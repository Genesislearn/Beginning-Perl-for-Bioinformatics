\chapter{Subroutines and Bugs}
\label{chap:chapter6}
\minitoc

In this chapter you'll extend your basic knowledge in two directions:

\begin{itemize}
  \item Subroutines
  \item Using the Perl debugger
\end{itemize}

Subroutines are an important way to structure programs. You'll use them in \autoref{chap:chapter7}, where you'll learn how to use randomization to simulate the mutation of DNA. The Perl debugger examines a program's behavior in "slow motion" and helps you find those pesky bugs. 

\section{Subroutines}
Subroutines are an important way to organize a program and are used in all major programming languages.

A \textit{subroutine} wraps up a bit of code, gives the code a name, and provides a way to pass in some values for its calculations and then report back the results. The rest of the program can then use the subroutine's code just by calling its name, giving the needed values to pass in to the subroutine code and then collecting the results. This use or "invocation" of a subroutine is commonly referred to as \textit{calling} the subroutine. You can think of a subroutine as a program within a program; just as you run programs to get results, so your programs call subroutines to get results. Once you have a subroutine, you can use it in a program simply by knowing which values to pass in and what kind of values to expect it to pass out. 

\subsection{Advantages of Subroutines}
Subroutines provide several benefits. They endow programs with abstraction, modularization, and the ability to create large programs by organizing the code into manageable chunks with defined inputs and outputs.

Say you need to calculate something, for instance the mean of a distribution at several places in a program or in several different programs. By writing this calculation as a subroutine, you can write it once, and then call it whenever you need it, thus making your program: 

\begin{itemize}
  \item Shorter, since you're reusing the code.
  \item Easier to test, since you can test the subroutine separately.
  \item Easier to understand, since it reduces clutter and better organizes programs.
  \item More reliable, since you have less code when you reuse subroutines, so there are fewer opportunities for something to go wrong.
  \item Faster to write, since you may, for example, have already written some subroutines that handle basic statistics and can just call the one that calculates the mean without having to write it again. Or better yet, you found a good statistics library someone else wrote, and you never had to write it at all.
\end{itemize}

There is another subtle, yet powerful idea at work here. Subroutines can themselves call other subroutines, that is, a subroutine can use another subroutine for help in its calculations.\footnote{Subroutines can even call themselves, and this so-called recursion can be an elegant way to compute (see \autoref{chap:chapter11}).} By writing a set of subroutines, each of which does one or a few things well, you can combine them in various ways to make new subroutines. You can then combine the new subroutines, and so on, and the end result can be large and flexible programming systems. Decomposing problems into sets of subroutines that can be conveniently combined allows you to create environments that can grow and adapt to changing conditions with a minimum of effort.

The trick of all this is in how you partition the code into subroutines. You want subroutines that encapsulate something that will be generally useful, and not just called once (although that sometimes can be useful too). There are various rules of thumb: a subroutine should do one thing well, and it should be no more than a page or two of code. These are not real rules, and exceptions are frequent, but they can help you divide your code into manageable chunks, suitable for subroutines. 

\subsection{Writing Subroutines}
Let's look at how subroutines are used and then at how they're defined.

To use a subroutine, you pass data into the subroutine as \textit{arguments}, and then you collect the return value(s) of the subroutine. For example, say you want a subroutine that, given some DNA, appends "ACGT" to the end of the DNA and returns the new, longer DNA. Let's call the subroutine \textit{addACGT}. In Perl, you usually call a subroutine by typing its name, followed by a parenthesized list of arguments (if any). For example, here's a call to \verb|addACGT| with the one argument \verb|$dna|: 

\begin{lstlisting}
addACGT($dna);
\end{lstlisting}

When calling a subroutine, older versions of Perl required starting the name of a subroutine with the \& (ampersand) character. It's still okay to do so (e.g., : \textit{\&addACGT}), but these days the ampersand is usually omitted.\footnote{There are times, even in the newer versions of Perl, when an ampersand is required; you'll see one such case in \autoref{chap:chapter11}, in \autoref{sect:section11.2.3}, which describes the \textit{File::Find} module. (See also the \textit{defined} and \textit{undef} functions in the documentation or the \textit{perlref} manpage).}

\autoref{exam:example6.1} demonstrates a subroutine that shows in detail how this works. 

\textbf{Example 6-1. A subroutine to append ACGT to DNA}
\lstinputlisting[label=exam:example6.1]{./scripts/example6-1.pl}

\autoref{exam:example6.1} produces the following output:

\begin{lstlisting}
I added ACGT to CGACGTCTTCTCAGGCGA and got CGACGTCTTCTCAGGCGAACGT
\end{lstlisting}

We'll now look at this code to see how subroutines are defined and used in a Perl program. 

The first thing to notice, taking the large view, is that the program now has two sections. The first section starts from the beginning of the program and ends with the \verb|exit| command. Following that (and announced by a blizzard of comments for easy reading) is a section for subroutine definitions, in this case, only the one definition for subroutine \textit{addACGT}. It is common to place all subroutine definitions together at the end of a program, for ease in reading. Usually they're listed alphabetically or in some other convenient way.

Actually, it is legal to put the subroutine definitions almost anywhere in a program. This is because Perl first scans through the code and does things like check the syntax and learn subroutine definitions, before it starts to run the program. In particular, subroutine definitions can come after the point in the code where you use them (not necessarily before, which many people assume is the rule), and they don't have to be grouped together but can be scattered throughout the code. But our method of collecting them together at the end can make reading a program much easier. The possible exception is when a small subroutine is used in one section of code, as sometimes happens with the \textit{sort} function, for instance. In this case having the definition right there can save the reader paging back and forth between the subroutine definition and its use. Usually, it's more convenient to read the program without the subroutine definitions, to get the overall flow of the program first, and then go back and look into the subroutines, if necessary.

As you see, \autoref{exam:example6.1} is very simple. It first stores some DNA into the variable \verb|$dna| and then passes that variable as an argument to the subroutine call, which looks like this: \verb|addACGT($dna)|. The subroutine is called by its name, followed by parentheses containing the arguments to the subroutine. There may be no arguments, or if more than one, they are separated by commas. The value returned by the subroutine can be saved; in this program the value is saved in a variable called \verb|$longer_dna|, which is then printed, and the program exits.  

The part of the program from the beginning to the \textit{exit} statement is called variously the \textit{main program} or the \textit{main body} of the program. By looking over this section of the code, you can see what happens from the beginning to the end of the program without looking into the details of the subroutines.

Now that you've looked over the main program of \autoref{exam:example6.1}, it's time to look at the subroutine definition and how it uses the principal of scoping. 

\section{Scoping and Subroutines}
A subroutine is defined by the \textit{reserved word}\footnote{A reserved word is a fundamental, defined word in the Perl language, such as \verb|if|, \verb|while|, \verb|foreach|, or \verb|sub|.} for subroutine definitions, \verb|sub|; the subroutine's name, in this case, \textit{addACGT}; and a \textit{block}, enclosed in a pair of matching curly braces. This is the same kind of block seen earlier in loops and conditional statements that groups statements together.

In \autoref{exam:example6.1}, the name of the subroutine is \verb|addACGT|, and the block is everything after the name. Here is the subroutine definition again:

\begin{lstlisting}
sub addACGT {
  my($dna) = @_;

  $dna .= 'ACGT';
  return $dna;
}
\end{lstlisting}

Now let's look into the block of the subroutine.

A subroutine is like a separate helper program for the main program, and it needs to have its own variables. You will use two types of variables in your subroutines in this book:\footnote{In the subroutines in this book, we won't use global variables, which can be seen by both the main program and the subroutines; nor will we use variables declared with \verb|local|, which provides a different kind of scoping restriction than \verb|my|.}

\begin{itemize}
  \item Arguments passed in to the subroutine
  \item Other variables declared with \verb|my| and restricted to the scope of the subroutine
\end{itemize}

Arguments are the values given to a subroutine when it is used, or called. The values of the arguments are passed into the subroutine by means of the special variable \verb|@_|, as you'll see in the next section.

Other variables a subroutine might use must be protected from interacting with variables in other parts of the program, so they have effect only within the subroutine's own scope. This is accomplished by declaring them as \verb|my| variables, as will be explained shortly.

Finally, most subroutines return their results via the \textit{return} function. This can return a single scalar as in \verb|return $dna;| in our subroutine \textit{addACGT}, in a list of scalars as in \verb|return ($dna1, $dna2);|, in an array as in \verb|return @lines;|, and more. 

\subsection{Arguments}
To \textit{call} a subroutine means to type its name and give it appropriate arguments and, usually, collect its results. \textit{Arguments}, sometimes called \textit{parameters}, usually contain the data that the subroutine computes on. In \autoref{exam:example6.1}, this is the call of the subroutine \textit{addACGT} with the argument \verb|$dna|:

\begin{lstlisting}
$longer_dna = addACGT($dna);
\end{lstlisting}

The essential point is that whenever you, the programmer, want to use a subroutine, you can call it with whatever argument(s) it is designed to accept and with which you need to compute (in this case, whatever DNA that needs \verb|ACGT| appended to it) and the value of each argument appears in the subroutine in the \verb|@_| array.

When you call a subroutine with certain arguments, the names of the arguments you provide in the call are not important inside the subroutine. Only the values of those arguments that are actually passed inside the subroutine are important. The subroutine typically collects the values from the \verb|@_| array and assigns them to new variables that may or may not have the same names as the variables with which you called the subroutine. The only thing preserved is the order of the values, not the names of the variables containing the values.

Here's how it works. The first line in the subroutine's block is:

\begin{lstlisting}
my($dna) = @_; 
\end{lstlisting}

The values of the arguments from the call of the subroutine are passed into the subroutine in the special array variable \verb|@_|. You know it's an array because it starts with the \verb|@| character. It has the brief name "\_", and it's a special array variable that comes predefined in Perl programs. (It's not a name you should pick for your own arrays.) The array \verb|@_| contains all the scalar values passed into the subroutine. These scalar values are the values of the arguments to the subroutine. In this case, there is one scalar value: the string of DNA that's the value of the variable \verb|$dna| passed in as an argument.

If the subroutine has more arguments—for instance one argument for DNA, one for the associated protein, and one for the name of the gene—they are all passed in and assigned to \verb|my| variables inside the subroutine:

\begin{lstlisting}
my($dna,$protein,$name_of_gene) = @_;
\end{lstlisting}

If there are no arguments, just omit that statement in the subroutine.

After the statement:

\begin{lstlisting}
my($dna) = @_;
\end{lstlisting}

executes in the subroutine, the passed-in value is assigned to the subroutine's variable \verb|$dna|. The next section explains why this is a new variable specific to the subroutine. The subroutine's variable can be called anything; it certainly doesn't have to be the same name as the argument, as it happens to be in this example. What's cool about scoping is that it doesn't matter if it is or not. 

\begin{adjustwidth}{2cm}{2cm}
  \parpic[l]{
  \includegraphics[width=1cm]{warning.png}
  }
  Beware the common mistake of forgetting the \verb|@_| array when naming your arguments in a subroutine, that is, using the statement:
  \begin{lstlisting}
my($dna);
  \end{lstlisting}
  instead of:
  \begin{lstlisting}
my($dna) = @_;
  \end{lstlisting}
  If you make this mistake, the values of the arguments won't appear in your subroutine, even though their names are declared. 
\end{adjustwidth}

\subsection{Scoping}
By keeping all variables a subroutine uses active only within the subroutine, you can make it safe to call the subroutines from anywhere. You make the variables specific only to the subroutine by declaring them as \verb|my| variables. \verb|my| is a keyword defined in Perl that limits variables to the block in which they are used (in this case, the block is the subroutine). \footnote{There are different models of scoping; \verb|my| implements a type called \textit{lexical scoping}, also known as \textit{static scoping}. Another method is available in Perl via the \textit{local} construct, but you almost always want to use \verb|my|.} 

Hiding variables and making them local to only a restricted part of a program, is called \textit{scoping}. In Perl, using \verb|my| variables is known as \textit{lexical scoping}, and it's an essential part of modularizing your programs.

You declare that a variable is a \verb|my| variable like this:

\begin{lstlisting}
my($x); 
\end{lstlisting}

or:

\begin{lstlisting}
my $x ; 
\end{lstlisting}

or, combining the declaration with an initialization to a value:

\begin{lstlisting}
my($x) = '49'; 
\end{lstlisting}

or, if you're collecting an argument within a subroutine:

\begin{lstlisting}
my($x) = @_; 
\end{lstlisting}

Once a variable is declared in this fashion, it exists only until the end of the block it was declared in. So in a subroutine, if you declare all your variables like this (both the arguments and any other variables), they are active only in the subroutine. If any variable has the same name as another variable elsewhere in the program, you don't have to worry, because the \verb|my| declaration actually creates a new variable, active only in the enclosing block, and any other variable of the same name used elsewhere outside the block is kept separate.

The example that showed collecting an argument in a subroutine uses parentheses around the variable. Because \verb|@_| is an array, the parentheses around the new variables put them in array context and ensure that they are initialized correctly (see \autoref{chap:chapter4}).

\begin{adjustwidth}{2cm}{2cm}
  \parpic[l]{
  \includegraphics[width=1cm]{warning.png}
  }
  Always declare all your variables in your subroutines—even those variables that don't come in as arguments—such as the \verb|my| construct. 
\end{adjustwidth}

Why use scoping? \autoref{exam:example6.2} shows the trouble that can happen when you don't. Recall that one of the advantages of subroutines is writing a useful bit of code once and then using it whenever you need it. \autoref{exam:example6.2} is a program that has a variable in the main program with the same name as a variable in a subroutine it calls. This can easily happen if you write the subroutine at a time other than the main program (say six months later) or if you call a subroutine someone else wrote. 

\textbf{Example 6-2. The pitfalls of not using my variables}
\lstinputlisting[label=exam:example6.2]{./scripts/example6-2.pl}

\autoref{exam:example6.2} gives the following output:

\begin{lstlisting}
I changed all the A's in TTTTT to T's and got TTTTT 
\end{lstlisting}

What was expected was this output:

\begin{lstlisting}
I changed all the A's in AAAAA to T's and got TTTTT 
\end{lstlisting}

You can get by this expected output by changing the definition of subroutine \textit{A\_to\_T} to the following, in which the variable \verb|$dna| in the subroutine is declared as a \verb|my| variable: 

\begin{lstlisting}
sub A_to_T {
  my($input) = @_;
  my($dna) = $input;
  $dna =~ s/A/T/g;
  return $dna;
}
\end{lstlisting}

Where exactly did \autoref{exam:example6.2} go wrong? When the program entered the subroutine, and used the variable \verb|$dna| to calculate the string with A's changed to T's, the Perl language saw that there was already a variable \verb|$dna| being used in the main part of the program and just kept using it. When the program returned from the subroutine and got to the \verb|print| statement, it was still using the same (the one and only) variable \verb|$dna|. So, when it printed the results, the variable \verb|$dna|, instead of having the original DNA in it, had the altered DNA that had been computed in the subroutine.

Now this sort of thing can happen a lot. Programmers tend to use certain names for variables a great deal: the usual suspects are names such as \verb|$tmp|, \verb|$temp|, \verb|$x|, \verb|$a|, \verb|$number|, \verb|$variable|, \verb|$var|, \verb|$array|, \verb|$input|, \verb|$output|, \verb|$result|, \verb|$data|, \verb|$file|, \verb|$filename|, and so on. Bioinformaticians are quite fond of \verb|$dna|, \verb|$protein|, \verb|$motif|, \verb|$sequence|, and the like. As you start using libraries of subroutines from other people and as your programs get larger, it's much easier—and a whole lot safer—to let the Perl language worry about avoiding the problem of name collisions.

In fact, from now on we're going to stop using undeclared variables. From this point forward, all our variables, even those in the main program, will be declared with \verb|my|. You can enforce this discipline by adding the following directive to your programs:

\begin{lstlisting}
use strict;
\end{lstlisting}

which has the effect of insisting that your programs have all their variables declared as \verb|my| variables.

Lest you rail at this seemingly unnecessary complication to your coding, compared to the simpler and happier days of \autoref{chap:chapter4} and \autoref{chap:chapter5}, you should know that many languages require declarations for all their variables. The fact that in Perl you don't have to enforce strict scoping is handy when you're writing short programs, for example, or when you're trying to teach programming without hitting the students with a thousand details at the beginning.

Another benefit you get from strict scoping happens if you accidently misspell a variable name while writing a program. If the variables aren't being declared, Perl creates a new variable with the (misspelled) name. The program may not work correctly, and it may be hard to find where the problem is. By strictly scoping the program, any misspelled variables are also undeclared, and Perl complains about it, saving you hours or days of hair-pulling and bad language.

Finally, let's recap how scoping, arguments, and subroutines work by taking another look at \autoref{exam:example6.1}. The subroutine is called by writing its name \textit{addACGT}, passing it the argument \verb|$dna|, and collecting results (if any) by assignment to \verb|$longer_dna|:

\begin{lstlisting}
$longer_dna = addACGT($dna); 
\end{lstlisting}

The first line in the subroutine gets the value of the argument from the special variable \verb|@_|, and stores it in its own variable called \verb|$dna|, which can't be seen outside the subroutine because it uses \verb|my|. Even though the original variable outside the subroutine is also called \verb|$dna|, the variable called \verb|$dna| within the subroutine is an entirely new variable (with the same name) that belongs only to the subroutine due to the use of \verb|my|. This new variable is in effect only during the time the program is in the subroutine. Notice in the output from the \verb|print| statement at the end of \autoref{exam:example6.2} that even though a variable called \verb|$dna| is lengthened inside the subroutine, the original variable, \verb|$dna|, outside the subroutine isn't changed. 

\section{Command-Line Arguments and Arrays}
\autoref{exam:example6.3} is another program that uses subroutines. You use the command line to give the program information it needs (such as filenames, or strings of DNA) without having to interactively answer the program's prompts. This is useful if you're scheduling a program to run at a time when you won't be there, for instance.

\autoref{exam:example6.3} also shows a little more about using arrays. You'll see how to use subscripts to access a specific element of an array.

For command-line programs, you type the name of the program, followed by the arguments to the program, if any, and then hit the Enter (or Return) key to start the program running. In \autoref{exam:example6.3}, when the user types the program name, she follows that with the argument, which, in this case, is just the string of DNA in which she'll count the G's. So the program is called and returns an answer like so:

\begin{lstlisting}
AAGGGGTTTCCC

The DNA AAGGGGTTTCCC has 4 G's in it!
\end{lstlisting}

Of course, many programs come with a graphical user interface (GUI). This gives the program some or all of the computer screen and usually includes such things as menus, buttons, and places to type in values to set parameters from the keyboard.

However, many programs are run from a command line. Even the newer MacOS X, which is built on top of Unix, now provides a command line. (Although most Windows users don't use the MS-DOS command window much, it's still useful, e.g., for running Perl programs.) As already mentioned, running a program noninteractively, passing parameters in as command-line arguments, allows you to run the program automatically, say in the middle of the night when no one is actually sitting at the computer.  

\autoref{exam:example6.3} counts the number of G's in a string of DNA. 

\textbf{Example 6-3. Counting the G's in some DNA on the command line}
\lstinputlisting[label=exam:example6.3]{./scripts/example6-3.pl}

Now let's look at how this program works, while examining and explaining the new features. For starters, notice the new line:

\begin{lstlisting}
use strict;
\end{lstlisting}

which I will use from now on to ensure all variables are declared with \verb|my|, thus enforcing lexical scoping.

Perl has some special variables it sets so you can easily use the arguments from the command line. Every Perl program has an array variable \verb|@ARGV| that contains any command-line arguments. Also, there's a special variable called \verb|$0| (a zero) that has the name of the program as it was called from the command line.

Notice in \autoref{exam:example6.3} that an informative message is defined in the variable \verb|$USAGE| and that it begins with the value of the variable \verb|$0|, followed an indication of the arguments the program needs. This is a common practice; if the user doesn't give the program what it needs, which is determined by some kind of test, the program prints information about how to properly use it and exits.

In fact, this program does check to see if any arguments were typed on the command line. It checks if \verb|@ARGV| has anything in it, in which case it evaluates to \verb|true|; or if it is completely empty, in which case it evaluates to \verb|false|. If you want the program to require an argument be given, you can use the \verb|unless| conditional, and if \verb|@ARGV| is empty, to print out the \verb|$USAGE| statement and exit the program: 

\begin{lstlisting}
unless(@ARGV) {
  print $USAGE;
  exit;
}
\end{lstlisting}

The next bit of code shows something new about arrays, namely, how to extract one element from an array, as referenced by a subscript. In other words, it shows how to get at the first, fourth, or whichever element. The code in \autoref{exam:example6.3} shows how to extract the first element, which as you've seen, is numbered 0:

\begin{lstlisting}
my($dna) = $ARGV[0];
\end{lstlisting}

Now you already know there is a first element, since you've just tested to make sure the array isn't empty. You get the first element of array \verb|@ARGV| by changing the \verb|@| to a \verb|$| and appending square brackets containing the desired subscript; 0 for the first element, 1 for the second element, and so on. This syntax indicates that since you're now looking at just one element of the array, and it's a scalar variable, you use the dollar sign, as you would any other scalar variables.

In \autoref{exam:example6.3}, you copy this first (and only) element of the command-line array \verb|@ARGV| into the variable \verb|$dna|.

Finally comes the call to the subroutine, which contains nothing new but fulfills a dream from the final paragraph of \autoref{chap:chapter5}:

\begin{lstlisting}
my($num_of_Gs) = countG ( $dna );
\end{lstlisting}

\section{Passing Data to Subroutines}
When you start parsing GenBank, PDB, and BLAST files in later chapters, you'll need more complicated arguments to your subroutines to hold the several fields of data you'll parse out of the records. These next sections explain the way it's done in Perl. You can skim this section and return for a closer read when you get to \autoref{chap:chapter10}. 

\subsection{Subroutines: Pass by Value}
\label{sect:section6.4.1}
So far, all our subroutines have had fairly simple arguments. The values of these arguments are copied and passed to the subroutines, and whatever happens to those values in the subroutine doesn't affect the values of the arguments in the main program. This is called \textit{pass by value} or \textit{call by value}. For example: 

\begin{lstlisting}
#!/usr/bin/perl -w
# Example of pass-by-value (a.k.a. call-by-value)

use strict;

my $i = 2;

simple_sub($i);

print "In main program, after the subroutine call, \$i equals $i\n\n";

exit;

################################################################################
# Subroutines
################################################################################
sub simple_sub {

  my($i) = @_;

  $i += 100;

  print "In subroutine simple_sub, \$i equals $i\n\n";
}
\end{lstlisting}

This gives the following output:

\begin{lstlisting}
In subroutine simple_sub, $i equals 102

In main program, after the subroutine call, $i equals 2
\end{lstlisting}

\subsection{Subroutines: Pass by Reference}
If you have more complicated arguments, say a mixture of scalars, arrays, and hashes, Perl often cannot distinguish between them. Perl passes all arguments into the subroutine as a single array, the special \verb|@_| array. If there are arrays or hashes as arguments, their elements get "flattened" out into this single \verb|@_| array in the subroutine. Here's an example: 

\begin{lstlisting}
#!/usr/bin/perl -w
# Example of problem of pass-by-value with two arrays

use strict;

my @i = ('1', '2', '3');
my @j = ('a', 'b', 'c');

print "In main program before calling subroutine: i = " .  "@i\n";
print "In main program before calling subroutine: j = " .  "@j\n";

reference_sub(@i, @j);

print "In main program after calling subroutine: i = " .  "@i\n";
print "In main program after calling subroutine: j = " .  "@j\n";

exit;

################################################################################
# Subroutines
################################################################################

sub reference_sub {

  my(@i, @j) = @_;

  print "In subroutine : i = " . "@i\n";
  print "In subroutine : j = " . "@j\n";

  push(@i, '4');

  shift(@j);
}
\end{lstlisting}

The following output illustrates the problem of this approach:

\begin{lstlisting}
In main program before calling subroutine: i = 1 2 3
In main program before calling subroutine: j = a b c
In subroutine : i = 1 2 3 a b c
In subroutine : j = 
In main program after calling subroutine: i = 1 2 3
In main program after calling subroutine: j = a b c
\end{lstlisting}

As you see, in the subroutine all the elements of \verb|@i| and \verb|@j| were grouped into one \verb|@_| array. All distinction between the two arrays you started with was lost in the subroutine. When you try to get the two arrays back in the statement:

\begin{lstlisting}
my(@i, @j) = @_;
\end{lstlisting}

Perl assigns everything to the first array, \verb|@i|. This behavior makes passing multiple arrays into subroutines somewhat dicey. 

Also, as usual, the original arrays in the main program were not affected by the subroutine, since you used lexical scoping (\verb|my| variables).

To get around this problem, you can pass arguments into subroutines in a style called \textit{pass by reference} or \textit{call by reference}. Using pass by reference, you can pass a subroutine any collection of scalars, arrays, hashes, and more, and the subroutine can distinguish between them. There is a price to pay: the resulting code looks a little more complex. But the payoff is often well worth it.

There is one big difference in the behavior of arguments that are passed by reference. When argument variables are passed in this fashion, anything you do to the values of the argument variables in the subroutine also affects the values of the arguments in the main program.

To call a subroutine that has its arguments passed by reference, you call it the same way as before, with one difference: you must preface the argument names with a backslash. In the example of pass by reference in this section, the subroutine call is accomplished like so:

\begin{lstlisting}
reference_sub(\@i, \@j);
\end{lstlisting}

As you see here, the arguments are two arrays, and, to preserve the distinction between them as they are passed into the \textit{reference\_sub} subroutine, they are passed by reference by prepending their names with a backslash.

Within the subroutine, there are a few changes. First, the arguments are collected from the \verb|@_| array, and saved as scalar variables. This is because a reference is a special kind of data that is stored in a scalar variable, no matter whether it's a reference to a scalar, an array, a hash, or other. The example collects its arguments as follows:

\begin{lstlisting}
my($i, $j) = @_;
\end{lstlisting}

reading them from the \verb|@_| array as scalars.

The subroutine has to do one more thing with these referenced arguments. When it uses them, it has to dereference them. To dereference a referenced argument, you have to prepend the reference with the symbol that shows what kind of variable it is: a \verb|$| for a scalar, \verb|@| for an array, \verb|%| for a hash. So these variables have two symbols before their name—reading left to right, their usual symbol and then a \verb|$| that indicates the variable is a reference. The lines:

\begin{lstlisting}
push(@$i, '4');
shift(@$j);
\end{lstlisting}

in the following subroutine are the ones that manipulate the arguments.  The \textit{push} adds an element '4' to the end of the \verb|@i| array, and the \textit{shift} removes the first element from the \verb|@j| array. Because these arrays have been passed by reference, their names in the subroutine are \verb|@$i| and \verb|@$j|. (If you want to look at the third element of the \verb|@j| array, which normally is \verb|$j[2]|, you'd say \verb|$j[2]|.)

Whatever changes you make to the arguments in the subroutine also take effect in the main program. This is because the references are references to the actual arguments; they are not copies of their values as in pass by value. So, as you see in the example, after calling the subroutine, the arrays in the main program have been altered accordingly:

\begin{lstlisting}
#!/usr/bin/perl
# Example of pass-by-reference (a.k.a. call-by-reference)

use strict;
use warnings;

my @i = ('1', '2', '3');
my @j = ('a', 'b', 'c');

print "In main program before calling subroutine: i = " .  "@i\n";
print "In main program before calling subroutine: j = " .  "@j\n";

reference_sub(\@i, \@j);

print "In main program after calling subroutine: i = " .  "@i\n";
print "In main program after calling subroutine: j = " .  "@j\n";

exit;

################################################################################
# Subroutines
################################################################################

sub reference_sub {
  my($i, $j) = @_;

  print "In subroutine : i = " . "@$i\n";
  print "In subroutine : j = " . "@$j\n";

  push(@$i, '4');
  shift(@$j);
}
\end{lstlisting}

This gives the following output:

\begin{lstlisting}
In main program before calling subroutine: i = 1 2 3
In main program before calling subroutine: j = a b c
In subroutine : i = 1 2 3
In subroutine : j = a b c
In main program after calling subroutine: i = 1 2 3 4
In main program after calling subroutine: j = b c
\end{lstlisting}

The subroutine can now distinguish between the two arrays passed on as arguments.The changes that were made inside the subroutine to the variables remain in effect after the subroutine has ended, and you've returned to the main program. This is the essential characteristic of pass by reference. 

\section{Modules and Libraries of Subroutines}
As you start to build a collection of subroutines, you'll find that you're copying them a lot from existing programs and pasting them into new programs. The subroutines then appear in multiple program. This makes the listings of your program code a bit verbose and repetitive. It also makes modifying a subroutine more complicated because you have to modify all the copies.

In short, subroutines are great, but if you have to keep copying them into each new program you write, it gets tiresome. So it's time to start collecting subroutines into the handy files called \textit{modules} or \textit{libraries}.

Here's how it works. You put all your reusable subroutines into a separate file. (Or, as you keep writing more and more code, and things get complicated, you may want to organize them into several files.) Then you just name the file in your program and \textit{presto}: the subroutine's definitions all get read in, just as if they were in your program. To do this, you use the Perl built-in function \textit{use}, which reads in the subroutine library file.

Let's call this module \textit{BeginPerlBioinfo.pm}. You can put all your subroutine definitions into it, just as they appear in the program code. Then you can create the module by typing in the subroutine definitions as you read the book; or, more easily, it can be downloaded from the book's web site. But there is one thing to remember when creating or adding to a module: \textit{the last line in a module must be \texttt{1;} or it won't work}. This \verb|1;| should be the last line of the \textit{.pm} file, not part of the last subroutine. If you forget this, you'll get an error message something like: 

\begin{lstlisting}
BeginPerlBioinfo.pm did not return a true value at jkl line 14.
BEGIN failed--compilation aborted at jkl line 14.
\end{lstlisting}

Now, to use any of the subroutines in \textit{BeginPerlBioinfo.pm}, you just have to put the following statement in your code, near the top (near the \verb|use strict| statement): 

\begin{lstlisting}
use BeginPerlBioinfo;
\end{lstlisting}

Note that \textit{.pm} is left off the name on purpose: that's how Perl handles the names of modules.

There's one last thing to know about using modules to load in subroutines: the Perl program needs to know where to find the module. If you're doing all your work in one folder, everything should work okay.  If Perl complains about not being able to find \textit{BeginPerlBioinfo.pm}, give full pathname information to the module. If the full pathname is \textit{/home/tisdall/book/BeginPerlBioinfo.pm}, then use this in your program:

\begin{lstlisting}
use lib '/home/tisdall/book';
use BeginPerlBioinfo;
\end{lstlisting}

There are other ways to tell Perl where to look for modules; consult the Perl documentation for \verb|use|.

Beginning in \autoref{chap:chapter8}, I'll define subroutines and show the code, but you'll be putting them into your module and typing:

\begin{lstlisting}
use BeginPerlBioinfo;
\end{lstlisting}

This module is also available for download at this book's web site. 

\section{Fixing Bugs in Your Code}
Now let's talk about what to do when your program is having trouble.

A program can go wrong in any number of ways. Maybe it won't run at all. A look at the error messages, especially the first line or two of the error messages, usually leads you to the problem, which will be somewhere in the syntax, and its solution, which will be to use the correct syntax (e.g., matching braces or ending each statement with a semicolon).

Your program may run but not behave as you planned. Then you have some problem with the logic of the program. Perhaps at some point, you've zigged when you should have zagged, like adding instead of subtracting or using the assignment operator = when you meant to test for equality between two numbers with ==. Or, the problem could be that you just have a poor design to accomplish your task, and it's only when you actually try it out that the flaw becomes evident.

However, sometimes the problem is not obvious, and you have to resort to the heavy artillery.

Fortunately, Perl has several ways to help you find and fix bugs in your programs. The use of the statements \verb|use strict;| and \verb|use warnings;| should become a habit, as you can catch many errors with them. The Perl debugger gives you complete freedom to examine a program in detail as it runs.

\subsection{use warnings; and use strict;}
In general, it's not too hard to tell when the syntax of a program is wrong because the Perl interpreter will produce error messages that usually lead you right to the problem. It's much harder to tell when the program is doing something you didn't really want. Many such problems can be caught if you turn on the warnings and enforce the strict use of declarations.

You have probably noticed that all the programs in this book up until now start with the command interpreter line:

\begin{lstlisting}
#!/usr/bin/perl -w
\end{lstlisting}

That \verb|-w| turns on Perl's warnings and attempts to find potential problems in your code and then to warn you about them. It finds common problems such as variables that are declared more than once, and so on, things that are not syntax errors but that can lead to bugs.

Another way to turn on warnings is to add the following statement near the top of the program:

\begin{lstlisting}
use warnings;
\end{lstlisting}

The statement \verb|use warnings;| may not be available on your version of Perl, if it's an old one. So if your Perl complains about it, take it out and use the \textit{-w} command instead, either on the command interpreter line, or from the command line:

\begin{lstlisting}[language=bash]
$ perl -w my_program
\end{lstlisting}

However, \verb|use warnings;| is a bit more portable between different operating systems. So, from now on, that's the way I'll turn on warnings in my code. Another important helper you should use is the following statement placed near the top of your program (next to \verb|use warnings;|):

\begin{lstlisting}
use strict;
\end{lstlisting}

As mentioned previously, this forces you to declare your variables. (It has some options, that are beyond the scope of this book.) It finds misspelled variables, undeclared variables that may be interfering with other parts of the program, and so on. 

\begin{adjustwidth}{2cm}{2cm}
  \parpic[l]{
  \includegraphics[width=1cm]{note.png}
  }
  It's best to always use both \verb|use strict;| and \verb|use warnings;| when writing your Perl code. 
\end{adjustwidth}

\subsection{Fixing Bugs with Comments and Print Statements}
Sometimes you can identify misbehaving code by selectively commenting out sections of the program until you find the part that seems to cause the problem. You can also add \verb|print| statements at suspicious parts of a misbehaving program to check what certain variables are doing. Both of these are time-honored programming techniques, and they work well in almost any programming language.

Commenting out sections of code can be particularly helpful when the error messages that you get from Perl don't point you directly at the offending line. This happens occasionally. When it does happen you may, by trial and error, discover that commenting out a small section of code causes the error messages to go away; then you know where the error is occurring.

Adding \verb|print| statements can also be a quick way to pinpoint a problem, especially if you already have some idea of where the problem is. As a novice programmer, however, you may find that using the Perl debugger is easier than adding \verb|print| statements. In the debugger, you can easily set \verb|print| statements at any line. For instance, the following debugger command says to print the values of \verb|$i| and \verb|$k| before line 48:

\begin{lstlisting}
a 48 print "$i $k\n"
\end{lstlisting}

Once you learn how to do it, this method is generally faster and easier than editing the Perl program and adding \verb|print| statements by hand. Using this method is partly a matter of taste, since some extremely good Perl programmers prefer to do it the old-fashioned way, by adding \verb|print| statements. 

\subsection{The Perl Debugger}
My favorite way to deal with nonobvious bugs in my programs is to use the Perl debugger. The problem with bugs in code is that once a program starts running, all you can see is the output; you can't see the steps a program is taking. The Perl debugger lets you examine your program in detail, step by step, and almost always can lead you quickly to the problem. You'll also find that it's easy to use with a little practice.

There are situations the Perl debugger can't handle well: interacting processes that depend on timing considerations, for instance. The debugger can examine only one program at a time, and while examining, it stops the program, so timing considerations with other processes go right out the window.

For most purposes, the Perl debugger is a great, essential, programming tool. This section introduces its most important features. 

\subsubsection{A program with bugs}
\autoref{exam:example6.4} has some bugs we can examine. It's supposed to take a sequence and two bases, and output everything from those two bases to the end of the sequence (if it can find them in the sequence). The two bases can be given as an argument, or if no argument is given, the program uses the bases TA by default.

There is one new thing in \autoref{exam:example6.4}. The \textit{next} statement affects the control flow in a loop. It immediately returns the control flow to the next iteration of the loop, skipping whatever else would have followed. Also, you may want to recall \verb|$_|, which we discussed back in \autoref{exam:example5.5} in the context of a \verb|foreach| loop. 

\textbf{Example 6-4. A program with a bug or two}
\lstinputlisting[label=exam:example6.4]{./scripts/example6-4.pl}

Here's the output of two runs of \autoref{exam:example6.1}:

\begin{lstlisting}[language=bash]
$ perl example 6-4 AA

$ perl example 6-4
TA
\end{lstlisting}

Huh? It should have printed out \verb|AAGGCGA| when called with the argument \verb|AA|, and \verb|TAAGGCGA| when called with no arguments. There must be a bug in this program. But, if you look it over, there isn't anything obviously wrong. It's time to fire up the debugger. What follows is an actual debugging session on \autoref{exam:example6.4}, interspersed with comments to explain what's happening and why. 

\subsubsection{How to start and stop the debugger}
The debugger runs interactively, and you control it from the keyboard.\footnote{You also can run it automatically to produce a trace of the program in a file.} The most common way to start it is by giving the \textit{-d} switch to Perl at the command line. Since you're using buggy \autoref{exam:example6.4} to demonstrate the debugger, here's how to start that program:

\begin{lstlisting}[language=bash]
perl -d example6-4
\end{lstlisting}

Alternatively, you could have added a \textit{-d} flag to the command interpreter:

\begin{lstlisting}[language=bash]
#!/usr/bin/perl -d
\end{lstlisting}

On systems such as Unix and Linux where command interpretation works, this starts the debugger automatically.

To stop the debugger, simply type \verb|q|.

\subsubsection{Debugger command summary}
First, let's try to find the bug in \autoref{exam:example6.4} when it's called with no arguments:

\begin{lstlisting}
$ perl -d example6-4
Default die handler restored.

Loading DB routines from perl5db.pl version 1.07
Editor support available.

Enter h or 'h h' for help, or 'man perldebug' for more help.

main::(example6-4:11):    my $dna = 'CGACGTCTTCTAAGGCGA';
  DB<1> 
\end{lstlisting}

Let's stop right here at the beginning and look at a few things. After some messages, which may not mean a whole lot right now, you get the excellent information that the commands \verb|h| and \verb|h h| give more help. Let's try \verb|h h|:

\begin{lstlisting}
  DB<1> h h
List/search source lines:               Control script execution:
  l [ln|sub]  List source code            T           Stack trace
  - or .      List previous/current line  s [expr]    Single step [in expr]
  w [line]    List around line            n [expr]    Next, steps over subs
  f filename  View source in file         <CR/Enter>  Repeat last n or s
  /pattern/ ?patt?   Search forw/backw    r           Return from subroutine
  v          Show versions of modules     c [ln|sub]  Continue until position
Debugger controls:                        L           List break/watch/actions
  O [...]     Set debugger options        t [expr]    Toggle trace [trace expr]
  <[<]|{[{]|>[>] [cmd] Do pre/post-prompt b [ln|event|sub] [cnd] Set breakpoint
  ! [N|pat]   Redo a previous command     d [ln] or D Delete a/all breakpoints
  H [-num]    Display last num commands   a [ln] cmd  Do cmd before line
  = [a val]   Define/list an alias        W expr      Add a watch expression
  h [db_cmd]  Get help on command         A or W      Delete all actions/watch
  |[|]db_cmd  Send output to pager        ![!] syscmd Run cmd in a subprocess
  q or ^D     Quit                        R           Attempt a restart
Data Examination:       expr     Execute perl code, also see: s,n,t expr
  x|m expr      Evals expr in list context, dumps the result or lists methods.
  p expr        Print expression (uses script's current package).
  S [[!]pat]    List subroutine names [not] matching pattern
  V [Pk [Vars]] List Variables in Package.  Vars can be ~pattern or !pattern.
  X [Vars]     Same as "V current_package [Vars]".
For more help, type h cmd_letter, or run man perldebug for all docs.
  DB<2> 
\end{lstlisting}

It's a bit hard to read, but you have a concise summary of the debugger commands. You can also use the \verb|h| command, which gives several screens worth of information. The \verb=| h= command displays those several pages one at a time; the pipe at the beginning of a debugger command pipes the output through a pager, which typically advances a page when you hit the spacebar on your keyboard. You should try those out. Right now, however, let's focus on a few of the most useful commands. But remember that typing \verb|h| \textit{command} can give you help about the command. 

\subsubsection{Stepping through statements with the debugger}
Back to the immediate problem. When you started up the debugger, you saw that it stopped on the first line of real Perl code:

\begin{lstlisting}
  main::(example6-4:11):    my $dna = 'CGACGTCTTCTAAGGCGA';
\end{lstlisting}

There's an important point about the debugger you should understand right away. It shows the line it's about to execute, not the line it just executed.

So really, \autoref{exam:example6.4} hasn't done anything yet. You can see from the command summary that \verb|p| tells the debugger to print out values. If you ask it to print the value of \verb|$dna|, you'll find:

\begin{lstlisting}
  DB<2> p $dna

  DB<3> 
\end{lstlisting}

It didn't show anything because there's nothing to show; it hasn't even seen the variable \verb|$dna| yet. So you should execute the statement. There are two commands to use: \verb|n| or \verb|s| both execute the statement being displayed. (The difference is that \verb|n| or "next" skips the plunge into a subroutine call, treating it like a single statement; \verb|s| or "single step" enters a subroutine and single step you through that code as well.) Once you've given one of these commands, you can just hit Enter to repeat the same command.

Since there aren't any subroutines, you needn't worry about choosing between \verb|n| and \verb|s|, so let's use \verb|n|: 

\begin{lstlisting}
 DB<3> n
 main::(example6-4:12):    my @dna;
   DB<3> 
\end{lstlisting}

This shows the next line (you can see the line numbers of the Perl program at the end of the prompt). If you wish to see more lines, the \verb|w| or "window" command will serve: 

\begin{lstlisting}
  DB<3> w
9
10      # declare and initialize variables
11:     my $dna = 'CGACGTCTTCTAAGGCGA';
12==>   my @dna;
13:     my $receivingcommittment;
14:     my $previousbase = ''; 
15
16:     my $subsequence = '';
17
18:     if (@ARGV) {
  DB<3>
\end{lstlisting}

The current line—the line that will be executed next—is highlighted with an arrow (\verb|==>|).

The \verb|w| seems like a useful thing. Let's get more information about it with the help command \verb|h w|: 

\begin{lstlisting}
  DB<3> h w
w [line]        List window around line.
  DB<4> 
\end{lstlisting}

Actually, there's more—hitting \verb|w| repeatedly keeps showing more of the program; a minus sign backs up a screen. But enough of that.

Now that \verb|$dna| has been declared and initialized, the program seems wrong on the first statement: 

\begin{lstlisting}
  DB<4> p $dna
CGACGTCTTCTAAGGCGA
  DB<5> 
\end{lstlisting}

That's exactly what was expected. There's no bug, so let's continue examining the lines, printing out values here and there: 

\begin{lstlisting}
  DB<5> n
main::(example6-4:13):	my $receivingcommittment;
  DB<5> n
main::(example6-4:14):	my $previousbase = ''; 
  DB<5> n
main::(example6-4:16):	my $subsequence = '';
  DB<5> n
main::(example6-4:18):	if (@ARGV) {
  DB<5> p @ARGV

  DB<6> w
15
16:     my $subsequence = '';
17
18==>   if (@ARGV) {
19:         my $subsequence = $ARGV[0];
20      }else{
21:         $subsequence = 'TA';
22      }
23
24:     my $base1 = substr($subsequence, 0, 1);
  DB<6> n
main::(example6-4:21):	    $subsequence = 'TA';
  DB<6> n
main::(example6-4:24):	my $base1 = substr($subsequence, 0, 1);
  DB<6> p $subsequence
TA
  DB<7> n
main::(example6-4:25):	my $base2 = substr($subsequence, 1, 1);
  DB<7> n
main::(example6-4:28):	@dna = split ( '', $dna );
  DB<7> p $base1
T
  DB<8> p $base2
A
  DB<9>
\end{lstlisting}

So far, everything is as expected; the default subsequence \verb|TA| is being used, and the \verb|$base1| and \verb|$base2| variables are set to \verb|T| and \verb|A|, the first and second bases of the subsequence. Let's continue:

\begin{lstlisting}
  DB<9> n
main::(example6-4:39):    foreach (@dna) {
  DB<9> p @dna
CGACGTCTTCTAAGGCGA
  DB<10> p "@dna"
C G A C G T C T T C T A A G G C G A
  DB<11> 
\end{lstlisting}

This shows a trick with Perl and printing arrays: normally they are printed without any spacing between the elements, but enclosing an array in double quotes in a \verb|print| statement causes it to be displayed with spaces between the elements.

Again, everything seems okay, and we're about to enter a loop. Let's look at the whole loop first: 

\begin{lstlisting}
  DB<11> w
36       #
37       # At each loop, save the previous base.
38
39==>    foreach (@dna) {
40:          if ($receivingcommittment) {
41:              print;
42:              next;
43           } elsif ($previousbase eq $base1) {
44:              if ( /$base2/ ) {
45:                  print $base1, $base2; 
  DB<11> w
43           } elsif ($previousbase eq $base1) {
44:              if ( /$base2/ ) {
45:                  print $base1, $base2; 
46:                  $recievingcommitment = 1;
47               }
48           }
49:          $previousbase = $_;
50       }
51
52:      print "\n";
  DB<11>
\end{lstlisting}

Despite the few repeated lines resulting from the \verb|w| command, you can see the whole loop. Now you know something in here is going wrong: when you tested the program without giving it an argument, as it's running now, it took the default argument \verb|TA|, and so far it seemed okay. However, all it actually did in your test was to print out the \verb|TA| when it was supposed to print out everything in the string starting with the first occurrence of \verb|TA|. What's going wrong? 

\subsubsection{Setting breakpoints}
To figure out what's wrong, you can set a breakpoint in your code. A \textit{breakpoint} is a spot in your program where you tell the debugger to stop execution so you can poke around in the code. The Perl debugger lets you set breakpoints in various ways. They let you run the program, stopping only to examine it when a statement with a breakpoint is reached. That way, you don't have to step through every line of code. (If you have 5,000 lines of code, and the error happens when you hit a line of code that's first used when you're reading the 12,000th line of input, you'll be happy about this feature.)

Notice that the part of this loop that prints out the rest of the string, once the starting two bases have been found, is the \verb|if| block starting at line 40: 

\begin{lstlisting}
if ($receivingcommittment) {
  print;
  next;
}
\end{lstlisting}

Let's look at that \verb|$receivingcommittment| variable.

Here's one way to do this. Let's set a breakpoint at line 40. Type \verb|b 40| and then \verb|c| to continue, and the program proceeds until it hits line 40: 

\begin{lstlisting}
  DB<11> b 40
  DB<12> c
main::(example6-4:40):      if ($receivingcommittment) {
  DB<12> p
C
  DB<12> 
\end{lstlisting}

The last command, \verb|p|, prints out the element from the \verb|@dna| array you reached in the \verb|foreach| loop. Since you didn't specify a variable for the loop, it used the default \verb|$_| variable. Many Perl commands such as \verb|print| or pattern matching operate on the default \verb|$_| variable if no other variable is given. (It's the cousin of the \verb|@_| default array subroutines used to hold their parameters.) So the \verb|p| debugger command shows that you're operating on C from the \verb|@dna| array, which is the first character.

All well and good. But it would be good to have the program break when the variable \verb|$receivingcommittment| has a change in its value, and then single step from there, to see why the program isn't printing out the rest of the string. Recall that this variable is the flag whose change tells the program to print the rest of the string. First let's delete all other breakpoints: 

\begin{lstlisting}
  DB<12> D
Deleting all breakpoints...
\end{lstlisting}

You can "watch" the variable with \verb|W| like so: 

\begin{lstlisting}
  DB<12> W $receivingcommittment
  DB<13> c
TA
Debugged program terminated.  Use q to quit or R to restart,
  use O inhibit_exit to avoid stopping after program termination,
  h q, h R or h O to get additional info.  
  DB<13> 
\end{lstlisting}

Wait a minute! The \verb|W| command should indicate when \verb|$receivingcommittment| changes value. But when the program continued running with the \verb|c| command, it ran to the end, meaning that \verb|$receivingcommittment| never changed value. So let's start up the program again and break on the line that changes its value: 

\begin{lstlisting}
  DB<13> R
Warning: some settings and command-line options may be lost!
Default die handler restored.

Loading DB routines from perl5db.pl version 1.07
Editor support available.

Enter h or 'h h' for help, or 'man perldebug' for more help.

main::(example6-4:11):	my $dna = 'CGACGTCTTCTAAGGCGA';
  DB<13> w 45
42:              next;
43           } elsif ($previousbase eq $base1) {
44:              if ( /$base2/ ) {
45:                  print $base1, $base2; 
46:                  $recievingcommitment = 1;
47               }
48           }
49:          $previousbase = $_;
50       }
51
  DB<14> b 46
  DB<15> c
TAmain::(example6-4:46):             $recievingcommitment = 1;
  DB<15> n
main::(example6-4:49):          $previousbase = $_;
  DB<15> p $receivingcommittment

  DB<16> 
\end{lstlisting}

Huh? The code says it's assigning the variable a value of 1, but after you execute the code, with the \verb|n| and try to print out the value, it doesn't print anything.

If you stare harder at the program, you see that at line 66 you misspelled \verb|$receivingcommittment| as \verb|$recievingcommitment|. That explains everything; fix it and run it again:

\begin{lstlisting}[language=bash]
$ perl example6-4
TAAGGCGA 
\end{lstlisting}

Success! 

\subsubsection{Fixing another bug}
Now, did that fix the other bug when you ran \autoref{exam:example6.4} with an argument?

\begin{lstlisting}[language=bash]
$ perl example6-4 AA
GACGTCTTCTAAGGCGA
\end{lstlisting}

Again, huh? You expected \verb|AAGGCGA|. Can there be another bug in the program? Let's try the debugger again:

\begin{lstlisting}
$ perl -d example6-4 AA
Default die handler restored.

Loading DB routines from perl5db.pl version 1.07
Editor support available.

Enter h or 'h h' for help, or 'man perldebug' for more help.

main::(example6-4:11):	my $dna = 'CGACGTCTTCTAAGGCGA';
  DB<1> n
main::(example6-4:12):	my @dna;
  DB<1> n
main::(example6-4:13):	my $receivingcommittment;
  DB<1> n
main::(example6-4:14):	my $previousbase = ''; 
  DB<1> n
main::(example6-4:16):	my $subsequence = '';
  DB<1> n
main::(example6-4:18):	if (@ARGV) {
  DB<1> n
main::(example6-4:19):	    my $subsequence = $ARGV[0];
  DB<1> n
main::(example6-4:24):	my $base1 = substr($subsequence, 0, 1);
  DB<1> n
main::(example6-4:25):	my $base2 = substr($subsequence, 1, 1);
  DB<1> n
main::(example6-4:28):	@dna = split ( '', $dna );
  DB<1> p $subsequence

  DB<2> p $base1

  DB<3> p $base2

  DB<4> 
\end{lstlisting}

Okay, for some reason the \verb|$subsequence|, and therefore the \verb|$base1| and \verb|$base2| variables, are not getting set right. How come?

Check out line 19 where you declared a new \verb|my| variable in the block of the \verb|if| statement with the same name, \verb|$subsequence|. That's the variable you're setting, but it's disappearing as soon as the \verb|if| statement is over, because it's scoped in the block since it's a \verb|my| variable.

So again, you fix that problem by removing the \verb|my| declaration on line 19 and instead inserting an assignment \verb|$subsequence = $ARGV[0];| and run the program again:

\begin{lstlisting}
$ perl example6-4
TAAGGCGA
$ perl example6-4 AA
AAGGCGA 
\end{lstlisting}

Here, finally, is success.

\subsubsection{use warnings; and use strict; redux}
\autoref{exam:example6.4} was somewhat artificial. It turns out that these problems would have been reported easily if warnings had been used. So let's see an actual example of the benefits of \verb|use strict;| and \verb|use warnings;|, as discussed earlier in this chapter.

If you go back to the original \autoref{exam:example6.4} and add the \verb|use warnings;| directive near the top of the program, you get the following output: 

\begin{lstlisting}
$ perl example6-4 
Name "main::recievingcommitment" used only once: possible typo at example6-4 line 47.
TA 
\end{lstlisting}

As you see, the warnings found the first bug immediately. They noticed there was a variable that was used only once, usually a sign of a misspelled variable. (I can never spell "receiving" or "commitment" properly.) So fix the misspelling at line 66, and run it again: 

\begin{lstlisting}
$ perl example6-4 
TAAGGCGA
$ perl example6-4 AA
substr outside of string at example6-4 line 26.
Use of uninitialized value in regexp compilation at example6-4 line 45.
Use of uninitialized value in print at example6-4 line 46.
GACGTCTTCTAAGGCGA   
\end{lstlisting}

So, the first bug is fixed. The second bug remains with a few warnings that are, perhaps, hard to understand. But focus on the first error message, and see that it complains about line 26:

\begin{lstlisting}
my $base2 = substr($subsequence, 1, 1);
\end{lstlisting}

So, there's something wrong with \verb|$subsequence|. Often, error messages will be off by one line, so it may well be that the error starts on the line before, the first time \verb|$subsequence| is operated on by the \textit{substr}. But that's not the case here.

Nonetheless, the warnings have pointed directly to the problem. In this case, you still have to take a little initiative; look back at the \verb|$subsequence| variable and notice the extra \verb|my| declaration within the \verb|if| block on line 20 that is preventing the variable from being initialized properly. Now this is not necessarily always a bug—declaring a variable scoped within a block and that overrides another variable of the same name that is outside the block. In fact, it's perfectly legal, so the programmers who wrote the warnings did not flag it as an obvious error. However, it seems to have caused a real problem here!

One final point: if you go back to the original, buggy program, notice there's no \verb|use strict;| in the program. If you add that and run the program without arguments, you get the following: 

\begin{lstlisting}
$ perl example6-4   
Global symbol "$recievingcommitment" requires explicit package name at example6-4 line 47.
Execution of example6-4 aborted due to compilation errors.
\end{lstlisting}

Fixing the misspelled variable, and running the program with the argument, you get:

\begin{lstlisting}
$ perl example6-4 AA
GACGTCTTCTAAGGCGA
\end{lstlisting}

You can see that \verb|use strict;| didn't help for the other bug. Remember, it's best to employ both \verb|use strict;| and \verb|use warnings;|.

\section{Exercises}
\textcolor{red}{\textit{Exercise 6.1}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to concatenate two strings of DNA.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.2}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to report the percentage of each nucleotide in DNA. You've seen the plus operator \verb|+|. You will also want to use the divide operator \verb|/| and the multiply operator \verb|*|. Count the number of each nucleotide, divide by the total length of the DNA, then multiply by 100 to get the percentage. Your arguments should be the DNA and the nucleotide you want to report on. The \verb|int| function can be used to discard digits after the decimal point, if needed.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.3}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to prompt a user with any message, and collect the user's answer. The subroutine's argument should be the message, and the return value should be the (one-line) answer. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.4}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to look for command-line arguments such as \verb|-help|, \verb|-h|, and \verb|--help|. Recall that command-line arguments appear in the \verb|@ARGV| array. Call your subroutine from a main program. If you give the program any of the named command-line arguments, when you pass them into the subroutine it should return a true value. If this is the case, have the program print out a help message in a \verb|$USAGE| variable and exit. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.5}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to check if a file exists, is a regular file, and is nonzero in size. Use the \verb|file test| operators (See \autoref{chap:chapterab}). 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.6}}
\begin{adjustwidth}{1cm}{}
Use Exercise 6.3 in a subroutine that keeps prompting until a valid file is entered by the user or until five attempts have failed. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.7}}
\begin{adjustwidth}{1cm}{}
Write a module that contains subroutines that report various statistics on DNA sequences, for instance length, GC content, presence or absence of poly-T sequences (long stretches of mostly T's at the 5' (left) end of many \verb|$DNA| sequences), or other measures of interest. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.8}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to do something a biologist normally does. (Here's an opportunity to look around the lab and write a useful program!) 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.9}}
\begin{adjustwidth}{1cm}{}
Read the documentation about the debugger and become familiar with its use by applying it during your programming. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.10}}
\begin{adjustwidth}{1cm}{}
Write a subroutine that alters an array of lines in a file. Use pass by reference for the array. Pass the subroutine a reference to the array, a regular expression, and a string to replace the regular expression. All the lines of the array should be altered by substituting the matches found for the regular expression by the replacement string.
\end{adjustwidth}
