\chapter{Mutations and Randomization}
\label{chap:chapter7}
\minitoc

As every biologist knows, mutation is a fundamental topic in biology.  Mutations in DNA occur all the time in cells. Most of them don't affect the actions of proteins and are benign. Some of them do affect the proteins and may result in diseases such as cancer. Mutations can also lead to nonviable offspring that dies during development; occasionally they can lead to evolutionary change. Many cells have very complex mechanisms to repair mutations.

Mutations in DNA can arise from radiation, chemical agents, replication errors, and other causes. We're going to model mutations as random events, using Perl's random number generator.

Randomization is a computer technique that crops up regularly in everyday programs, most commonly in cryptography, such as when you want to generate a hard-to-guess password. But it's also an important branch of algorithms: many of the fastest algorithms employ randomization.

Using randomization, it's possible to simulate and investigate the mechanisms of mutations in DNA and their effect upon the biological activity of their associated proteins. Simulation is a powerful tool for studying systems and predicting what they will do; randomization allows you to better simulate the "ordered chaos" of a biological system. The ability to simulate mutations with computer programs can aid in the study of evolution, disease, and basic cellular processes such as division and DNA repair mechanisms. Computer models of cell development and function, now in their early stages, will become much more accurate and useful in coming years, and mutation is a basic biological mechanism these models will incorporate.

From the standpoint of programming technique, as well as from the standpoint of modeling evolution, mutation, and disease, randomization is a powerful—and, luckily for us, easy-to-use—programming skill.

Here's a breakdown of what we will accomplish in this chapter:

\begin{itemize}
  \item Randomly select an index into an array and a position in a string: these are the basic tools for picking random locations in DNA (or other data)
  \item Model mutation with random numbers by learning how to randomly select a nucleotide in DNA and then mutate it to some other (random) nucleotide
  \item Use random numbers to generate DNA sequence data sets, which can be used to study the extent of randomness in actual genomes
  \item Repeatedly mutate DNA to study the effect of mutations accumulating over time during evolution
\end{itemize}

\section{Random Number Generators}
A \textit{random number generator} is a subroutine you can call. For most practical purposes, you needn't worry about what's inside it. The values you get for random numbers on the computer differ somewhat from the values of real-world random events as measured, for example, by detecting nuclear decay events. Some computers actually have devices such as geiger counters attached so as to have a source of truly random events. But I'd be willing to bet your computer doesn't. What you have in place of a geiger counter, is an algorithm called a random number generator.

The numbers that are output by random number generators are not really random; they are thus called \textit{pseudo-random numbers}. A random number generator, being an algorithm, is predictable. A random number generator needs a seed, an input you can change to get a different series of (pseudo-)random numbers.

The numbers from a random number generator give an even distribution of values. This is one of the most important characteristics of randomness and largely justifies the use of these algorithms where some amount of random behavior is desired.

The other "take-home message" about random number generators is that the seed you start them up with should itself be selected randomly. If you seed with the same number every time, you'll get the same sequence of "random numbers" every time as well. (Not very random!) Try to pick a seed that has some randomness in it, such as a number calculated from some computer event that changes haphazardly over time.\footnote{Even here, for critical applications, you're not out of the woods. Unless you pick your seeds carefully, hackers will figure out how you're picking them and crack your random numbers and therefore your passwords. The method used to generate seeds in this chapter, \verb=time|$$=, is crackable by dedicated hackers. A better choice is \verb=time() ^ ($$+<<15))=. If program security is important, you should consult the Perl documentation, and the \textit{Math::Random} and \textit{Math::TrulyRandom} modules from CPAN}

In the examples that follow, I use a simple method for seed picking that's okay for most purposes. If you use random numbers for data encryption with critical privacy issues (such as patient records), you should read further into the Perl documentation about the several advanced options Perl provides for random number generation. In this book, I use a Perl method that is good enough for most purposes.

\section{A Program Using Randomization}
\autoref{exam:example7.1} introduces randomization in the context of a simple program. It randomly combines parts of sentences to construct a story. This isn't a bioinformatics program, but I've found that it's an effective way to learn the basics of randomization. You will learn how to randomly select elements from arrays, which you'll apply in the future examples that mutate DNA.

The example declares a few arrays filled with parts of sentences, then randomizes their assembly into complete sentences. It's a trivial children's game; yet it teaches several programming points.

\textbf{Example 7-1. Children's game with random numbers}
\lstinputlisting[label=exam:example7.1]{./scripts/example7-1.pl}

Here is some typical output from \autoref{exam:example7.1}:

\begin{lstlisting}
Joe and Moe jumped with Rebecca in New York City. Rebecca exploded Groucho in a dream. Mom ran to Harpo over the rainbow. TV giggled with Joe and Moe over the rainbow. Harpo exploded Joe and Moe at the beach. Robin Hood giggled with Harpo at the beach. 

Type "quit" to quit, or press Enter to continue: 

Harpo put hot sauce into the orange juice of TV before dinner. Dad ran to Groucho in a dream. Joe and Moe put hot sauce into the orange juice of TV in New York City. Joe and Moe giggled with Joe and Moe over the rainbow. TV put hot sauce into the orange juice of Mom just for the fun of it. Robin Hood ran to Robin Hood at the beach. 

Type "quit" to quit, or press Enter to continue: quit
\end{lstlisting}

The structure of the example is quite simple. After enforcing the declarations of variables, and turning on warnings, with:

\begin{lstlisting}
use strict;
use warnings;
\end{lstlisting}

the variables are declared, and the arrays are initialized with values. 

\subsection{Seeding the Random Number Generator} 
Next, the random number generator is seeded by a call to the built-in function \verb|srand|. It takes one argument, the seed for the random number generator discussed earlier. As mentioned, you have to give a different seed at this step to get a different series of random numbers. Try changing this statement to something like:

\begin{lstlisting}
srand(100);
\end{lstlisting}

and then run the program more than once. You'll get the same results each time.\footnote{The latest random number generators automatically change the series, so if this experiment doesn't work, you're probably using a very new random number generator. However, sometimes you want to repeat a series. Note that newer versions of Perl automatically give you a good seed if you call \verb|srand| like so: \verb|srand;|.} The seed you're using: 

\begin{lstlisting}
time|$$ 
\end{lstlisting}

is a calculation that returns a different seed each time.

\textit{time} returns a number representing the time, \textit{\$\$} returns a number representing the ID of the Perl program that's running (this typically changes each time you run the program), and | means bitwise OR and combines the bits of the two numbers (for details see the Perl documentation). There are other ways to pick a seed, but let's stick with this popular one.

\subsection{Control Flow}
The main loop of the program is a \verb|do-until| loop. These loops are handy when you want to do something (like print a little story) before taking any actions (like asking the user if he wants to continue) each time through the loop. The \verb|do-until| loop first executes the statements in the block and then performs a test to determine if it should repeat the statements in the block. Note that this is the reverse of the other types of loops you've seen that do the test first and then the block.

Since the \verb|$story| variable is always being appended to, it needs to be emptied at the top of each loop. It's common to forget that variables that are increased in some way need to be reset at the correct spot, so watch for that in your programming. The clue is increasingly long strings or big numbers.

The \verb|for| loop contains the main work of the program. As you've seen before, this loop initializes a counter, performs a test, and then increments the counter at the end of the block.

\subsection{Making a Sentence}
In \autoref{exam:example7.1}, note that the statement that makes a sentence stretches out over a few lines of code. It's a bit complicated, and it's the real work of the whole program, so there are comments attached to help read it. Notice that the statement has been carefully formatted so that it's neatly laid out over its eight lines. The variable names have been well chosen, so it's clear that you're making a sentence out of a noun, a verb, a noun, and a prepositional phrase.

However, even with all that, there are rather deeply nested expressions within the square brackets that specify the array positions, and it requires a bit of scrutiny to read this code. You will see that you're building a string out of sentence parts separated by spaces and ending with a period and a space. The string is built by several applications of the dot string concatenation operator. These have been placed at the beginning of each line to clarify the overall structure of the statement. 

\subsection{Randomly Selecting an Element of an Array}
Let's look closely at one of the sentence part selectors:

\begin{lstlisting}
$verbs[int(rand(scalar @verbs))] 
\end{lstlisting}

These kinds of nested braces need to be read and evaluated from the inside out. So the expression that's most deeply surrounded by braces is:

\begin{lstlisting}
scalar @verbs
\end{lstlisting}

You see from the comments before the statement that the built-in function \textit{scalar} returns the number of elements in an array. The array in question, \verb|@verbs|, has seven elements, so this expression returns 7.

So now you have:

\begin{lstlisting}
$verbs[int(rand(7))]
\end{lstlisting}

and the most deeply nested expression is now:

\begin{lstlisting}
rand(7)
\end{lstlisting}

The helpful comments in the code before the statement remind you that this statement returns a (pseudo)random number greater than 0 and less than 7. This number is a \textit{floating-point number} (decimal number with a fraction). Recall that an array with seven elements will number them from 0 to 6.

So now you have something like this:

\begin{lstlisting}
$verbs[int(3.47429)] 
\end{lstlisting}

and you want to evaluate the expression:

\begin{lstlisting}
int(3.47429) 
\end{lstlisting}

The \textit{int} function discards the fractional part of a floating-point number and returns just the integer part, in this case 3.

So you've come to the final step:

\begin{lstlisting}
$verbs[3]
\end{lstlisting}

which gives you the fourth element of the \verb|@verbs| array, as the comments have been kind enough to remind you. 

\subsection{Formatting}
To randomly select a verb, you call a few functions: 

\begin{description}
  \item[\textcolor{red}{\textit{scalar}}] Determines the size of the array 
  \item[\textcolor{red}{\textit{rand}}] Picks a random number in the range determined by the size of the array 
  \item[\textcolor{red}{\textit{int}}] Transforms the floating-point number \textit{rand} returns into the integer value you need for an array element 
\end{description}

Several of these function calls are combined in one line using nested braces. Sometimes this produces hard-to-read code, and the gentle reader may be nodding his or her head vigorously at this unflattering characterization of the author's painstaking handiwork. You could try rewriting these lines, using additional temporary variables. For instance, you can say:

\begin{lstlisting}
$verb_array_size = scalar @verbs;
$random_floating_point = rand ( $verb_array_size );
$random_integer = int $random_floating_point;
$verb = $verbs[$random_integer];
\end{lstlisting}

and repeat for the other parts of speech, finally building your sentence with a statement such as:

\begin{lstlisting}
$sentence = "$subject $verb $object $prepositional_phrase. ";
\end{lstlisting}

It's a matter of style. You will make these kinds of choices all the time as you program. The choice of layout in \autoref{exam:example7.1} was based on a tradeoff between a desire to express the overall task clearly (which won) balanced against the difficulty of reading highly nested function calls (which lost). Another reason for this layout choice is that, in the programs that follow, you'll select random elements in arrays with some regularity, so you'll get used to seeing this particular nesting of calls. In fact, perhaps you should make a little subroutine out of this kind of call if you will do the same thing many times?

Readability is the most important thing here, as it is in most code. You have to be able to read and understand code, your own as well as the code of others, and that is usually more important than trying to achieve other laudable goals such as fastest speed, smallest amount of memory used, or shortest program. It's not always important, but usually it's best to write for readability first, then go back and try to goose up the speed (or whatever) if necessary. You can even leave the more readable code in there as comments, so whoever has to read the code can still get a clear idea of the program and how you went about improving the speed (or whatever). 

\subsection{Another Way to Calculate the Random Position}
Perl often has several ways to accomplish a task. The following is an alternate way to write this random number selection; it uses the same function calls but without the parentheses:

\begin{lstlisting}
$verbs[int rand scalar @verbs]
\end{lstlisting}

This chaining of functions, each of which takes one argument, is common in Perl. To evaluate the expression, Perl first takes \verb|@verbs| as an argument to \textit{scalar}, which returns the size of the array. Then it takes that value as an argument to \verb|rand|, which returns a floating-point number from \verb|0| to less than the size of the array. It then uses that floating-point number as an argument to \textit{int}, which returns the greatest integer less than the floating-point number. In other words, it calculates the same number to be used as the subscript for the array \verb|@verbs|.

Why does Perl allow this? Because such calculations are very frequent, and, in the spirit of "Let the computer do the work," Perl designer Larry Wall decided to save you (and himself) the bother of typing and matching all those parentheses.

Having gone that far, Larry decided it'd be easy to add even more. You can eliminate the \textit{scalar} and the \textit{int} function calls and use:

\begin{lstlisting}
$verbs[rand @verbs]
\end{lstlisting}

What's going on here? Since \textit{rand} already expects a scalar value, it evaluates \verb|@verbs| in a scalar context, which simply returns the size of the array. Larry cleverly designed array subscripts (which, of course, are always integer values) to automatically take just the integer part of a floating-point value if it was given as a subscript; so, out with the \textit{int}. 

\section{A Program to Simulate DNA Mutation}
\autoref{exam:example7.1} gave you the tools you'll need to mutate DNA. In the following examples, you'll represent DNA, as usual, by a string made out of the alphabet A, C, G, and T. You'll randomly select positions in the string and then use the \textit{substr} function to alter the DNA.

This time, let's go about things a little differently and first compose some of the useful subroutines you'll need before showing the whole program. 

\subsection{Pseudocode Design}
Starting with simple pseudocode, here's a design for a subroutine that mutates a random position in DNA to a random nucleotide:

\begin{enumerate}
  \item Select a random position in the string of DNA.
  \item Choose a random nucleotide.
  \item Substitute the random nucleotide into the random position in the DNA.
\end{enumerate}

This seems short and to the point. So you decide to make each of the first two sentences into a subroutine. 
\subsubsection{Select a random position in a string}
How can you randomly select a position in a string? Recall that the built-in function \textit{length} returns the length of a string. Also recall that positions in strings are numbered from \verb|0| to \verb|length-1|, just like positions in arrays. So you can use the same general idea as in \autoref{exam:example7.1}, and make a subroutine: 

\begin{lstlisting}
# randomposition
#
# A subroutine to randomly select a position in a string.
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomposition {

  my($string) = @_;

  # This expression returns a random number between 0 and length-1,
  # which is how the positions in a string are numbered in Perl.

  return int(rand(length($string)));
}
\end{lstlisting}

\textit{randomposition} is really a short function, if you don't count the comments. It's just like the idea in \autoref{exam:example7.1} to select a random array element.

Of course, if you were really writing this code, you'd make a little test to see if your subroutine worked:

\begin{lstlisting}
#!/usr/bin/perl -w
# Test the randomposition subroutine

my $dna = 'AACCGTTAATGGGCATCGATGCTATGCGAGCT';

srand(time|$$);

for (my $i=0 ; $i < 20 ; ++$i ) {
  print randomposition($dna), " ";
}

print "\n";

exit;

sub randomposition {
  my($string) = @_;
  return int rand length $string;
}
\end{lstlisting}

Here's some representative output of the test (your results should vary):

\begin{lstlisting}
28 26 20 1 29 7 1 27 2 24 8 1 23 7 13 14 2 12 13 27 
\end{lstlisting}

Notice the new look of the \verb|for| loop:

\begin{lstlisting}
for (my $i=0 ; $i < 20 ; ++$i ) {
\end{lstlisting}

This shows how you can localize the counter variables (in this case, \verb|$i|) to the loop by declaring them with \verb|my| inside the \verb|for| loop.

\subsubsection{Choose a random nucleotide}
Next, let's write a subroutine that randomly chooses one of the four nucleotides: 

\begin{lstlisting}
# randomnucleotide
#
# A subroutine to randomly select a nucleotide
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomnucleotide {

  my(@nucs) = @_;

  # scalar returns the size of an array. 
  # The elements of the array are numbered 0 to size-1
  return $nucs[rand @nucs];
}
\end{lstlisting}

Again, this subroutine is short and sweet. (Most useful subroutines are; although writing a short subroutine is no guarantee it will be useful.  In fact, you'll see in a bit how you can improve this one.)

Let's test this one too:

\begin{lstlisting}
#!/usr/bin/perl -w
# Test the randomnucleotide subroutine

my @nucleotides = ('A', 'C', 'G', 'T');

srand(time|$$);

for (my $i=0 ; $i < 20 ; ++$i ) {
  print randomnucleotide(@nucleotides), " ";
}

print "\n";

exit;

sub randomnucleotide {
  my(@nucs) = @_;

  return $nucs[rand @nucs];
}
\end{lstlisting}

Here's some typical output (it's random, of course, so there's a high probability your output will differ):

\begin{lstlisting}
C A A A A T T T T T A C A C T A A G G G 
\end{lstlisting}

\subsubsection{Place a random nucleotide into a random position}
Now for the third and final subroutine, that actually does the mutation. Here's the code: 

\begin{lstlisting}
# mutate
#
# A subroutine to perform a mutation in a string of DNA
#

sub mutate {

  my($dna) = @_;
  my(@nucleotides) = ('A', 'C', 'G', 'T');

  # Pick a random position in the DNA
  my($position) = randomposition($dna);

  # Pick a random nucleotide
  my($newbase) = randomnucleotide(@nucleotides);

  # Insert the random nucleotide into the random position in the DNA.
  # The substr arguments mean the following:
  #  In the string $dna at position $position change 1 character to
  #  the string in $newbase
  substr($dna,$position,1,$newbase);

  return $dna;
}
\end{lstlisting}

Here, again, is a short program. As you look it over, notice that it's relatively easy to read and understand. You mutate by picking a random position then selecting a nucleotide at random and substituting that nucleotide at that position in the string. (If you've forgotten how \textit{substr} works, refer to \autoref{chap:chapterab} or other Perl documentation. If you're like me, you probably have to do that a lot, especially to get the order of the arguments right.)

There's a slightly different style used here for declaring variables. Whereas you've been declaring them at the beginning of a program, here you're declaring each variable the first time it's used. There are pros and cons for each programming style. Having all the variables at the top of the program gives good organization and can help in reading; declaring them on-the-fly can seem like a more natural way to write. The choice is yours.

Also, notice how this subroutine is mostly built from other subroutines, with a little bit added. That has a lot to do with its readability. At this point, you may be thinking that you've actually decomposed the problem pretty well, and the pieces are fairly easy to build and, in the end, they fit together well. But do they? 

\subsection{Improving the Design}
You're about to pat yourself on the back for writing the program so quickly, but you notice something. You keep having to declare that pesky \verb|@nucleotides| array and then pass it in to the \textit{randomnucleotide} subroutine. But the only place you use the array is inside the \textit{randomnucleotide} subroutine. So why not change your design a little? Here's a new try: 

\begin{lstlisting}
# randomnucleotide
#
# A subroutine to randomly select a nucleotide
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomnucleotide {
  my(@nucs) = ('A', 'C', 'G', 'T');

  # scalar returns the size of an array. 
  # The elements of the array are numbered 0 to size-1
  return $nucs[rand @nucs];
}
\end{lstlisting}

Notice that this function now has no arguments. It's called like so:

\begin{lstlisting}
$randomnucleotide = randomnucleotide( );
\end{lstlisting}

It's asking for a random element from a very specific set. Of course, you're always thinking, and you say, "It'd be handy to have a subroutine that randomly selects an element from any array. I might not need it right now, but I bet I'll need it soon!" So you define two subroutines instead of one: 

\begin{lstlisting}
# randomnucleotide
#
# A subroutine to randomly select a nucleotide
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomnucleotide {
  my(@nucleotides) = ('A', 'C', 'G', 'T');

  # scalar returns the size of an array. 
  # The elements of the array are numbered 0 to size-1
  return randomelement(@nucleotides);
}

# randomelement
#
# A subroutine to randomly select an element from an array
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomelement {

  my(@array) = @_;

  return $array[rand @array];
}
\end{lstlisting}

Look back and notice that you didn't have to change your subroutine \textit{mutate}; just the internal workings of \textit{randomnucleotide} changed, not its behavior. 

\subsection{Combining the Subroutines to Simulate Mutation}
Now you've got all your ducks in place, so you write your main program as in \autoref{exam:example7.2} and see if your new subroutine works.

\textbf{Example 7-2. Mutate DNA}
\lstinputlisting[label=exam:example7.2]{./scripts/example7-2.pl}

Here's some typical output from \autoref{exam:example7.2}:

\begin{lstlisting}
Mutate DNA

Here is the original DNA:

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Here is the mutant DNA:

AAAAAAAAAAAAAAAAAAAAGAAAAAAAAA

Here are 10 more successive mutations:

AAAAAAAAAAAAAAAAAAAAGACAAAAAAA
AAAAAAAAAAAAAAAAAAAAGACAAAAAAA
AAAAAAAAAAAAAAAAAAAAGACAAAAAAA
AAAAAAAAAAAAAACAAAAAGACAAAAAAA
AAAAAAAAAAAAAACAACAAGACAAAAAAA
AAAAAAAAAAAAAACAACAAGACAAAAAAA
AAAAAAAAAGAAAACAACAAGACAAAAAAA
AAAAAATAAGAAAACAACAAGACAAAAAAA
AAAAAATAAGAAAACAACAAGACAAAAAAA
AAAAAATTAGAAAACAACAAGACAAAAAAA
\end{lstlisting}

\autoref{exam:example7.2} was something of a programming challenge, but you end up with the satisfaction of seeing your (simulated) DNA mutate. How about writing a graphical display for this, so that every time a base gets mutated, it makes a little explosion and the color gets highlighted, so you can watch it happening in real-time?

Before you scoff, you should know how important good graphical displays are for the success of most programs. This may be a trivial-sounding graphic, but if you can demonstrate the most common mutations in, for instance, the BRCA breast cancer genes in this way, it might be useful. 

\subsection{A Bug in Your Program?}
To return to the business at hand, you may have noticed something when you looked over the output from \autoref{exam:example7.2}. Look at the first two lines of the "10 more successive mutations." They are exactly the same! Could it be that after patting yourself on the back and telling yourself what a good bit of work you'd done, you've discovered a bug?

How can you track it down? You may want to step through the running of the program with the Perl debugger, which you saw in \autoref{chap:chapter6}. However, this time, you stop and think about your design instead. You're replacing the bases at random positions with randomly chosen bases. Aha!  Sometimes the base at the position you randomly choose is exactly the same as the base you randomly choose to plug into its place! You're replacing a base with itself on occasion!\footnote{How often? In DNA that's all one base, it's happening 1/4 of the time. In DNA that's equally populated with the four bases, it's happening...1/4 of the time!} 

Let's say you decide that behavior is not useful. At each successive mutation, you need to see one base change. How can you alter your code to ensure that? Let's start with some pseudocode for the \textit{mutate} subroutine: 

\begin{lstlisting}
Select a random position in the string of DNA

Repeat:

  Choose a random nucleotide

Until: random nucleotide differs from the nucleotide in the random position

Substitute the random nucleotide into the random position in the DNA
\end{lstlisting}

This seems like something that should work, so you alter the \textit{mutate} subroutine, calling it the \textit{mutate\_better} subroutine: 

\begin{lstlisting}
# mutate_better
#
# Subroutine to perform a mutation in a string of DNA--version 2, in which
#  it is guaranteed that one base will change on each call
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub mutate_better {

  my($dna) = @_;
  my(@nucleotides) = ('A', 'C', 'G', 'T');

  # Pick a random position in the DNA
  my($position) = randomposition($dna);

  # Pick a random nucleotide
  my($newbase);

  do {
    $newbase = randomnucleotide(@nucleotides);

  # Make sure it's different than the nucleotide we're mutating
  }until ( $newbase ne substr($dna, $position,1));

  # Insert the random nucleotide into the random position in the DNA
  # The substr arguments mean the following:
  #  In the string $dna at position $position change 1 character to
  #  the string in $newbase
  substr($dna,$position,1,$newbase);

  return $dna;
}
\end{lstlisting}

When you plug this subroutine in place of \textit{mutate} and run the code, you get the following output:

\begin{lstlisting}
Mutate DNA

Here is the original DNA:

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Here is the mutant DNA:

AAAAAAAAAAAAATAAAAAAAAAAAAAAAA

Here are 10 more successive mutations:

AAAAAAAAAAAAATAAAAAAAACAAAAAAA
AAAAATAAAAAAATAAAAAAAACAAAAAAA
AAATATAAAAAAATAAAAAAAACAAAAAAA
AAATATAAAAAAATAAAAAAAACAACAAAA
AATTATAAAAAAATAAAAAAAACAACAAAA
AATTATTAAAAAATAAAAAAAACAACAAAA
AATTATTAAAAAATAAAAAAAACAACACAA
AATTATTAAAAAGTAAAAAAAACAACACAA
AATTATTAAAAAGTGAAAAAAACAACACAA
AATTATTAAAAAGTGATAAAAACAACACAA
\end{lstlisting}

which seems to indeed make a real change on every iteration.

Notice one more thing about declaring variables. In this code for \textit{mutate\_better}, if you'd declared \verb|$newbase| within the loop, since the loop is enclosed in a block, the variable \verb|$newbase| would not then be visible outside of that loop. In particular, it wouldn't be available in the \verb|substr| call that does the actual base change for the mutation. So, in \textit{mutate\_better}, you had to declare the variable outside of the loop.  

This is a frequent source of confusion for programmers who like to declare variables on the fly and a powerful argument for getting into the habit of collecting variable definitions together at the top of the program.

Even so, there are often times when you want to hide a variable within a block, because that's the only place where you will use it. Then you may want to do the declaration in the block . (Perhaps at the top of the block, if it's a long one?) 

\section{Generating Random DNA} 
It's often useful to generate random data for test purposes. Random DNA can also be used to study the organization of actual DNA from an organism. In this section, we'll write some programs to generate random DNA sequences.

Such random DNA sequences have proved useful in several ways. For instance, the popular BLAST program (see \autoref{chap:chapter12}) depends on the properties of random DNA for the analytic and empirical results that underpin the sequence similarity scores, statistics that are used to rank the "hits" that BLAST returns to the user.

Let's assume what's needed is a set of random DNA fragments of varying length. Your program will have to specify a maximum and a minimum length, as well as how many fragments to generate. 

\subsection{Bottom-up Versus Top-down}
In \autoref{exam:example7.2}, you wrote the basic subroutines, then a subroutine that called the basic subroutines, and finally the main program. If you ignore the pseudocode, this is an example of \textit{bottom-up design}; start with the building blocks, then assemble them into a larger structure.

Now let's see what it's like to start with the main program, with its subroutine calls, and write the subroutines after you find a need for them. This is called \textit{top-down design}.

\subsection{Subroutines for Generating a Set of Random DNA}
Given our goal of generating random DNA, perhaps what you want is a data-generating subroutine:

\begin{lstlisting}
@random_DNA = make_random_DNA_set( $minimum_length, $maximum_length, $size_of_set );
\end{lstlisting}

This looks okay, but of course, it begs the question of how to actually accomplish the overall task. (That's top-down design for you!) So you need to move down and write pseudocode for the \textit{make\_random\_DNA\_set} subroutine: 

\begin{lstlisting}
repeat $size_of_set times:

  $length = random number between minimum and maximum length

  $dna = make_random_DNA ( $length );

  add $dna to @set
}

return @set
\end{lstlisting}

Now, continuing the top-down design, you need some pseudocode for the \textit{make\_random\_DNA} subroutine:

\begin{lstlisting}
from 1 to $size

  $base = randomnucleotide

  $dna .= $base
}

return $dna
\end{lstlisting}

Don't go any further: you've already got a \textit{randomnucleotide} subroutine from \autoref{exam:example7.2}.

(Are you bothered by the absence of balanced curly braces in the pseudocode? Here, you're relying on indentation and lining up the right braces to indicate the blocks. Since it's pseudocode, anything is allowed as long as it works.) 

\subsection{Turning the Design into Code}
Now that we've got a top-down design, how to proceed with the coding? Let's follow the top-down design, just to see how it works.

\autoref{exam:example7.3} starts with the main program and proceeds, following the order of the top-down design you did in pseudocode, then followed by the subroutines. 

\textbf{Example 7-3. Generate random DNA}
\lstinputlisting[label=exam:example7.3]{./scripts/example7-3.pl}

Here's the output from \autoref{exam:example7.3}:

\begin{lstlisting}
Here is an array of 12 randomly generated DNA sequences
  with lengths between 15 and 30:

TACGCTTGTGTTTTCGGGGGAC
GGGGTGTGGTAAGGCTGTCTCAGATGTGC
TGAACGACAACCTCCTGGACTTTACT
ATCTATGCTTTGCCATGCTAGT
CCGCTCATTCCTCTTCCTCGGC
TGTACCCCTAATACACTTTAGCCGAATTTA
ATAGGTCGGGGCGACAGCGCCGG
GATTGACCTCTGTAA
AAAATCTCTAGGATCGAGC
GTATGTGCTTGGGTAAAT
ATGGAGTTGCGAGGAAGTAGCTGAGT
GGCCCATGACCAGCATCCAGACAGCA
\end{lstlisting}

\section{Analyzing DNA}
In this final example dealing with randomization, you'll collect some statistics on DNA in order to answer the question: on average, what percentage of bases are the same between two random DNA sequences?  Although some simple mathematics can answer the question for you, the point of the program is to show that you now have the necessary programming ability to ask and answer questions about your DNA sequences. (If you were using real DNA, say a collection of some particular gene as it appears in several organisms in slightly different forms, the answer would be somewhat more interesting. You may want to try that later.)

So let's generate a set of random DNA, all the same length, then ask the following question about the set. What's the average percentage of positions that are the same between pairs of DNA sequences in this set?

As usual, let's try to sketch an idea of the program in pseudocode: 

\begin{lstlisting}
Generate a set of random DNA sequences, all the same length

For each pair of DNA sequences

  How many positions in the two sequences are identical as a fraction?

}

Report the mean of the preceding calculations as a percentage
\end{lstlisting}

Clearly, to write this code, you can reuse at least some of the work you've already done. You certainly know how to generate a set of random DNA sequences. Also, although you don't have a subroutine that compares, position by position, the bases in two sequences, you know how to look at the positions in DNA strings. So that subroutine shouldn't be hard to write. In fact, let's write some pseudocode that compares each nucleotide in one sequence with the nucleotide in the same position in another sequence: 

\begin{lstlisting}
assuming DNA1 is the same length as DNA2,

for each position from 1 to length(DNA)

  if the character at that position is the same in DNA_1 and DNA_2

    ++$count
  }
}

return count/length
\end{lstlisting}

The whole problem now seems eminently do-able. You also have to write the code that picks each pair of sequences, collects the results, and finally takes the mean of the results and report it as a percentage.  That can all go into the main program. \autoref{exam:example7.4} gives it a try, all in one shot. 

\textbf{Example 7-4. Calculate average \% identity between pairs of random DNA sequences}
\lstinputlisting[label=exam:example7.4]{./scripts/example7-4.pl}

If the code in \autoref{exam:example7.4} seems somewhat repetitive of code from previous examples, it is. In the interest of presentation, I included the subroutine code in the program. (You'll start using modules in \autoref{chap:chapter8} as a way to avoid this repetition.) 

Here's the output of \autoref{exam:example7.4}:

\begin{lstlisting}
In this run of the experiment, the average number of 
matching positions is 0.24%
\end{lstlisting}

Well, that seems reasonable. You might say, it's obvious: a quarter of the positions match, and there are four bases. But the point isn't to verify elementary probability, it's to show you have enough programming under your belt to write some programs that ask and answer questions about DNA sequences. 

\subsection{Some Notes About the Code}
Notice in the main program that when it calls:

\begin{lstlisting}
@random_DNA = make_random_DNA_set( 10, 10, 10 );
\end{lstlisting}

you don't need to declare and initialize variables such as \verb|$minimum_length|. You can just fill in the actual numbers when you call the subroutine. (However it's often a good idea to put such things in variables declared at the top of the program, where it's easy to find and change them.) Here, you set the maximum and minimum lengths to 10 and ask for 10 sequences.

Let's restate the problem we just solved. You have to compare all pairs of DNA, and for each pair, calculate the percentage of positions that have the same nucleotides. Then, you have to take the mean of these percentages.

Here's the code that accomplishes this in the main program of \autoref{exam:example7.4}:

\begin{lstlisting}
# Iterate through all pairs of sequences
for (my $k = 0 ; $k < scalar @random_DNA - 1 ; ++$k) {
  for (my $i = ($k + 1) ; $i < scalar @random_DNA ; ++$i) {

    # Calculate and save the matching percentage
    $percent = matching_percentage($random_DNA[$k], $random_DNA[$i]);
    push(@percentages, $percent);
  }
}
\end{lstlisting}

To look at each pair, you use a nested loop. A \textit{nested loop} is simply a loop within another loop. These are fairly common in programming but must be handled with care. They may seem a little complex; take some time to see how the nested loop works, because it's common to have to select all combinations of two (or more) elements from a set.

The nested loop involves looking at $(n * (n-1)) / 2$ pairs of sequences, which is a square function of the size of the data set. This can get very big! Try gradually increasing the size of the data set and rerunning the program, and you'll see your compute time increase, and more than gradually.

See how the looping works? First sequence 0 (indexed by \verb|$K|) is paired with sequences 1,2,3,...,9, in turn (indexed by \verb|$i|). Then sequence 1 is paired with 2,3,...,9, etc. Finally, 8 is paired with 9. (Recall that array elements are numbered starting at 0, so the last element of an array with 10 elements is numbered 9. Also recall that scalar \verb|@random_DNA| returns the number of elements in the array.)

You might find it a worthwhile exercise to let the number of sequences be some small value, say 3 or 4, and think through (paper and pencil in hand) how the nested loops and the variables \verb|$k| and \verb|$i| evolve during the running of the program. Or you can use the Perl debugger to watch how it happens. 

\section{Exercises}
\textcolor{red}{\textit{Exercise 7.1}}
\begin{adjustwidth}{1cm}{}
Write a program that asks you to pick an amino acid and then keeps (randomly) guessing which amino acid you picked. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.2}}
\begin{adjustwidth}{1cm}{}
Write a program that picks one of the four nucleotides and then keeps prompting until you correctly guess the nucleotide it picked.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.3}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to randomly shuffle the elements of an array. The subroutine should take an array as an argument and return an array with the same elements but shuffled in a random order. Each element of the original array should appear exactly once in the output array, just like shuffling a deck of cards. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.4}}
\begin{adjustwidth}{1cm}{}
Write a program to mutate protein sequence, similar to the code in \autoref{exam:example7.2} that mutates DNA. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.5}}
\begin{adjustwidth}{1cm}{}
Write a subroutine that, given a codon (a fragment of DNA of length 3), returns a random mutation in the codon. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.6}}
\begin{adjustwidth}{1cm}{}
Some versions of Perl automatically seed the random number generator, making it superfluous to call \verb|srand| for that purpose before using \verb|rand| to generate random numbers. Experiment to see if your implementation of \verb|rand| calls \verb|srand| automatically, or if you have to explicitly call \verb|srand| yourself, as you have seen done in the code in this chapter. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.7}}
\begin{adjustwidth}{1cm}{}
Sometimes not all choices are will be picked in a random selection. Write a subroutine that randomly returns a nucleotide, in which the probability of each nucleotide can be specified. Pass the subroutine four numbers as arguments, representing the probabilities of each nucleotide; if each probability is 0.25, the subroutine is equally likely to pick each nucleotide. As error checking, have the subroutine ensure that the sum of the four probabilities is 1.

\textit{Hint:} one way to accomplish this is to divide the range between 0 and 1 into four intervals with lengths corresponding to the probability of the respective nucleotides. Then, simply pick a random number between 0 and 1, see in which interval it falls, and return the corresponding nucleotide.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.8}}
\begin{adjustwidth}{1cm}{}
\textit{This is a more difficult exercise.} The \textit{study} function in Perl may speed up searches for motifs in DNA or protein. Read the Perl documentation on this function. Its use is simple: given some sequence data in a variable \verb|$sequence|, type:

\begin{lstlisting}
study $sequence;
\end{lstlisting}

before doing the searches. Do you think \textit{study} will speed up searches in DNA or protein, based on what you've read about it in the documentation?
\end{adjustwidth}

\textit{For lots of extra credit!} Now read the Perl documentation on the standard module Benchmark. (Type \verb|perldoc Benchmark|, or visit the Perl home page at \href{http://www.perl.com}{http://www.perl.com}.) See if your guess is right by writing a program that benchmarks motif searches of DNA and of protein, with and without \textit{study}. 
