\chapter{Motifs and Loops}
\label{chap:chapter5}
\minitoc

This chapter continues demonstrating the basics of the Perl language begun in \autoref{chap:chapter4}. By the end of the chapter, you will know how to:

\begin{itemize}
  \item Search for motifs in DNA or protein
  \item Interact with users at the keyboard
  \item Write data to files
  \item Use loops
  \item Use basic regular expressions
  \item Take different actions depending on the outcome of conditional tests
  \item Examine sequence data in detail by operating on strings and arrays
\end{itemize}

These topics, in addition to what you learned in \autoref{chap:chapter4}, will give you the skills necessary to begin to write useful bioinformatics programs; in this chapter, you will learn to write a program that looks for motifs in sequence data. 

\section{Flow Control}
\textit{Flow control} is the order in which the statements of a program are executed. A program executes from the first statement at the top of the program to the last statement at the bottom, in order, unless told to do otherwise. There are two ways to tell a program to do otherwise: conditional statements and loops. A \textit{conditional statement} executes a group of statements only if the conditional test succeeds; otherwise, it just skips the group of statements. A \textit{loop} repeats a group of statements until an associated test fails.

\subsection{Conditional Statements}
Let's take another look at the \textit{open} statement. Recall that if you try to open a nonexistent file, you get error messages. You can test for the existence of a file explicitly, before trying to open it. In fact, such tests are among the most powerful features of computer languages. The \textit{if}, \textit{if-else}, and \textit{unless} conditional statements are three such testing mechanisms in Perl.

The main feature of these kinds of constructs is the testing for a conditional. A conditional evaluates to a \verb|true| or \verb|false| value. If the conditional is \verb|true|, the statements following are executed; if the conditional is \verb|false|, they are skipped (or vice versa).

However, "What is truth?" It's a question that programming languages may answer in slightly different ways.

This section contains a few examples that demonstrate some of Perl's conditionals. The true-false condition in each example is equality between two numbers. Notice that equality of numbers is represented by two equal signs \verb|==|, because the single equal sign \verb|=| is already used for assignment to a variable. 

\begin{adjustwidth}{2cm}{2cm}
  \parpic[l]{
  \includegraphics[width=1cm]{warning.png}
  }
  Confusion between = for assignment and == for numeric equality is a frequent programming bug, so watch for it! 
\end{adjustwidth}

The following examples demonstrate whether the conditional will evaluate to \verb|true| or \verb|false|. You don't ordinarily have much use for such simple tests. Usually you test the values that have been read into variables or the return value of function calls—things you don't necessarily know beforehand.

The \verb|if| statement with a \verb|true| conditional: 

\begin{lstlisting}
if( 1 == 1 ) {
  print "1 equals 1\n\n";
}
\end{lstlisting}

produces the output:

\begin{lstlisting}
1 equals 1
\end{lstlisting}

The test is \verb|1 == 1|, or, in English, "Does 1 equal 1?" Since it does, the conditional evaluates to \verb|true|, the statement associated with the \verb|if| statement is executed, and a message is printed out.

You can also just say:

\begin{lstlisting}
if( 1 ) {
  print "1 evaluates to true\n\n";
}
\end{lstlisting}

which produces the output:

\begin{lstlisting}
1 evaluates to true
\end{lstlisting}

The \verb|if| statement with a \verb|false| conditional: 

\begin{lstlisting}
if( 1 == 0 ) {
  print "1 equals 0\n\n";
}
\end{lstlisting}

produces no output! The test is \verb|1 == 0| or, in English, "Does 1 equal 0?" Since it doesn't, the conditional evaluates to \verb|false|, the statements associated with the \verb|if| statement aren't executed, and no message is printed out.

You can also just say:

\begin{lstlisting}
if( 0  ) {
  print "0 evaluates to true\n\n";
}
\end{lstlisting}

which produces no output, since 0 evaluates to \verb|false|, so the statements associated with the \verb|if| statement are skipped entirely. 

There's another way to write short \verb|if| statements that mirrors how the English language works. In English, you can say, equivalently, "If you build it, they will come" or "They will come if you build it." Not to be outdone, Perl also allows you to put the \verb|if| after the action:

\begin{lstlisting}
print "1 equals 1\n\n" if (1 == 1);
\end{lstlisting}

which does the same thing as the first example in this section and prints out:

\begin{lstlisting}
1 equals 1
\end{lstlisting}

Now, let's look at an \verb|if-else| statement with a \verb|true| conditional:

\begin{lstlisting}
if( 1 == 1 ) {
  print "1 equals 1\n\n";
} else {
  print "1 does not equal 1\n\n";
}
\end{lstlisting}

which produces the output:

\begin{lstlisting}
1 equals 1
\end{lstlisting}

The \verb|if-else| does one thing if the test evaluates to \verb|true| and another if the test evaluates to \verb|false|. Here is \verb|if-else| with a \verb|false| conditional: 

\begin{lstlisting}
if( 1 == 0 ) {
  print "1 equals 0\n\n";
} else {
  print "1 does not equal 0\n\n";
}
\end{lstlisting}

which produces the output:

\begin{lstlisting}
1 does not equal 0
\end{lstlisting}

The final example is \verb|unless|—the opposite of \verb|if|. It works like the English word "unless": e.g., "Unless you study Russian literature, you are ignorant of Chekov." If the conditional evaluates to \verb|true|, no action is taken; if it evaluates to \verb|false|, the associated statements are executed. If "you study Russian literature" is \verb|false|, "you are ignorant of Chekov." 

\begin{lstlisting}
unless( 1 == 0 ) {
  print "1 does not equal 0\n\n"\nonumber\\
}
\end{lstlisting}

produces the output:

\begin{lstlisting}
1 does not equal 0
\end{lstlisting}

\subsubsection{Conditional tests and matching braces}
Two more comments are in order about these statements and their conditional tests.

First, there are several tests that can be used in the conditional part of these statements. In addition to numeric \textit{equality} \verb|==| as in the previous example, you can also test for inequality \verb|!=|, greater than \verb|>|, less than \verb|<|, and more.

Similarly, you can test for string equality using the \textit{eq} operator: if two strings are the same, it's \verb|true|. There are also file test operators that allow you to test if a file exists, is empty, if permissions are set a certain way, and so on (see \autoref{chap:chapterab}). One common test is just a variable name: if the variable contains zero, it's considered \verb|false|; any other number evaluates to \verb|true|. If the variable contains a nonempty string, it evaluates to \verb|true|; the empty string, designated by "" or '', is \verb|false|.

Second, notice that the statements that follow the conditional are enclosed within a matching pair of curly braces. These statements within curly braces are called a block and arise frequently in Perl.\footnote{As something of an oddity, the last statement within a block doesn't need a semicolon after it.} Matching pairs of parentheses, brackets, or braces, i.e., \verb|()|, \verb|[]|, \verb|<>|, and \verb|{}|, are common programming features. Having the same number of left and right braces in the right places is essential for a Perl program to run correctly.

Matching braces are easy to lose track of, so don't be surprised if you miss some and get error messages when you try to run the program. This is a common syntax error; you have to go back and find the missing brace. As code gets more complex, it can be a challenge to figure out where the matching braces are wrong and how to fix them. Even if the braces are in the right place, it can be hard to figure out what statements are grouped together when you're reading code. You can avoid this problem by writing code that doesn't try to do too much on any one line and uses indentation to further highlight the blocks of code (see \autoref{sect:section5.2}).\footnote{Some text editors help you find a matching brace (for instance, in the vi editor, hitting the percent key \% over a parenthesis bounces you to the matching parenthesis).} 

Back to the conditional statements. The \textit{if-else} also has an \textit{if-elsif-else} form, as in \autoref{exam:example5.1}. The conditionals, first the \textit{if} and then the \textit{elsifs}, are evaluated in turn, and as soon as one evaluates to \verb|true|, its block is executed, and the rest of the conditionals are ignored. If none of the conditionals evaluates to \verb|true|, the \textit{else} block is executed if there is one—it's optional. 

\textbf{Example 5-1. if-elsif-else}
\lstinputlisting[label=exam:example5.1]{./scripts/example5-1.pl}

Notice the \verb|\"| in the \textit{else} block's \verb|print| statement; it lets you print a double-quote sign (") within a double-quoted string. The backslash character tells Perl to treat the following " as the sign itself and not interpret it as the marker for the end of the string. Also note the use of \textit{eq} to check for equality between strings.

\autoref{exam:example5.1} gives the output:

\begin{lstlisting}
MNIDDKL--the magic word!
\end{lstlisting}

\subsection{Loops}
A \textit{loop} allows you to repeatedly execute a block of statements enclosed within matching curly braces. There are several ways to loop in Perl: \textit{while} loops, \textit{for} loops, \textit{foreach} loops, and more. \autoref{exam:example5.2} (from \autoref{chap:chapter4}) displays the \textit{while} loop and how it's used while reading protein sequence data in from a file. 

\textbf{Example 5-2. Reading protein sequence data from a file, take 4}
\lstinputlisting[label=exam:example5.2]{./scripts/example5-2.pl}

Here's the output of \autoref{exam:example5.2}:

\begin{lstlisting}
  ######  Here is the next line of the file:
MNIDDKLEGLFLKCGGIDEMQSSRTMVVMGGVSGQSTVSGELQD
  ######  Here is the next line of the file:
SVLQDRSMPHQEILAADEVLQESEMRQQDMISHDELMVHEETVKNDEEQMETHERLPQ
  ######  Here is the next line of the file:
GLQYALNVPISVKQEITFTDVSEQLMRDKKQIR
\end{lstlisting}

In the \textit{while} loop, notice how the variable \verb|$protein| is assigned each time through the loop to the next line of the file. In Perl, an assignment returns the value of the assignment. Here, the test is whether the assignment succeeds in reading another line. If there is another line to read in, the assignment occurs, the conditional is \verb|true|, the new line is stored in the variable \verb|$protein|, and the block with the two \verb|print| statements is executed. If there are no more lines, the assignment is undefined, the conditional is \verb|false|, and the program skips the block with the two \verb|print| statements, quits the \textit{while} loop, and continues to the following parts of the program (in this case, the \textit{close} and \textit{exit} functions). 

\subsubsection{open and unless}
The \textit{open} call is a system call, because to open a file, Perl must ask for the file from the operating system. The operating system may be a version of Unix or Linux, a version of Microsoft Windows, one of the Apple Macintosh operating systems, and so on. Files are managed by the operating system and can be accessed only by it.

It's a good habit to check for the success or failure of system calls, especially when opening files. If a system call fails, and you're not checking for it, your program will continue, perhaps attempting to read or write to a file you couldn't open in the first place. You should always check for failure and let the user of the program know right away when a file can't be opened. Often you may want to exit the program on failure or try to open a different file.  

In \autoref{exam:example5.2}, the \textit{open} system call is part of the test of the \textit{unless} conditional.

\textit{unless} is the opposite of \textit{if}. Just as in English you can say "do the statements in the block if the condition is true"; you can also say the opposite, "do the statements in the block unless the condition is true." The \textit{open} system call gives you a true value if it successfully opens the file; so here, in the conditional test of the \textit{unless} statement, if the \textit{open} call fails, the statements in the block are performed, the program prints an error message, and then exits.

To sum up, conditionals and loops are simple ideas and not difficult to learn in Perl. They are among the most powerful features of programming languages. Conditionals allow you to tailor a program to several alternatives, and in that way, make decisions based on the type of input it gets. They are responsible for a large part of whatever artificial intelligence there is in a computer program. Loops harness the speed of the computer so that in a few lines of code, you can handle large amounts of input or continually iterate and refine a computation. 

\section{Code Layout}
\label{sect:section5.2}
Once you start using loops and conditional statements, you need to think seriously about formatting. You have many options when formatting Perl code on the page. Compare these variant ways of formatting an \textit{if} statement inside a \verb|while| loop:

\textcolor{red}{\textit{Format A}}
\begin{adjustwidth}{1cm}{}
\begin{lstlisting}
while ( $alive ) {
  if ( $needs_nutrients ) {
    print "Cell needs nutrients\n";
  }
}
\end{lstlisting}
\end{adjustwidth}

\textcolor{red}{\textit{Format B}}
\begin{adjustwidth}{1cm}{}
\begin{lstlisting}
while ( $alive )
{
  if ( $needs_nutrients )
  {
    print "Cell needs nutrients\n";
  }
}
\end{lstlisting}
\end{adjustwidth}

\textcolor{red}{\textit{Format C}}
\begin{adjustwidth}{1cm}{}
\begin{lstlisting}
  while ( $alive )
    {
      if ( $needs_nutrients )
{
  print "Cell needs nutrients\n";
}
}
\end{lstlisting}
\end{adjustwidth}

\textcolor{red}{\textit{Format D}}
\begin{adjustwidth}{1cm}{}
\begin{lstlisting}
while($alive){if($needs_nutrients){print "Cell needs nutrients\n";}}
\end{lstlisting}
\end{adjustwidth}

These code fragments are equivalent as far as the Perl interpreter is concerned. That's because Perl doesn't rely on how the statements are laid out on the lines; Perl cares only about the correct order of the syntactical elements. Some elements need some whitespace (such as spaces, tabs, or newlines) between them to make them distinct, but in general, Perl doesn't restrict how you use whitespace to lay out your code.

Formats A and B are common ways to lay out code. They both make the program structure clear to the human reading it. Notice how the statements that have a block associated with them—the \textit{while} and \textit{if} statements—line up the curly braces and indent the statements within the blocks. These layouts make clear the extent of the block associated with the statements. (This can be critical for long, complicated blocks.) The statements inside the blocks are indented, for which you normally use the Tab key or groups of four or eight spaces. (Many text editors allow you to insert spaces when you hit the Tab key, or you can instruct them to set the tab stops at four, eight, or whatever number of spaces.) The overall structure of the program becomes clearer this way; you can easily see which statements are grouped in a block and associated with a given loop or conditional. Personally, I prefer the layout in Format A, although I'm also perfectly happy with Format B.

Format C is an example of badly formatted code. The flow control of the code isn't clear; for instance, it's hard to see if the \textit{print} statement is in the block of the \textit{while} statement.  

Format D demonstrates how hard it is to read code with essentially no formatting, even a simple fragment like this.

The Perl style guide, available from the main Perl manual page or from the command line by typing:

\begin{lstlisting}
perldoc perlstyle
\end{lstlisting}

has some recommendations and some suggestions for ways to write readable code. However, they are not rules, and you may use your own judgment as to the formatting practices that work best for you. 

\section{Finding Motifs}
One of the most common things we do in bioinformatics is to look for motifs, short segments of DNA or protein that are of particular interest. They may be regulatory elements of DNA or short stretches of protein that are known to be conserved across many species. (The PROSITE web site at \href{http://www.expasy.ch/prosite/}{http://www.expasy.ch/prosite/} has extensive information about protein motifs.)

The motifs you look for in biological sequences are usually not one specific sequence. They may have several variants—for example, positions in which it doesn't matter which base or residue is present. They may have variant lengths as well. They can often be represented as regular expressions, which you'll see more of in the discussion following \autoref{exam:example5.3}, in \autoref{chap:chapter9}, and elsewhere in the book.  

Perl has a handy set of features for finding things in strings. This, as much as anything, has made it a popular language for bioinformatics.  \autoref{exam:example5.3} introduces this string-searching capability; it does something genuinely useful, and similar programs are used all the time in biology research. It does the following:

\begin{itemize}
  \item Reads in protein sequence data from a file
  \item Puts all the sequence data into one string for easy searching
  \item Looks for motifs the user types in at the keyboard
\end{itemize}

\textbf{Example 5-3. Searching for motifs}
\lstinputlisting[label=exam:example5.3]{./scripts/example5-3.pl}

Here's some typical output from \autoref{exam:example5.3}:

\begin{lstlisting}
Please type the filename of the protein sequence data:
NM_021964fragment.pep
Enter a motif to search for: SVLQ
I found it!

Enter a motif to search for: jkl
I couldn't find it.

Enter a motif to search for: QDSV
I found it!

Enter a motif to search for: HERLPQGLQ
I found it!

Enter a motif to search for: 
I couldn't find it. 
\end{lstlisting}

As you see from the output, this program finds motifs that the user types in at the keyboard. With such a program, you no longer have to search manually through potentially huge amounts of data. The computer does the work and does it much faster and more accurately than a human.

It'd be nice if this program not only reported it found the motif but at what position. You'll see how this can be accomplished in \autoref{chap:chapter9}. An exercise in that chapter challenges you to modify this program so that it reports the positions of the motifs.

The following sections examine and discuss the parts of \autoref{exam:example5.3} that are new:

\begin{itemize}
  \item Getting user input from the keyboard
  \item Joining lines of a file into a single scalar variable
  \item Regular expressions and character classes
  \item \verb|do-until| loops
  \item Pattern matching
\end{itemize}

\subsection{Getting User Input from the Keyboard}
You first saw filehandles in \autoref{exam:example4.5}. In \autoref{exam:example5.3} (as was true in \autoref{exam:example4.3}), a filehandle and the angle bracket input operator are used to read in data from an opened file into an array, like so:

\begin{lstlisting}
@protein = <PROTEINFILE>;
\end{lstlisting}

Perl uses the same syntax to get input that is typed by the user at the keyboard. In \autoref{exam:example5.3}, a special filehandle called STDIN (short for standard input), is used for this purpose, as in this line that collects a filename from the user:

\begin{lstlisting}
$proteinfilename = <STDIN>;
\end{lstlisting}

So, a filehandle can be associated with a file; it can also be associated with the keyboard where the user types responses to questions the program asks.

If the variable you're using to save the input is a scalar variable starts with a dollar sign (\verb|$|), as in this fragment, only one line is read, which is almost always what you want in this case.

In \autoref{exam:example5.3}, the user is requested to enter the filename of a file containing protein sequence data. After getting a filename in this fashion, there's one more step before you can open the file. When the user types in a filename and sends a newline by hitting the Enter key (also known as the Return key), the filename also gets a newline character at the end as it is stored in the variable. This newline is not part of the filename and has to be removed before the \textit{open} system call will work. The Perl function \textit{chomp} removes newlines (or its cousins linefeeds and carriage returns) from the end of a string. (The older function \textit{chop} removes the last character, no matter what it is; this caused trouble, so \textit{chomp} was introduced and is almost always preferred.)

So this part of Perl requires a little bit extra: removing the newline from the input collected from the user at the keyboard. Try commenting out the \verb|chomp| function, and you'll see that the \verb|open| fails, because no filename has a newline at the end. (Operating systems have rules as to which characters are allowed in filenames.) 

\subsection{Turning Arrays into Scalars with join}
\label{sect:section5.3.2}
It's common to find protein sequence data broken into short segments of 80 or so characters each. The reason is simple: when data is printed out on paper or displayed on the screen, it needs to be broken up into lines that fit into the space. Having your data broken into segments, however, is inconvenient for your Perl program. What if you're searching for a motif that's split by a newline character? Your program won't find it. In fact, some of the motifs searched for in \autoref{exam:example5.3} are split by line breaks. In Perl you deal with this sort of segmented data with the Perl function \textit{join}. In \autoref{exam:example5.3} \textit{join} collapses an array \verb|@protein| by combining all the lines of data into a single string stored in a new scalar variable \verb|$protein|:

\begin{lstlisting}
$protein = join( '', @protein );
\end{lstlisting}

You specify a string to be placed between the elements of the array as they're joined. In this case, you specify the empty string to be placed between the lines of the input file. The empty string is represented with the pair of single quotes '' (double quotes "" also serve).  

Recall that in \autoref{exam:example4.2}, I introduced several equivalent ways to concatenate two fragments of DNA. The use of the \textit{join} function is very similar. It takes the scalar values that are the elements of the array and concatenates them into a single scalar value. Recall the following statement from \autoref{exam:example4.2}, which is one of the equivalent ways to concatenate two strings: 

\begin{lstlisting}
$DNA3 = $DNA1 . $DNA2;
\end{lstlisting}

Another way to accomplish the same concatenation uses the \textit{join} function:

\begin{lstlisting}
$DNA3 = join( "", ($DNA1, $DNA2) );
\end{lstlisting}

In this version, instead of giving an array name, I specify a list of scalar elements:

\begin{lstlisting}
($DNA1, $DNA2)
\end{lstlisting}

\subsection{do-until Loops}
There's a new kind of loop in \autoref{exam:example5.3}, the \verb|do-until| loop, which first executes a block and then does a conditional test. Sometimes this is more convenient than the usual order in which you test first, then do the block if the test succeeds. Here, you want to prompt the user, get the user's input, search for the motif, and report the results. Before doing it again, you check the conditional test to see if the user has input an empty line. This means that the user has no more motifs to look for, so you exit the loop. 

\subsection{Regular Expressions}
\textit{Regular expressions} let you easily manipulate strings of all sorts, such as DNA and protein sequence data. What's great about regular expressions is that if there's something you want to do with a string, you usually can do it with Perl regular expressions.

Some regular expressions are very simple. For instance, you can just use the exact text of what you're searching for as a regular expression: if I was looking for the word "bioinformatics" in the text of this book, I could use the regular expression:

\begin{lstlisting}
/bioinformatics/
\end{lstlisting}

Some regular expressions can be more complex, however. In this section, I'll explain their use in \autoref{exam:example5.3}. 

\subsubsection{Regular expressions and character classes}
Regular expressions are ways of matching one or more strings using special wildcard-like operators. Regular expressions can be as simple as a word, which matches the word itself, or they can be complex and made to match a large set of different words (or even every word!).

After you join the protein sequence data into the scalar variable \verb|$protein| in \autoref{exam:example5.3}, you also need to remove newlines and anything else that's not sequence data. This can include numbers on the lines, comments, informational or "header" lines, and so on. In this case, you want to remove newlines and any spaces or tabs that might be invisibly present. The following line of code in \autoref{exam:example5.3} removes this whitespace:

\begin{lstlisting}
$protein =~ s/\s//g;
\end{lstlisting}

The sequence data in the scalar variable \verb|$protein| is altered by this statement. You first saw the binding operator =~ and the substitute function \textit{s///} back in \autoref{exam:example4.3}, where they were used to change one character into another. Here, they're used a little differently. You substitute any one of a set of whitespace characters, represented by \verb|\s| with nothing and by the lack of anything between the second and third forward slashes. In other words, you delete any of a set of whitespace characters, which is done globally throughout the string by virtue of the \verb|g| at the end of the statement.

The \verb|\s| is one of several metasymbols. You've already seen the metasymbol \verb|\n|. The \verb|\s| metasymbol matches any space, tab, newline, carriage return, or formfeed. \verb|\s| can also be written as: 

\begin{lstlisting}
[ \t\n\f\r]
\end{lstlisting}

This expression is an example of a character class and is enclosed in square brackets. A character class matches one character, any one of the characters named within the square brackets. A space is just typed as a space; other whitespace characters have their own metasymbols: \verb|\t| for tab, \verb|\n| for newline, \verb|\f| for formfeed, and \verb|\r| for carriage return. A carriage return causes the next character to be written at the beginning of the line, and a formfeed advances to the next line. The two of them together amount to the same thing as a newline character.

Each \textit{s///} command I've detailed has some kind of regular expression between the first two forward slashes \verb|/|. You've seen single letters as the \verb|C| in \textit{s/C/G/g} in that position. The \verb|C| is an example of a valid regular expression.

There's another use of regular expressions in \autoref{exam:example5.3}. The line of code: 

\begin{lstlisting}
if ( $motif =~ /^\s*$/ ) {
\end{lstlisting}

is, in English, testing for a blank line in the variable \verb|$motif|. If the user input is nothing except for perhaps some whitespace, represented as \verb|\s*|, the match succeeds, and the program exits. The whole regular expression is: 

\begin{lstlisting}
/^\s*$/
\end{lstlisting}

which translates as: match a string that, from the beginning (indicated by the \verb|^|), is zero or more (indicated by the \verb|*|) whitespace characters (indicated by the \verb|\s|) until the end of the string (indicated by the \verb|$|).

If this seems somewhat cryptic, just hang in there and you'll soon get familiar with the terminology. Regular expressions are a great way to manipulate sequence and other text-based data, and Perl is particularly good at making regular expressions relatively easy to use, powerful, and flexible. Many of the references in \autoref{chap:chapteraa} contain material on regular expressions, and there's a concise summary in \autoref{chap:chapterab}.

\cprotect \subsubsection{Pattern matching with \verb|=~| and regular expressions}
The actual search for the motif happens in this line from \autoref{exam:example5.3}: 

\begin{lstlisting}
if ( $protein =~ /$motif/ ) {
\end{lstlisting}

Here, the binding operator \verb|=~| searches for the regular expression stored as the value of the variable \verb|$motif| in the protein \verb|$protein|. Using this feature, you can interpolate the value of a variable into a string match. (Interpolation in Perl strings means inserting the value of a variable into a string, as you first saw in \autoref{exam:example4.2} when you were concatenating strings). The actual motif, that is, the value of the string variable \verb|$motif|, is your regular expression. The simplest regular expressions are just strings of characters, such as the motif \verb|AQQK|, for example.

You can use \autoref{exam:example5.3} to play with some more features of regular expressions. You can type in any regular expression to search for in the protein. Try starting up the program, referring to the documentation on regular expressions, and play! Here are some examples of typing in regular expressions: 

\begin{itemize}
  \item Search for an A followed by a D or S, followed by a V: 
\begin{lstlisting}
Enter a motif to search for: A[DS]V
I couldn't find it.
\end{lstlisting}
  \item Search for K, N, zero or more D's, and two or more E's (note that {2,} means "two or more"): 
\begin{lstlisting}
Enter a motif to search for: KND*E{2,}
I found it!
\end{lstlisting}
  \item Search for two E's, followed by anything, followed by another two E's: 
\begin{lstlisting}
Enter a motif to search for: EE.*EE
I found it!
\end{lstlisting}
\end{itemize}

In that last search, notice that a period stands for any character except a newline, and ".*" stands for zero or more such characters. (If you want to actually match a period, you have to escape it with a backslash.) 

\section{Counting Nucleotides}
There are many things you might want to know about a piece of DNA. Is it coding or noncoding?\footnote{Coding DNA is DNA that codes for a protein, that is, it is part of a gene. In many organisms, including humans, a large part of the DNA is noncoding—not part of genes and doesn't code for proteins. In humans, about 98-99\% of DNA is noncoding.} Does it contain a regulatory element? Is it related to some other known DNA, and if so, how? How many of each of the four nucleotides does the DNA contain? In fact, in some species the coding regions have a specific nucleotide bias, so this last question can be important in finding the genes. Also, different species have different patterns of nucleotide usage. So counting nucleotides can be interesting and useful.

In the following sections are two programs, \autoref{exam:example5.4} and \autoref{exam:example5.6}, that make a count of each type of nucleotide in some DNA. They introduce a few new parts of Perl:

\begin{itemize}
  \item "Exploding" a string
  \item Looking at specific locations in strings
  \item Iterating over an array
  \item Iterating over the length of a string
\end{itemize}

To get the count of each type of nucleotide in some DNA, you have to look at each base, see what it is, and then keep four counts, one for each nucleotide. We'll do this in two ways:

\begin{itemize}
  \item Explode the DNA into an array of single bases, and iterate over the array (that is, deal with the elements of the array one by one)
  \item Use the \textit{substr} Perl function to iterate over the positions in the string of DNA while counting
\end{itemize}

First, let's start with some pseudocode of the task. Afterwards, we'll make more detailed pseudocode, and finally write the Perl program for both approaches.

The following pseudocode describes generally what is needed:

\begin{lstlisting}
for each base in the DNA
  if base is A
    count_of_A = count_of_A + 1
  if base is C
    count_of_C = count_of_C + 1
  if base is G
    count_of_G = count_of_G + 1
  if base is T
    count_of_T = count_of_T + 1
done

print count_of_A, count_of_C, count_of_G, count_of_T
\end{lstlisting}

As you can see, this is a pretty simple idea, mirroring what you'd do by hand if you had to. (If you want to count the relative frequencies of the bases in all human genes, you can't do it by hand—there are too many of them—and you have to use such a program. Thus bioinformatics.) Now let's see how it can be coded in Perl. 

\section{Exploding Strings into Arrays}
Let's say you decide to explode the string of DNA into an array. By explode I mean separating out each letter in the string—sort of like blowing the string into bits. In other words, the letters representing the bases of the DNA in the string are separated, and each letter becomes its own scalar value in an array. Then you can look at the array elements (each of which is a single character) one by one, making the count as you go along. This is the inverse of the \verb|join| function in \autoref{sect:section5.3.2}, which takes an array of strings and makes a single scalar value out of them. (After exploding a string into an array, you could then join the array back into an identical string using \verb|join|, if you so desire.)

I'm also adding to this version of the pseudocode the instructions to get the DNA from a file and manipulate that file data until it's a single string of DNA sequence. So first, you join the data from the array of lines of the original file data, clean it up by removing whitespace until only sequence is left, and then explode it back into an array. But, of course, the point is that the last array has exactly what is needed, the data in a convenient form to use in the counting loop. Instead of an array of lines, with newlines and possibly other unwanted characters, there's an exact array of the individual bases. 

\begin{lstlisting}
read in the DNA from a file

join the lines of the file into a single string $DNA

# make an array out of the bases of $DNA
@DNA = explode $DNA

# initialize the counts
count_of_A = 0
count_of_C = 0
count_of_G = 0
count_of_T = 0

for each base in @DNA

  if base is A
    count_of_A = count_of_A + 1
  if base is C
    count_of_C = count_of_C + 1
  if base is G
    count_of_G = count_of_G + 1
  if base is T
    count_of_T = count_of_T + 1
done

print count_of_A, count_of_C, count_of_G, count_of_T
\end{lstlisting}

As promised, this version of the pseudocode is a bit more detailed. It suggests a method to look at each of the bases by exploding the string of DNA into an array of single characters. It also initializes the counts to zero to ensure they start off right. It's easier to see what's happening if you spell out the initialization in the program, and it can prevent certain kinds of errors from creeping into your code. (It's not a rule, however; sometimes, you may prefer to leave the values of variables undefined until they are used.) Perl assumes that an uninitialized variable has the value 0 if you try to use it as a number, for instance by adding another number to it. But you'll most likely get a warning if that is the case.

We now have a design for the program, let's turn it into Perl code. \autoref{exam:example5.4} is a workable program; you'll see other ways to accomplish the same task more quickly as you proceed in this chapter, but speed is not the main concern at this point. 

\textbf{Example 5-4. Determining frequency of nucleotides}
\lstinputlisting[label=exam:example5.4]{./scripts/example5-4.pl}

To demonstrate \autoref{exam:example5.4}, I have created the following small file of DNA and called it \textit{small.dna}: 

\begin{lstlisting}
AAAAAAAAAAAAAAGGGGGGGTTTTCCCCCCCC
CCCCCGTCGTAGTAAAGTATGCAGTAGCVG
CCCCCCCCCCGGGGGGGGAAAAAAAAAAAAAAATTTTTTAT
AAACG
\end{lstlisting}

The file \textit{small.dna} can be typed into your computer using your favorite text editor, or you can download it from this book's web site.

Notice that there is a V in the file, an error.\footnote{Files of DNA sequence data sometimes include such characters as N, meaning "some undetermined base," or other special characters. You sometimes have to look at the documentation for the source, say an ABI sequencer or a GenBank file or whatever, to discover which characters are used and what they mean.} Here is the output of \autoref{exam:example5.4}:

\begin{lstlisting}
Please type the filename of the DNA sequence data: small.dna
!!!!!!!! Error - I don't recognize this base: V

A = 40
C = 27
G = 24
T = 17
\end{lstlisting}

Now let's look at the new stuff in this program. Opening and reading the sequence data is the same as previous programs. The first new thing is at this line:

\begin{lstlisting}
@DNA = split( '', $DNA );
\end{lstlisting}

which the comments say will explode the string \verb|$DNA| into an array of single characters \verb|@DNA|.

\textit{split} is the companion to \textit{join}, and it's a good idea to take a little while to look over the documentation for these two commands. Calling \textit{split} with an empty string as the first argument causes the string to explode into individual characters; that's just what we want.\footnote{As you'll see in the documentation for the \texit{split} function, the first argument can be any regular expression, such as \verb|/\s+/| (one or more adjacent whitespace characters.)}

Next, there are five scalar variables initialized to 0, the variables \verb|$count_of_A| and so forth. \textit{Initializing} means assigning an initial value, in this case, the value 0. 

\autoref{exam:example5.4} illustrates the concepts of \textit{type} and \texit{initialization}. The type of a variable determines what kind of data it can hold, for instance, strings or numbers. Up to now we've been using scalar variables such as \verb|$DNA| to store strings of letters such as A, C, G, and T. \autoref{exam:example5.4} shows that you can also use scalar variables to store numbers. For example, the variable \verb|$count_of_A| keeps a running count of the character A.

Scalar variables can store integers (0, 1, -1, 2, -2, \ldots), decimal or floating-point numbers such as 6.544, and numbers in scientific notation such as 6.544E6, which translates as $6.544 \times 10^6$, or 6,544,000. (See \autoref{chap:chapterab} for more details on types of numbers.)

In \autoref{exam:example5.4}, the variables \verb|$count_of_A| through \verb|$count_of_T| are initialized to 0. \textit{Initializing} a variable means giving it a value after it's declared. If you don't initialize your variables, they assume the value of \verb|'undef'|. In Perl, an undefined variable is 0 if it is asked for in numerical context; it's an empty string if used in a string operation. Although Perl programmers often choose not to initialize variables, it's a critical step in many other languages. In C for instance, uninitialized variables have unpredictable values. This can wreak havoc with your output. You should get in the habit of initializing variables; it makes the program easier to read and maintain, and that's important.

To \textit{declare} a variable means to specify its name and other attributes such as an initial value and a scope (for scoping, see \autoref{chap:chapter6} and the discussion of \verb|my| variables). Many languages require you to declare all variables before using them. For this book, up to now, declarations have been an unnecessary complication. The next chapter begins to require declarations. In Perl, you may declare a variable's scope (see \autoref{chap:chapter6} and the discussion of \verb|my| variables) in addition to an initial value.  Many languages also require you to declare the type of a variable, for example "integer," or "string," but Perl does not.

Perl is written to be smart about what's in a scalar variable. For instance, you can assign the number \verb|1234| (without quotes) to a variable, or you can assign the string \verb|'1234'| (with quotes). Perl treats the variable as a string for printing, and as a number for using in arithmetic operations, without your having to worry about it. \autoref{exam:example5.5} demonstrates this ability. In other words, Perl isn't strict about specifying the type of data a variable is used for. 

\textbf{Example 5-5. Demonstration of Perl's built-in knowledge about numbers and strings}
\lstinputlisting[label=exam:example5.5]{./scripts/example5-5.pl}

\autoref{exam:example5.5} produces the output:

\begin{lstlisting}
1234 1234
2468
12341234
\end{lstlisting}

\autoref{exam:example5.5} illustrates the smart way Perl determines the datatype of a scalar variable, whether it's a string or a number, and whether you're trying to add or subtract it like a number or concatenate it like a string. Perl behaves accordingly, which makes your job as a programmer a little bit easier; Perl "does the right thing" for you.

Next is a new kind of loop, the \verb|foreach| loop. This loop works over the elements of an array. The line: 

\begin{lstlisting}
foreach $base (@DNA) {
\end{lstlisting}

loops over the elements of the array \verb|@DNA|, and each time through the loop, the scalar variable \verb|$base| (or whatever name you choose) is set to the next element of the array.

The body of the loop checks for each base and increments the count for that base if found. There are four ways to add \verb|1| to a number in Perl.  Here, you put a \verb|++| in front of the variable, like this:

\begin{lstlisting}
++$count; 
\end{lstlisting}

You can also put the \verb|++| after the variable:

\begin{lstlisting}
$count++;
\end{lstlisting}

You can spell it out like this, a combination of adding and assignment:

\begin{lstlisting}
$count = $count + 1;
\end{lstlisting}

or, as a shorthand of that, you can say:

\begin{lstlisting}
$count += 1;
\end{lstlisting}

Almost an embarrassment of riches. The plus-plus (\verb|++|) notation is convenient for incrementing counts, as we're doing here. The plus-equals (\verb|+=|) notation saves some typing and is very popular for adding other numbers besides 1.

The \verb|foreach| loop in \autoref{exam:example5.5} could have been written like this:

\begin{lstlisting}
foreach (@DNA) {
  
  if ( /A/ ) {
    ++$count_of_A;
  } elsif ( /C/  ) {
    ++$count_of_C;
  } elsif ( /G/  ) {
    ++$count_of_G;
  } elsif ( /T/  ) {
    ++$count_of_T;
  } else {
    print "!!!!!!!! Error - I don\'t recognize this base: ";
    print;
    print "\n";
    ++$errors;
  }
}
\end{lstlisting}

This version of the \verb|foreach| loop:

\begin{lstlisting}
foreach(@DNA) {.
\end{lstlisting}

doesn't have a scalar value. In a \verb|foreach| loop, if you don't specify a scalar variable to hold the scalars that are being read from the array (\verb|$base| served that function in the version of this loop in \autoref{exam:example5.5}), Perl uses the special variable \verb|$_|.

Furthermore, many Perl built-in functions operate on this special variable if no argument is provided to them. Here, the conditional tests are simply patterns; Perl assumes you're doing a pattern match on the \verb|$_| variable, so it behaves as if you had said \verb|$_ =~ /A/|, for instance. Finally, in the error message, the statement \verb|print;| prints the value of the \verb|$_| variable.

This special variable \verb|$_| that doesn't have to be named appears in many Perl programs, although I don't use it extensively in this book. 

\section{Operating on Strings}
It's not necessary to explode a string into an array in order to look at each character. In fact, sometimes you'd want to avoid that. A large string takes up a large amount of memory in your computer. So does a large array. When you explode a string into an array, the original string is still there, and you also have to make a copy of each character for the elements of the new array you're creating. If you have a large string, that already uses a good portion of available memory, creating an additional array can cause you to run out of memory. When you run out of memory, your computer performs poorly; it can slow to a crawl, crash, or freeze ("hang"). These haven't been worrisome considerations up to now, but if you use large data sets (such as the human genome), you have to take these things into account.

So let's say you'd like to avoid making a copy of the DNA sequence data into another variable. Is there a way to just look at the string \verb|$DNA| and count the bases from it directly? Yes. Here's some pseudocode, followed by a Perl program: 

\begin{lstlisting}
read in the DNA from a file

join the lines of the file into a single string of $DNA

# initialize the counts
count_of_A = 0
count_of_C = 0
count_of_G = 0
count_of_T = 0

for each base at each position in $DNA

  if base is A
    count_of_A = count_of_A + 1
  if base is C
    count_of_C = count_of_C + 1
  if base is G
    count_of_G = count_of_G + 1
  if base is T
    count_of_T = count_of_T + 1
done

print count_of_A, count_of_C, count_of_G, count_of_T
\end{lstlisting}

\autoref{exam:example5.6} shows a program that examines each base in a string of DNA. 

\textbf{Example 5-6. Determining frequency of nucleotides, take 2}
\lstinputlisting[label=exam:example5.6]{./scripts/example5-6.pl}

Here's the output of \autoref{exam:example5.6}:

\begin{lstlisting}
Please type the filename of the DNA sequence data: small.dna
!!!!!!!! Error - I don't recognize this vase: V
A = 40
C = 27
G = 24
T = 17
errors = 1
\end{lstlisting}

In \autoref{exam:example5.6}, I added a line of code to see if the file exists:

\begin{lstlisting}
unless ( -e $dna_filename ) {
\end{lstlisting}

There are file test operators for several conditions; see \autoref{chap:chapterab} or Perl documentation under \textit{-X}. Note that files have several attributes, such as size, permission, location in the filesystem, and type of file, and that many of these things can be tested for easily with the file test operators.  
Notice, also, that I have kept the detailed comments about the regular expression, because regular expressions can be hard to read, and a little commenting here helps a reader to skim the code.

Everything else is familiar, until you hit the \verb|for| loop; it requires a little explanation: 

\begin{lstlisting}
for ( $position = 0 ; $position < length $DNA ; ++$position ) {
  
  # the statements in the block
}
\end{lstlisting}

This \textit{for} loop is the equivalent of this \textit{while} loop: 

\begin{lstlisting}
$position = 0;

while( $position < length $DNA ) {

  # the same statements in the block, plus ...

  ++$position;
}
\end{lstlisting}

Take a moment and compare these two loops. You'll see the same statements but in different locations.

As you can see, the \textit{for} loop brings the initialization and increment of a counter (\verb|$position|) into the loop statement, whereas in the \textit{while} loop, they are separate statements. In the \textit{for} loop, both the initialization and the increment statement are placed between parentheses, whereas you find only the conditional test in the \textit{while} loop. In the \textit{for} loop, you can put initializations before the first semicolon and increment statements after the second semicolon. The initialization statement is done just once before starting the loop, and the increment statement is done at the end of each iteration through the block before going back to the conditional test. It's really just a shorthand for the equivalent \textit{while} loop as just shown. 

The conditional test checks to see if the position reached in the string is less than the length of the string. It uses the \textit{length} Perl function.  Obviously, you don't want to check characters beyond the length of the string. But a word is in order here about the numbering of positions in strings and arrays.

By default, Perl assumes that a string begins at position \verb|0| and its last character is at a position that's numbered one less than the length of the string. Why do it this way instead of numbering the positions from 1 up to and including the length of the string? There are reasons, but they're somewhat abstruse; see the documentation for enlightenment. If it's any comfort, many other programming languages make the same choice. (However, many do it the intuitive way, starting at 1. Ah well.)

This way of numbering is important to biologists because they are used to numbering sequences beginning with 1, not with \verb|0| the way Perl does it. You sometimes have to add 1 to a position before printing out results so they'll make sense to nonprogrammers. It's mildly annoying, but you'll get used to it.

The same holds true for numbering the elements of an array. The first element of an array is element \verb|0|; the last is element \verb|$length-1|.

Anyway, you see that the conditional test evaluates to \verb|true| while the value of \verb|$position| is \verb|length-1| or less and fails when \verb|$position| reaches the same value as the length of the string. For example, say you have a string that contains the text "seeing." This has a length of six characters. The "s" is at position 0, and the "g" is at position 5, which is one less than the string length 6.

Back in the block, you call the \textit{substr} function to look into the string: 

\begin{lstlisting}
$base = substr($DNA, $position, 1);
\end{lstlisting}

This is a fairly general-purpose function for working with strings; you can also insert and delete things. Here, you look at just one character, so you call \textit{substr} on the string \verb|$DNA|, ask it to look in position \verb|$position| for one character, and save the result in scalar variable \verb|$base|. Then you proceed to accumulate the count as in the preceding version of the program, \autoref{exam:example5.4}.  
\section{Writing to Files}
\autoref{exam:example5.7} shows one more way to count nucleotides in a string of DNA. It uses a Perl trick that was designed with exactly this kind of job in mind. It puts a global regular expression search in the test for a \textit{while} loop, and as you'll see, it's a compact way of counting characters in a string.

One of the nice things about Perl is that if you need to do something fairly regularly, the language has probably got a relatively succinct way to do it. (The downside of this is that Perl has a lot of things about it to learn.)

The results of \autoref{exam:example5.7}, besides being printed to the screen, will also be written to a file. The code that accomplishes this writing to a file is as follows: 

\begin{lstlisting}
# Also write the results to a file called "countbase"

$outputfile = "countbase";

unless ( open(COUNTBASE, ">$outputfile")  ) {

  print "Cannot open file \"$outputfile\" to write to!!\n\n";
  exit;
}

print COUNTBASE "A=$a C=$c G=$g T=$t errors=$e\n";

close(COUNTBASE);
\end{lstlisting}

As you see, to write to a file, you do an \textit{open} call, just as when reading from a file, but with a difference: you prepend a greater-than sign \verb|>| to the filename. The filehandle becomes a first argument to a \verb|print| statement (but without a comma following it). This makes the \verb|print| statement direct its output into the file.\footnote{In this case, if the file already exists, it's emptied out first. It's possible to specify several other behaviors. As mentioned earlier, the Perl documentation has all the details of the \textit{open} function, which sets the options for reading from, and writing to, files as well as other actions.}

\autoref{exam:example5.7} is the third version of the Perl program that examines each base in a string of DNA. 

\textbf{Example 5-7. Determining frequency of nucleotides, take 3}
\lstinputlisting[label=exam:example5.7]{./scripts/example5-7.pl}

\autoref{exam:example5.7} looks like this when you run it:

\begin{lstlisting}
Please type the filename of the DNA sequence data: small.dna
A=40 C=27 G=24 T=17 errors=1
\end{lstlisting}

The output file countbase has the following contents after you run \autoref{exam:example5.7}:

\begin{lstlisting}
A=40 C=27 G=24 T=17 errors=1
\end{lstlisting}

The \textit{while} loop:

\begin{lstlisting}
while($dna =~ /a/ig){$a++} 
\end{lstlisting}

has as its conditional test, within the parentheses, a string-matching expression:

\begin{lstlisting}
$dna =~ /a/ig 
\end{lstlisting}

This expression is looking for the regular expression \verb|/a/|, that is, the letter \verb|a|. Since it has the \verb|i| modifier, it's a case-insensitive match, which means it matches \verb|a| or \verb|A|. It also has the global modifier, which means match all the \verb|a|'s in the string. (Without the global modifier, it just keeps returning \verb|true| every time through the loop, if there is an "a" in \verb|$dna|.)

Now, this string-matching expression, in the context of a \textit{while} loop, causes the \textit{while} loop to execute its block on every match of the regular expression. So, append the one-statement block:

\begin{lstlisting}
{$a++}
\end{lstlisting}

to increment the counter at each match of the regular expression; in other words, you're counting all the \verb|a|'s. 

One other point should be made about this third version of the program. You'll notice some of the statements have been changed and shortened this time around. Some variables have shorter names, some statements are lined up on one line, and the \textit{print} statement at the end is more concise. These are just alternative ways of writing. As you program, you'll find yourself experimenting with different approaches: try some on for size.

The way to count bases in this third version is flexible; for instance, it allows you to count non-ACGT characters without specifying them individually. In later chapters, you'll use those \verb|while| loops to good effect. However, there's an even faster way to count bases. You can use the \textit{tr} transliteration function from \autoref{chap:chapter4}; it's faster, which is helpful if you have a lot of DNA to count: 

\begin{lstlisting}
$a = ($dna =~ tr/Aa//);
$c = ($dna =~ tr/Cc//);
$g = ($dna =~ tr/Gg//);
$t = ($dna =~ tr/Tt//);
\end{lstlisting}

The \textit{tr} function returns the count of the specified characters it finds in the string, and if the set of replacement characters is empty, it doesn't actually change the string. So it makes a good character counter. Notice that with \textit{tr}, you have to spell out the upper- and lowercase letters. Also, because \textit{tr} doesn't accept character classes, there's no direct way to count nonbases. You could, however, say: 

\begin{lstlisting}
$basecount = ($dna = ~ tr/ACGTacgt//);
$nonbase = (length $dna) - $basecount)
\end{lstlisting}

The program however, runs faster using \textit{tr} than using the \textit{while} loops of \autoref{exam:example5.7}.

You may find it a bit much to have three (really, four) versions of this base-counting program, especially since much of the code in each version is identical. The only part of the program that really changed was the part that did the counting of the bases. Wouldn't it have been convenient to have a way to just alter the part that counts the bases? In \autoref{chap:chapter6}, you'll see how subroutines allow you to partition your programs in just such a way. 

\section{Exercises}
\textcolor{red}{\textit{Exercise 5.1}}
\begin{adjustwidth}{1cm}{}
Use a loop to write a nonhalting program. The conditional must always evaluate to \verb|true|, every time through the loop. Note that some systems will catch that you're in an infinite loop and will stop the program automatically. You will stop your program differently, depending on which operating system you use. Ctrl-C works on Unix and Linux, a Windows MS-DOS command window, or a MacOS X shell window. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.2}}
\begin{adjustwidth}{1cm}{}
Prompt the user to enter two (short) strings of DNA. Concatenate the two strings of DNA by appending the second to the first using the \verb|.=| assignment operator. Print the two strings as concatenated, and then print the second string lined up over its copy at the end of the concatenated strings. For example, if the input strings are \verb|AAAA| and \verb|TTTT|, print:
\begin{verbatim}
AAAATTTT
    TTTT
\end{verbatim}

\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.3}}
\begin{adjustwidth}{1cm}{}
Write a program that prints all the numbers from 1 to 100. Your program should have much fewer than 100 lines of code! 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.4}}
\begin{adjustwidth}{1cm}{}
Write a program to calculate the reverse complement of a strand of DNA. Do not use the \textit{s///} or the \textit{tr} functions. Use the \textit{substr} function, and examine each base one at a time in the original while you build up the reverse complement. (Hint: you might find it easier to examine the original right to left, rather than left to right, although either is possible.) 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.5}}
\begin{adjustwidth}{1cm}{}
Write a program to report on the percentage of hydrophobic amino acids in a protein sequence. (To find which amino acids are hydrophobic, consult any introductory text on proteins, molecular biology, or cell biology. You will find information sources in \autoref{chap:chapteraa}.) 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.6}}
\begin{adjustwidth}{1cm}{}
Write a program that checks if two strings given as arguments are reverse complements of each other. Use the Perl built-in functions \textit{split}, \textit{pop}, \textit{shift}, and \textit{eq} (\textit{eq} actually an operator). 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.7}}
\begin{adjustwidth}{1cm}{}
Write a program to report how GC-rich some sequence is. (In other words, just give the percentage of G and C in the DNA.)
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.8}}
\begin{adjustwidth}{1cm}{}
Modify \autoref{exam:example5.3} to not only find motifs by regular expressions but to print out the motif that was found. For example, if you search, using regular expressions, for the motif EE.*EE, your program should print EETVKNDEE. You can use the special variable \verb|$&|. After a successful pattern match, this special variable is set to hold the pattern that was matched. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.9}}
\begin{adjustwidth}{1cm}{}
Write a program that switches two bases in a DNA string at specified positions. (Hint: you can use the Perl functions \verb|substr| or \verb|slice|. )
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.10}}
\begin{adjustwidth}{1cm}{}
Write a program that writes a temporary file and then deletes it. The \textit{unlink} function removes a file: just say, for example:
\begin{lstlisting}
unlink "tmpfile";
\end{lstlisting}
but also check to see if \verb|unlink| is successful.
\end{adjustwidth}
