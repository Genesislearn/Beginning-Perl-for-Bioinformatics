\chapter{基序和循环}
\label{chap:chapter5}
\minitoc

本章将在\autoref{chap:chapter4}的基础上进一步介绍Perl语言的基础知识。到本章结束的时候，你将学会：

\begin{itemize}
  \item 在DNA或蛋白质中查找基序
  \item 通过键盘与用户进行交互
  \item 把数据写入文件
  \item 使用循环
  \item 使用基本的正则表达式
  \item 根据条件测试的结果采取不同的行动
  \item 通过字符串和数组的操作对序列数据进行细致的处理
\end{itemize}

所有这些主题，加上在\autoref{chap:chapter4}学习的知识，将使你能够编写出实用的生物信息学程序。在本章中，你将学习编写一个在序列数据中查找基序的程序。

\section{流程控制}
\textit{流程控制}指的就是程序中语句执行的顺序。除非明确指明不按顺序执行，否则程序将从最顶端的第一个语句开始，顺序执行到最底端的最后一个语句。有两种方式可以告诉程序不按照顺序执行：条件语句和循环。\textit{条件语句}只会在条件测试成功的前提下执行相应的语句，否则就会直接跳过这些语句。\textit{循环}会一直重复那些语句，直到相应的测试失败为止。

\subsection{条件语句}
让我们再看一下\textit{open}语句吧。回忆一下，当你试图打开一个并不存在的文件时，你会看到错误信息。在你尝试打开文件之前，可以对文件是否存在进行明确的测试。事实上，类似的测试都是计算机语言最强大的特性之一。\textit{if}、\textit{if-else}和\textit{unless}条件语句就是Perl语言中用来进行类似测试的三个语句。

这类语句的最主要特性就是可以对条件进行测试。条件测试的结果可以是\verb|真（true）|或者是\verb|假（false）|。如果测试结果为\verb|真|，那么后面的语句就会被执行；与之相反，如果测试结果为\verb|假|，这些语句就会被跳过而不执行。

那么，“什么是真呢”？对于这个问题，不同计算机语言的回答会稍有不同。

本节包含了一些演示Perl条件语句的实例，其中的真-假条件测试就是看看两个数字是否相等。注意，因为一个等号\verb|=|是用来对变量进行赋值的，所以两个数字的相等要用两个等号\verb|==|来表示。

\begin{adjustwidth}{2cm}{2cm}
  \parpic[l]{
  \includegraphics[width=1cm]{warning.png}
  }
  =表示赋值、==表示数字相等，这两者非常容易让人混淆，可是说是编程中最常见的“bug”了，所以一定要小心奥！
\end{adjustwidth}

下面这个例子演示了条件测试的结果是\verb|真|还是\verb|假|。平时你很少会用到这么简单的测试；通常，你会测试那些预先并不知道结果的值，比如读入变量的值，或者函数调用的返回值。

条件测试为\verb|真|的\verb|if|语句：

\begin{lstlisting}
if( 1 == 1 ) {
  print "1 equals 1\n\n";
}
\end{lstlisting}

它会输出：

\begin{lstlisting}
1 equals 1
\end{lstlisting}

我们进行的测试是\verb|1 == 1|，用口语来说就是，“1是否等于1”。1确实等于1，所以条件测试的结果为\verb|真|，因此和\verb|if|语句相关联的语句就会被执行，信息被打印了出来。

你也可以这样写：

\begin{lstlisting}
if( 1 ) {
  print "1 evaluates to true\n\n";
}
\end{lstlisting}

它会输出：

\begin{lstlisting}
1 evaluates to true
\end{lstlisting}

条件测试为\verb|假|的\verb|if|语句：

\begin{lstlisting}
if( 1 == 0 ) {
  print "1 equals 0\n\n";
}
\end{lstlisting}

它没有任何输出！我们进行的测试是\verb|1 == 0|，用口语来说就是，“1是否等于0”。1当然不等于0了，所以条件测试的结果为\verb|假|，因此和\verb|if|语句相关联的语句就不会被执行，不会输出任何信息。

你也可写成：

\begin{lstlisting}
if( 0  ) {
  print "0 evaluates to true\n\n";
}
\end{lstlisting}

因为0的测试结果为\verb|假|，所以它不会产生任何输出，因此和\verb|if|语句相关联的语句会完全被跳过。

还有一种编写短小的\verb|if|语句的方法，它模拟的是英语中if的用法。在英语中，你可以说，“If you build it, they will come”，或者，“They will come if you build it”，这两种说法是完全等同的。Perl也不甘示弱，它也允许你把\verb|if|放在对应的动作之后：

\begin{lstlisting}
print "1 equals 1\n\n" if (1 == 1);
\end{lstlisting}

它和本节中的第一个例子做的事情是完全一样的，输出：

\begin{lstlisting}
1 equals 1
\end{lstlisting}

现在，让我们看一下条件测试为\verb|真|的\verb|if-else|语句：

\begin{lstlisting}
if( 1 == 1 ) {
  print "1 equals 1\n\n";
} else {
  print "1 does not equal 1\n\n";
}
\end{lstlisting}

它会输出：

\begin{lstlisting}
1 equals 1
\end{lstlisting}

当测试结果为\verb|真|时，\verb|if-else|会做某件事情，当测试结果为\verb|假|时，它则会另一件事情。这是条件测试为\verb|假|的\verb|if-else|语句：

\begin{lstlisting}
if( 1 == 0 ) {
  print "1 equals 0\n\n";
} else {
  print "1 does not equal 0\n\n";
}
\end{lstlisting}

它会输出：

\begin{lstlisting}
1 does not equal 0
\end{lstlisting}

最后的例子是\verb|unless|，它和\verb|if|完全相反。它就像英语中的“unless”那样来使用：比如，“Unless you study Russian literature, you are ignorant of Chekov”\footnote{译者注：除非你研究俄国文学，否则你不会对契诃夫有所了解。}。如果测试结果为\verb|真|，它不会采取任何行动；而当测试结果为\verb|假|时，相应的语句就会被执行。如果“you study Russian literature”是\verb|假|的，那么“you are ignorant of Chekov”。\footnote{译者注：如果“你研究俄国文学”是\verb|假|的，那么“你对契诃夫毫无了解”。}

\begin{lstlisting}
unless( 1 == 0 ) {
  print "1 does not equal 0\n\n"\nonumber\\
}
\end{lstlisting}

它会输出：

\begin{lstlisting}
1 does not equal 0
\end{lstlisting}

\subsubsection{条件测试和括号成对}
对这些语句和它们的条件测试，还有两点注释：

第一点，在这些语句的条件部分，有许多测试可以使用。除了在前述实例中使用的数字\textit{相等}\verb|==|外，你还可以对不等\verb|!=|、大于\verb|>|和小于\verb|<|等进行测试。

与之类似，你也可以使用\textit{eq}操作符对字符串相等进行测试：如果两个字符串是一样的，测试结果就是\verb|真|。也有一些文件测试操作符，允许你对文件进行相应的测试：是否存在，是否为空，是否设置了特定的权限，等等（参看\autoref{chap:chapterab}）。另一个比较常用的是对变量名进行测试：如果变量存储的是0，那它就被认为是\verb|假|的；任何其他的数字都被认为是\verb|真|的。如果变量中有非空的字符串，那它就是\verb|真|的；空的字符串用""或者''来表示，它是\verb|假|的。

第二点，注意条件测试之后的语句都被包裹在了成对的大括号内。用大括号括起来的语句叫做块，这在Perl中非常常见。\footnote{虽然这看起来有些奇怪，但块中的最后一个语句并不需要用分号来结尾。}括号成对出现是最普遍的编程特性，比如成对的小括号、中括号、尖括号和大括号：\verb|()|、\verb|[]|、\verb|<>|和\verb|{}|左右括号的数目相等，且它们都出现在正确的位置，这对于Perl程序正常运行来说是至关重要的。

成对使用括号是很难做到的，所以，当你因为少写了括号而导致程序报错时，请不要大惊小怪。这是一个比较常见的语法错误，你需要查阅代码找到缺少括号的地方并把它添加上。随着代码越来越复杂，要找到成对括号出错的地方并对它进行修正会更加具有挑战性。即使括号都在正确的位置，当你阅读代码时，要分清哪些语句是一组也是非常困难的。当然你也可以采取一定的措施来避免这样的问题：每一行代码做的事情不要太多，使用缩进让代码块更加突出明显一些（参看\autoref{sect:section5.2}）。\footnote{有些文本编辑器可以帮你找到配对的括号（举个例子，在vi编辑器中，在一个括号上键入百分号\%就会让光标跳跃到与之配对的括号上去）。} 

回过头来再看看条件语句。就像\autoref{exam:example5.1}中演示的那样，\textit{if-else}还有\textit{if-elsif-else}这样的形式。第一个\textit{if}和\textit{elsifs}中的条件被交替测试，一旦测试结果为\verb|真|，相应的代码块就会被执行，并且剩余的条件测试也会被忽略掉。假设没有一个条件的测试结果为\verb|真|，如果存在\textit{else}代码块，那它就会被执行。\textit{else}代码块是可有可无的。

\textbf{例5-1：if-elsif-else}
\lstinputlisting[label=exam:example5.1]{./scripts/example5-1.pl}

注意\textit{else}代码块的\verb|print|语句中的\verb|\"|，它可以在双引号包裹起来的字符串中打印出双引号（"）。反斜线告诉Perl，把后面紧跟的"当成引号本身，而不是把它当做字符串结束的标志。此外还请注意使用了\textit{eq}来检测字符串的相等。

\autoref{exam:example5.1}的输出：

\begin{lstlisting}
MNIDDKL--the magic word!
\end{lstlisting}

\subsection{循环}
\textit{循环}允许你重复执行被成对大括号包裹起来的语句块。在Perl中有多种方法实现循环：\textit{while}循环、\textit{for}循环、\textit{foreach}循环等等。\autoref{exam:example5.2}（来源于\autoref{chap:chapter4}）演示了如何使用\textit{while}循环从一个文件读取蛋白质序列数据。

\textbf{例5-2：从文件中读取蛋白质序列数据，第四次尝试}
\lstinputlisting[label=exam:example5.2]{./scripts/example5-2.pl}

下面是\autoref{exam:example5.2}的输出：

\begin{lstlisting}
  ######  Here is the next line of the file:
MNIDDKLEGLFLKCGGIDEMQSSRTMVVMGGVSGQSTVSGELQD
  ######  Here is the next line of the file:
SVLQDRSMPHQEILAADEVLQESEMRQQDMISHDELMVHEETVKNDEEQMETHERLPQ
  ######  Here is the next line of the file:
GLQYALNVPISVKQEITFTDVSEQLMRDKKQIR
\end{lstlisting}

在\textit{while}循环中，注意在循环至文件的下一行时\verb|$protein|变量是如何一次次被赋值的。在Perl中，赋值语句会返回赋予的值。此处，条件测试检测的是赋值语句是否成功得读取了另一行。如果有另一行被读入，就会发生赋值行为，条件测试就为\verb|真|，新的一行会被存储在\verb|$protein|变量中，而包含两个\verb|print|语句的代码块也会被执行。如果没有更多行了，赋值就会是未定义，条件测试就为\verb|假|，而程序也会跳过包含两个\verb|print|语句的代码块，退出\textit{while}循环，继续执行程序的后续部分（在这个例子中，就是\textit{close}和\textit{exit}函数）。

\subsubsection{open和unless}
\textit{open}是一个系统调用，因为要打开一个文件，Perl必须向操作系统提出请求。操作系统可以是Unix或Linux、Microsoft Windows或Apple Maintosh等的某个版本。文件被操作系统管理者，因此也只有操作系统能够访问它。

检查系统调用的成功与否是一个好习惯，尤其是当打开文件时更是如此。如果系统调用失败了，而你也没有对它进行检查，那么程序将继续运行，可能会尝试读取或写入一个你并没有打开过的文件。你应该总是检查这种失败，当文件无法打开时，要立即告知程序的使用者。当打开文件失败时，通常情况下你会希望立即退出程序，并尝试打开另一个文件。

在\autoref{exam:example5.2}中，\textit{open}系统调用是\textit{unless}条件测试的一部分。

\textit{unless}和\textit{if}相反。就像在你英语中你可以说“do the statements in the block if the condition is true”（“如果条件为真，就执行代码块中的语句”）一样，你也可以反过来说“do the statements in the block unless the condition is true”（“除非条件为真，否则就执行代码块中的语句”）\footnote{译者注：根据语境，此处应为：“do the statements in the block unless the condition is false”（“除非条件为假，否则就执行代码块中的语句”）。}。如果成功打开了文件，\textit{open}系统调用就会返回真值；在这个例子的\textit{unless}语句条件测试中，如果\textit{open}系统调用失败了，那么代码块中的语句就会被执行，程序会输出错误信息，随后退出。

总结一下，在Perl中，条件和循环都是比较简单的概念，学起来并不困难。它们是编程语言最强大的特性之一。条件可以使你的程序适应不同的状况，使用这种方式，就可以针对不同的输入采取不同的方案了。在人工智能的计算机程序中，它占了相当大的比重。循环充分利用了计算机的速度，利用循环，仅仅使用几行代码，你就可以处理大量的输入，或者对计算进行重复迭代与提炼。

\section{代码布局}
\label{sect:section5.2}
一旦你开始使用循环和条件语句，你就需要认真考虑格式的问题了。当格式化Perl代码时你有多种选择。对于\verb|while|循环中的\textit{if}语句，比较一下下面几种不同的格式化方法：

\textcolor{red}{\textit{格式A}}
\begin{adjustwidth}{1cm}{}
\begin{lstlisting}
while ( $alive ) {
  if ( $needs_nutrients ) {
    print "Cell needs nutrients\n";
  }
}
\end{lstlisting}
\end{adjustwidth}

\textcolor{red}{\textit{格式B}}
\begin{adjustwidth}{1cm}{}
\begin{lstlisting}
while ( $alive )
{
  if ( $needs_nutrients )
  {
    print "Cell needs nutrients\n";
  }
}
\end{lstlisting}
\end{adjustwidth}

\textcolor{red}{\textit{格式C}}
\begin{adjustwidth}{1cm}{}
\begin{lstlisting}
  while ( $alive )
    {
      if ( $needs_nutrients )
{
  print "Cell needs nutrients\n";
}
}
\end{lstlisting}
\end{adjustwidth}

\textcolor{red}{\textit{格式D}}
\begin{adjustwidth}{1cm}{}
\begin{lstlisting}
while($alive){if($needs_nutrients){print "Cell needs nutrients\n";}}
\end{lstlisting}
\end{adjustwidth}

对于Perl解释器来说，所有这些代码片段都是一样的，因为Perl并不依赖于每一行中语句的布局方式，它只关心句法元素的正确顺序。有些元素在它们中间需要空白（比如空格、制表符或者换行符），这样就可以把它们区别开了，但通常来说，对于你使用空白来布局代码的方式，Perl不会进行特别的限定。

格式A和B是布局代码最常见的方式。它们都使程序结构更加清晰，便于人们阅读。对于\textit{while}和\textit{if}这种附带着代码块的语句来说，注意观察是如何排列大括号、以及缩进代码块中的语句的。这种布局使得语句附带的代码块的范围更加清晰一些。（这对于长的、复杂的代码块是非常关键的。）代码块中的语句都进行了缩进，通常你使用制表符键或者四个或八个空格就可以实现这种缩进。（许多文本编辑器可以使你在敲击制表符键时输入空格，或者你可以对它们进行配置，使得用制表符键就可以输入四个、八个或者任意数目的空格。）使用这种方式，程序的总体结构变得更加清晰了，你可以轻而易举得看出那些语句是归类在循环或条件语句附带的代码块中的。就个人而言，尽管我也非常乐意使用格式B，但我更加喜欢格式A的布局。

格式C是格式化代码的反面教材。代码的流控制很不清晰，举个例子，很难看出\textit{print}语句是否在\textit{while}语句的代码块中。

格式D演示了，在对代码不进行任何格式化的情况下，即使对于这样一个简单的代码片段来说，要阅读它是多么的困难。

从Perl的手册也中可以找到Perl的风格指南，或者输入下面的命令也可以：

\begin{lstlisting}
perldoc perlstyle
\end{lstlisting}

对于如何编写可读性好的代码，Perl风格指南给出了不少的建议和意见。然而，这些并不是规则，你可以使用在经过众多格式化练习后找到的最适合你自己的代码布局方案。

\section{查找基序}
在生物信息学中我们最常做的事情之一就是查找基序，即特定的DNA或蛋白质片段。这些基序可能是DNA的调控元件，也可能是已知在多个物种中保守的蛋白质片段。（PROSITE网站——\href{http://www.expasy.ch/prosite/}{http://www.expasy.ch/prosite/}——有关于蛋白质基序的更多信息。）

在生物学序列中你要查找的基序往往不是特定的一个序列，它们可能有一些变体——比如，某个位置上的碱基或者残基是什么并不重要。它们也有可能有不同的长度。但通常它们都可以用正则表达式来进行表征，在接下来的\autoref{exam:example5.3}、\autoref{chap:chapter9}以及本书中的许多地方，你都可以看到更多关于正则表达式的讨论。

Perl有一系列在字符串中进行查找的便利的特性，这同样使得Perl成为生物信息学领域中流行的语言。\autoref{exam:example5.3}对这种字符串搜索的能力进行了演示；它做的事情真的非常实用，许多类似的程序在生物学研究中一直被使用着。它做的事情包括：

\begin{itemize}
  \item 从文件中读入蛋白质序列数据
  \item 为了便于搜索，把所有的序列数据都放到一个字符串中
  \item 查找用户通过键盘键入的基序
\end{itemize}

\textbf{例5-3：查找基序}
\lstinputlisting[label=exam:example5.3]{./scripts/example5-3.pl}

这是\autoref{exam:example5.3}典型的一个输出：

\begin{lstlisting}
Please type the filename of the protein sequence data:
NM_021964fragment.pep
Enter a motif to search for: SVLQ
I found it!

Enter a motif to search for: jkl
I couldn't find it.

Enter a motif to search for: QDSV
I found it!

Enter a motif to search for: HERLPQGLQ
I found it!

Enter a motif to search for: 
I couldn't find it. 
\end{lstlisting}

就像你在结果中看到的那样，这个程序查找用户通过键盘键入的基序。利用这样一个程序，你就不用再在海量的数据中手工进行查找了。让计算机来做这样的工作，它比人工做的更快、更准确。

如果程序不仅报告它找到了基序，还能告诉我们在哪里找到了它，那就更好了。在\autoref{chap:chapter9}中你将看到如何来实现这个目标，那一章的一个练习要求你对这个程序进行修改，使得它能够报告基序的位置。

接下来的小节将对\autoref{exam:example5.3}中这些新的内容进行介绍与讨论：

\begin{itemize}
  \item 获取用户的键盘输入
  \item 把文件的所有行合并到一个标量变量中
  \item 正则表达式和字符组
  \item \verb|do-until|循环
  \item 模式匹配
\end{itemize}

\subsection{获取用户的键盘输入}
在\autoref{exam:example4.5}中你第一次遇到文件句柄。在\autoref{exam:example5.3}中（在\autoref{exam:example4.3}中也是这样），使用文件句柄和尖括号输入操作符从打开的文件中读入数据并保存到数组中，就像这样：

\begin{lstlisting}
@protein = <PROTEINFILE>;
\end{lstlisting}

Perl使用同样的语法获取用户的键盘输入。在\autoref{exam:example5.3}中，为了获取用户的键盘输入，使用了一个叫做STDIN（standard input（标准输入）的简写）的特殊的文件句柄，就像这行从用户键盘输入获取文件名的代码一样：

\begin{lstlisting}
$proteinfilename = <STDIN>;
\end{lstlisting}

文件句柄可以和一个文件相关联，也可以和用户回答程序问题时的键盘输入相关联。

就像这个代码片段一样，如果你用来存储输入的变量是一个以美元符号（\verb|$|）起始的标量变量，那么将只有一行被读入，这往往也是在这种情况下你希望的结果。

在\autoref{exam:example5.3}中，用户被要求输入一个包含蛋白质序列数据的文件的文件名。在通过这种方式得到文件名后，打开文件之前还需要一步操作。当用户键入文件名并通过Enter键（也叫做Return键）换行时，文件名和其末尾的换行符一起被保存进了变量中。这个换行符并不是文件名的一部分，所以在使用\textit{open}系统调用之前应该把它去除掉。Perl函数\textit{chomp}会去除掉字符串末尾的换行符newlines（或者它的表亲换行符linefeeds和回车符carriage returns）。（更加古老的\textit{chop}函数会删除最后一个字符，不管这个字符是什么；这会导致一些问题，所以\textit{chomp}被引入了进来，而它也总是被优先考虑使用的。）

所以这一个部分还有一点附带的知识：删除获取的用户键盘输入中的换行符。试着把\verb|chomp|函数注释掉，你会看到\verb|open|调用失败，因为并没有末尾包含换行符的文件名。（对于文件名中可以使用的字符，操作系统有自己的规定。）

\subsection{使用join把数组合并成标量}
\label{sect:section5.3.2}
常常可以发现，蛋白质序列数据被打断成了短的片段，每个片段有大约80个字符。原因很简单：当要把数据打印到纸张上或展示在屏幕上时，根据纸张或屏幕的空间需要把它打断成数行。你的数据被打断成了片段，但对你的Perl程序来说却多有不便。当你要查找一个基序，而它却被换行符分割开了，这会怎样呢？你的程序将无法找到这个基序。事实上，\autoref{exam:example5.3}中查找的一些基序确实被换行符分割开了。在Perl中，你可以使用\textit{join}函数来处理类似的片段数据。在\autoref{exam:example5.3}中，\textit{join}把存储在\verb|@protein|数组中的数据的所有行合并成一个单独的字符串，并把它保存在了新的标量变量\verb|$protein|中：

\begin{lstlisting}
$protein = join( '', @protein );
\end{lstlisting}

当合并数组时，你需要指定一个字符串，这个字符串会放在数组的各个元素之间。在这个例子中，你指定的是空字符串，它会放在输入文件的各行之间。空字符串就夹在成对的单引号''中（当然也可以使用双引号""）。


回忆一下\autoref{exam:example4.2}，在那个例子中，我介绍了好几种串联两个DNA片段的方法。\textit{join}函数的作用与之类似，它取出数组元素的变量值并把它们串联成一个单独的标量值。回忆一下\autoref{exam:example4.2}中的下列语句，它是串联两个字符串的方法之一：

\begin{lstlisting}
$DNA3 = $DNA1 . $DNA2;
\end{lstlisting}

另一种实现同样串联的方法是使用\textit{join}函数：

\begin{lstlisting}
$DNA3 = join( "", ($DNA1, $DNA2) );
\end{lstlisting}

在这个例子中，我没有给出数组名，而是指定了一个标量元素的列表：

\begin{lstlisting}
($DNA1, $DNA2)
\end{lstlisting}

\subsection{do-until循环}
在\autoref{exam:example5.3}中有一种新的循环，这就是\verb|do-until|循环，它首先执行一个代码块，之后再进行条件检测。有时它会比常见的先测试、如果测试成功就执行代码块的策略更加方便。在这个例子中，你想提示用户，获取用户的输入，查找基序并报告查找结果。在重复这些动作之前，你进行条件测试来看看用户是否输入了一个空行。输入空行意味着用户没有更多的基序来查找了，所以你就退出循环。

\subsection{正则表达式}
\textit{正则表达式}使你可以轻松处理各种各样的字符串，比如DNA和蛋白质序列数据。正则表达式的强大之处就在于，如果想对字符串进行一些处理，你通常可以使用Perl的正则表达式来完成该任务。

有些正则表达式非常简单。举个例子，你可以把你想搜索的具体文字当成正则表达式来使用：如果我想在本书的文字中超找“bioinformatics”（“生物信息学”），我可以使用这样的正则表达式：

\begin{lstlisting}
/bioinformatics/
\end{lstlisting}

然而，有些正则表达式会更加复杂。在本节中，我会通过\autoref{exam:example5.3}来演示它们的使用。

\subsubsection{正则表达式和字符组}
Regular expressions are ways of matching one or more strings using special wildcard-like operators. Regular expressions can be as simple as a word, which matches the word itself, or they can be complex and made to match a large set of different words (or even every word!).

After you join the protein sequence data into the scalar variable \verb|$protein| in \autoref{exam:example5.3}, you also need to remove newlines and anything else that's not sequence data. This can include numbers on the lines, comments, informational or "header" lines, and so on. In this case, you want to remove newlines and any spaces or tabs that might be invisibly present. The following line of code in \autoref{exam:example5.3} removes this whitespace:

\begin{lstlisting}
$protein =~ s/\s//g;
\end{lstlisting}

The sequence data in the scalar variable \verb|$protein| is altered by this statement. You first saw the binding operator =~ and the substitute function \textit{s///} back in \autoref{exam:example4.3}Example 4-3, where they were used to change one character into another. Here, they're used a little differently. You substitute any one of a set of whitespace characters, represented by \verb|\s| with nothing and by the lack of anything between the second and third forward slashes. In other words, you delete any of a set of whitespace characters, which is done globally throughout the string by virtue of the \verb|g| at the end of the statement.

The \verb|\s| is one of several metasymbols. You've already seen the metasymbol \verb|\n|. The \verb|\s| metasymbol matches any space, tab, newline, carriage return, or formfeed. \verb|\s| can also be written as: 

\begin{lstlisting}
[ \t\n\f\r]
\end{lstlisting}

This expression is an example of a character class and is enclosed in square brackets. A character class matches one character, any one of the characters named within the square brackets. A space is just typed as a space; other whitespace characters have their own metasymbols: \verb|\t| for tab, \verb|\n| for newline, \verb|\f| for formfeed, and \verb|\r| for carriage return. A carriage return causes the next character to be written at the beginning of the line, and a formfeed advances to the next line. The two of them together amount to the same thing as a newline character.

Each \textit{s///} command I've detailed has some kind of regular expression between the first two forward slashes \verb|/|. You've seen single letters as the \verb|C| in \textit{s/C/G/g} in that position. The \verb|C| is an example of a valid regular expression.

There's another use of regular expressions in \autoref{exam:example5.3}. The line of code: 

\begin{lstlisting}
if ( $motif =~ /^\s*$/ ) {
\end{lstlisting}

is, in English, testing for a blank line in the variable \verb|$motif|. If the user input is nothing except for perhaps some whitespace, represented as \verb|\s*|, the match succeeds, and the program exits. The whole regular expression is: 

\begin{lstlisting}
/^\s*$/
\end{lstlisting}

which translates as: match a string that, from the beginning (indicated by the \verb|^|), is zero or more (indicated by the \verb|*|) whitespace characters (indicated by the \verb|\s|) until the end of the string (indicated by the \verb|$|).

If this seems somewhat cryptic, just hang in there and you'll soon get familiar with the terminology. Regular expressions are a great way to manipulate sequence and other text-based data, and Perl is particularly good at making regular expressions relatively easy to use, powerful, and flexible. Many of the references in \autoref{chap:chapteraa} contain material on regular expressions, and there's a concise summary in \autoref{chap:chapterab}.

\cprotect \subsubsection{使用\verb|=~|和正则表达式进行模式匹配}
The actual search for the motif happens in this line from \autoref{exam:example5.3}: 

\begin{lstlisting}
if ( $protein =~ /$motif/ ) {
\end{lstlisting}

Here, the binding operator \verb|=~| searches for the regular expression stored as the value of the variable \verb|$motif| in the protein \verb|$protein|. Using this feature, you can interpolate the value of a variable into a string match. (Interpolation in Perl strings means inserting the value of a variable into a string, as you first saw in \autoref{exam:example4.2} when you were concatenating strings). The actual motif, that is, the value of the string variable \verb|$motif|, is your regular expression. The simplest regular expressions are just strings of characters, such as the motif \verb|AQQK|, for example.

You can use \autoref{exam:example5.3} to play with some more features of regular expressions. You can type in any regular expression to search for in the protein. Try starting up the program, referring to the documentation on regular expressions, and play! Here are some examples of typing in regular expressions: 

\begin{itemize}
  \item Search for an A followed by a D or S, followed by a V: 
\begin{lstlisting}
Enter a motif to search for: A[DS]V
I couldn't find it.
\end{lstlisting}
  \item Search for K, N, zero or more D's, and two or more E's (note that {2,} means "two or more"): 
\begin{lstlisting}
Enter a motif to search for: KND*E{2,}
I found it!
\end{lstlisting}
  \item Search for two E's, followed by anything, followed by another two E's: 
\begin{lstlisting}
Enter a motif to search for: EE.*EE
I found it!
\end{lstlisting}
\end{itemize}

In that last search, notice that a period stands for any character except a newline, and ".*" stands for zero or more such characters. (If you want to actually match a period, you have to escape it with a backslash.) 

\section{Counting Nucleotides}
There are many things you might want to know about a piece of DNA. Is it coding or noncoding?\footnote{Coding DNA is DNA that codes for a protein, that is, it is part of a gene. In many organisms, including humans, a large part of the DNA is noncoding—not part of genes and doesn't code for proteins. In humans, about 98-99\% of DNA is noncoding.} Does it contain a regulatory element? Is it related to some other known DNA, and if so, how? How many of each of the four nucleotides does the DNA contain? In fact, in some species the coding regions have a specific nucleotide bias, so this last question can be important in finding the genes. Also, different species have different patterns of nucleotide usage. So counting nucleotides can be interesting and useful.

In the following sections are two programs, \autoref{exam:example5.4} and \autoref{exam:example5.6}, that make a count of each type of nucleotide in some DNA. They introduce a few new parts of Perl:

\begin{itemize}
  \item "Exploding" a string
  \item Looking at specific locations in strings
  \item Iterating over an array
  \item Iterating over the length of a string
\end{itemize}

To get the count of each type of nucleotide in some DNA, you have to look at each base, see what it is, and then keep four counts, one for each nucleotide. We'll do this in two ways:

\begin{itemize}
  \item Explode the DNA into an array of single bases, and iterate over the array (that is, deal with the elements of the array one by one)
  \item Use the \textit{substr} Perl function to iterate over the positions in the string of DNA while counting
\end{itemize}

First, let's start with some pseudocode of the task. Afterwards, we'll make more detailed pseudocode, and finally write the Perl program for both approaches.

The following pseudocode describes generally what is needed:

\begin{lstlisting}
for each base in the DNA
  if base is A
    count_of_A = count_of_A + 1
  if base is C
    count_of_C = count_of_C + 1
  if base is G
    count_of_G = count_of_G + 1
  if base is T
    count_of_T = count_of_T + 1
done

print count_of_A, count_of_C, count_of_G, count_of_T
\end{lstlisting}

As you can see, this is a pretty simple idea, mirroring what you'd do by hand if you had to. (If you want to count the relative frequencies of the bases in all human genes, you can't do it by hand—there are too many of them—and you have to use such a program. Thus bioinformatics.) Now let's see how it can be coded in Perl. 

\section{Exploding Strings into Arrays}
Let's say you decide to explode the string of DNA into an array. By explode I mean separating out each letter in the string—sort of like blowing the string into bits. In other words, the letters representing the bases of the DNA in the string are separated, and each letter becomes its own scalar value in an array. Then you can look at the array elements (each of which is a single character) one by one, making the count as you go along. This is the inverse of the \verb|join| function in \autoref{sect:section5.3.2}, which takes an array of strings and makes a single scalar value out of them. (After exploding a string into an array, you could then join the array back into an identical string using \verb|join|, if you so desire.)

I'm also adding to this version of the pseudocode the instructions to get the DNA from a file and manipulate that file data until it's a single string of DNA sequence. So first, you join the data from the array of lines of the original file data, clean it up by removing whitespace until only sequence is left, and then explode it back into an array. But, of course, the point is that the last array has exactly what is needed, the data in a convenient form to use in the counting loop. Instead of an array of lines, with newlines and possibly other unwanted characters, there's an exact array of the individual bases. 

\begin{lstlisting}
read in the DNA from a file

join the lines of the file into a single string $DNA

# make an array out of the bases of $DNA
@DNA = explode $DNA

# initialize the counts
count_of_A = 0
count_of_C = 0
count_of_G = 0
count_of_T = 0

for each base in @DNA

  if base is A
    count_of_A = count_of_A + 1
  if base is C
    count_of_C = count_of_C + 1
  if base is G
    count_of_G = count_of_G + 1
  if base is T
    count_of_T = count_of_T + 1
done

print count_of_A, count_of_C, count_of_G, count_of_T
\end{lstlisting}

As promised, this version of the pseudocode is a bit more detailed. It suggests a method to look at each of the bases by exploding the string of DNA into an array of single characters. It also initializes the counts to zero to ensure they start off right. It's easier to see what's happening if you spell out the initialization in the program, and it can prevent certain kinds of errors from creeping into your code. (It's not a rule, however; sometimes, you may prefer to leave the values of variables undefined until they are used.) Perl assumes that an uninitialized variable has the value 0 if you try to use it as a number, for instance by adding another number to it. But you'll most likely get a warning if that is the case.

We now have a design for the program, let's turn it into Perl code.  \autoref{exam:example5.4} is a workable program; you'll see other ways to accomplish the same task more quickly as you proceed in this chapter, but speed is not the main concern at this point. 

\textbf{Example 5-4. Determining frequency of nucleotides}
\lstinputlisting[label=exam:example5.4]{./scripts/example5-4.pl}

To demonstrate \autoref{exam:example5.4}, I have created the following small file of DNA and called it \textit{small.dna}: 

\begin{lstlisting}
AAAAAAAAAAAAAAGGGGGGGTTTTCCCCCCCC
CCCCCGTCGTAGTAAAGTATGCAGTAGCVG
CCCCCCCCCCGGGGGGGGAAAAAAAAAAAAAAATTTTTTAT
AAACG
\end{lstlisting}

The file \textit{small.dna} can be typed into your computer using your favorite text editor, or you can download it from this book's web site.

Notice that there is a V in the file, an error.\footnote{Files of DNA sequence data sometimes include such characters as N, meaning "some undetermined base," or other special characters.  You sometimes have to look at the documentation for the source, say an ABI sequencer or a GenBank file or whatever, to discover which characters are used and what they mean.} Here is the output of \autoref{exam:example5.4}:

\begin{lstlisting}
Please type the filename of the DNA sequence data: small.dna
!!!!!!!! Error - I don't recognize this base: V

A = 40
C = 27
G = 24
T = 17
\end{lstlisting}

Now let's look at the new stuff in this program. Opening and reading the sequence data is the same as previous programs. The first new thing is at this line:

\begin{lstlisting}
@DNA = split( '', $DNA );
\end{lstlisting}

which the comments say will explode the string \verb|$DNA| into an array of single characters \verb|@DNA|.

\textit{split} is the companion to \textit{join}, and it's a good idea to take a little while to look over the documentation for these two commands. Calling \textit{split} with an empty string as the first argument causes the string to explode into individual characters; that's just what we want.\footnote{As you'll see in the documentation for the split function, the first argument can be any regular expression, such as \verb|/\s+/| (one or more adjacent whitespace characters.)}

Next, there are five scalar variables initialized to 0, the variables \verb|$count_of_A| and so forth. I nitializing means assigning an initial value, in this case, the value 0. 

\autoref{exam:example5.4} illustrates the concepts of type and initialization. The type of a variable determines what kind of data it can hold, for instance, strings or numbers. Up to now we've been using scalar variables such as \verb|$DNA| to store strings of letters such as A, C, G, and T. \autoref{exam:example5.4} shows that you can also use scalar variables to store numbers. For example, the variable \verb|$count_of_A| keeps a running count of the character A.

Scalar variables can store integers (0, 1, -1, 2, -2, \ldots), decimal or floating-point numbers such as 6.544, and numbers in scientific notation such as 6.544E6, which translates as 6.544 x 106, or 6,544000.  (See \autoref{chap:chapterab} for more details on types of numbers.)

In \autoref{exam:example5.4}, the variables \verb|$count_of_A| through \verb|$count_of_T| are initialized to 0. \textit{Initializing} a variable means giving it a value after it's declared. If you don't initialize your variables, they assume the value of \verb|'undef'|. In Perl, an undefined variable is 0 if it is asked for in numerical context; it's an empty string if used in a string operation. Although Perl programmers often choose not to initialize variables, it's a critical step in many other languages. In C for instance, uninitialized variables have unpredictable values. This can wreak havoc with your output. You should get in the habit of initializing variables; it makes the program easier to read and maintain, and that's important.

To \textit{declare} a variable means to specify its name and other attributes such as an initial value and a scope (for scoping, see \autoref{chap:chapter6} and the discussion of \verb|my| variables). Many languages require you to declare all variables before using them. For this book, up to now, declarations have been an unnecessary complication. The next chapter begins to require declarations. In Perl, you may declare a variable's scope (see \autoref{chap:chapter6} and the discussion of \verb|my| variables) in addition to an initial value.  Many languages also require you to declare the type of a variable, for example "integer," or "string," but Perl does not.

Perl is written to be smart about what's in a scalar variable. For instance, you can assign the number \verb|1234| (without quotes) to a variable, or you can assign the string \verb|'1234'| (with quotes). Perl treats the variable as a string for printing, and as a number for using in arithmetic operations, without your having to worry about it. \autoref{exam:example5.5} demonstrates this ability. In other words, Perl isn't strict about specifying the type of data a variable is used for. 

\textbf{Example 5-5. Demonstration of Perl's built-in knowledge about numbers and strings}
\lstinputlisting[label=exam:example5.5]{./scripts/example5-5.pl}

\autoref{exam:example5.5} produces the output:

\begin{lstlisting}
1234 1234
2468
12341234
\end{lstlisting}

\autoref{exam:example5.5} illustrates the smart way Perl determines the datatype of a scalar variable, whether it's a string or a number, and whether you're trying to add or subtract it like a number or concatenate it like a string. Perl behaves accordingly, which makes your job as a programmer a little bit easier; Perl "does the right thing" for you.

Next is a new kind of loop, the \verb|foreach| loop. This loop works over the elements of an array. The line: 

\begin{lstlisting}
foreach $base (@DNA) {
\end{lstlisting}

loops over the elements of the array \verb|@DNA|, and each time through the loop, the scalar variable \verb|$base| (or whatever name you choose) is set to the next element of the array.

The body of the loop checks for each base and increments the count for
that base if found. There are four ways to add \verb|1| to a number in Perl.
Here, you put a \verb|++| in front of the variable, like this:

\begin{lstlisting}
++$count; 
\end{lstlisting}

You can also put the \verb|++| after the variable:

\begin{lstlisting}
$count++;
\end{lstlisting}

You can spell it out like this, a combination of adding and assignment:

\begin{lstlisting}
$count = $count + 1;
\end{lstlisting}

or, as a shorthand of that, you can say:

\begin{lstlisting}
$count += 1;
\end{lstlisting}

Almost an embarrassment of riches. The plus-plus (\verb|++|) notation is convenient for incrementing counts, as we're doing here. The plus-equals (\verb|+=|) notation saves some typing and is very popular for adding other numbers besides 1.

The \verb|foreach| loop in \autoref{exam:example5.5} could have been written like this:

\begin{lstlisting}
foreach (@DNA) {
  
  if ( /A/ ) {
    ++$count_of_A;
  } elsif ( /C/  ) {
    ++$count_of_C;
  } elsif ( /G/  ) {
    ++$count_of_G;
  } elsif ( /T/  ) {
    ++$count_of_T;
  } else {
    print "!!!!!!!! Error - I don\'t recognize this base: ";
    print;
    print "\n";
    ++$errors;
  }
}
\end{lstlisting}

This version of the \verb|foreach| loop:

\begin{lstlisting}
foreach(@DNA) {.
\end{lstlisting}

doesn't have a scalar value. In a \verb|foreach| loop, if you don't specify a scalar variable to hold the scalars that are being read from the array (\verb|$base| served that function in the version of this loop in \autoref{exam:example5.5}), Perl uses the special variable \verb|$_|.

Furthermore, many Perl built-in functions operate on this special variable if no argument is provided to them. Here, the conditional tests are simply patterns; Perl assumes you're doing a pattern match on the \verb|$_| variable, so it behaves as if you had said \verb|$_ =~ /A/|, for instance.  Finally, in the error message, the statement \verb|print;| prints the value of the \verb|$_| variable.

This special variable \verb|$_| that doesn't have to be named appears in many Perl programs, although I don't use it extensively in this book. 

\section{Operating on Strings}
It's not necessary to explode a string into an array in order to look at each character. In fact, sometimes you'd want to avoid that. A large string takes up a large amount of memory in your computer. So does a large array. When you explode a string into an array, the original string is still there, and you also have to make a copy of each character for the elements of the new array you're creating. If you have a large string, that already uses a good portion of available memory, creating an additional array can cause you to run out of memory. When you run out of memory, your computer performs poorly; it can slow to a crawl, crash, or freeze ("hang"). These haven't been worrisome considerations up to now, but if you use large data sets (such as the human genome), you have to take these things into account.

So let's say you'd like to avoid making a copy of the DNA sequence data into another variable. Is there a way to just look at the string \verb|$DNA| and count the bases from it directly? Yes. Here's some pseudocode, followed by a Perl program: 

\begin{lstlisting}
read in the DNA from a file

join the lines of the file into a single string of $DNA

# initialize the counts
count_of_A = 0
count_of_C = 0
count_of_G = 0
count_of_T = 0

for each base at each position in $DNA

  if base is A
    count_of_A = count_of_A + 1
  if base is C
    count_of_C = count_of_C + 1
  if base is G
    count_of_G = count_of_G + 1
  if base is T
    count_of_T = count_of_T + 1
done

print count_of_A, count_of_C, count_of_G, count_of_T
\end{lstlisting}

\autoref{exam:example5.6} shows a program that examines each base in a string of DNA. 

\textbf{Example 5-6. Determining frequency of nucleotides, take 2}
\lstinputlisting[label=exam:example5.6]{./scripts/example5-6.pl}

Here's the output of \autoref{exam:example5.6}:

\begin{lstlisting}
Please type the filename of the DNA sequence data: small.dna
!!!!!!!! Error - I don't recognize this vase: V
A = 40
C = 27
G = 24
T = 17
errors = 1
\end{lstlisting}

In \autoref{exam:example5.6}, I added a line of code to see if the file exists:

\begin{lstlisting}
unless ( -e $dna_filename ) {
\end{lstlisting}

There are file test operators for several conditions; see \autoref{chap:chapterab} or Perl documentation under \textit{-X}. Note that files have several attributes, such as size, permission, location in the filesystem, and type of file, and that many of these things can be tested for easily with the file test operators.  
Notice, also, that I have kept the detailed comments about the regular expression, because regular expressions can be hard to read, and a little commenting here helps a reader to skim the code.

Everything else is familiar, until you hit the \verb|for| loop; it requires a little explanation: 

\begin{lstlisting}
for ( $position = 0 ; $position < length $DNA ; ++$position ) {
  
  # the statements in the block
}
\end{lstlisting}

This \textit{for} loop is the equivalent of this \textit{while} loop: 

\begin{lstlisting}
$position = 0;

while( $position < length $DNA ) {

  # the same statements in the block, plus ...

  ++$position;
}
\end{lstlisting}

Take a moment and compare these two loops. You'll see the same statements but in different locations.

As you can see, the \textit{for} loop brings the initialization and increment of a counter (\verb|$position|) into the loop statement, whereas in the \textit{while} loop, they are separate statements. In the \textit{for} loop, both the initialization and the increment statement are placed between parentheses, whereas you find only the conditional test in the \textit{while} loop. In the \textit{for} loop, you can put initializations before the first semicolon and increment statements after the second semicolon. The initialization statement is done just once before starting the loop, and the increment statement is done at the end of each iteration through the block before going back to the conditional test. It's really just a shorthand for the equivalent \textit{while} loop as just shown. 

The conditional test checks to see if the position reached in the string is less than the length of the string. It uses the \textit{length} Perl function.  Obviously, you don't want to check characters beyond the length of the string. But a word is in order here about the numbering of positions in strings and arrays.

By default, Perl assumes that a string begins at position \verb|0| and its last character is at a position that's numbered one less than the length of the string. Why do it this way instead of numbering the positions from 1 up to and including the length of the string? There are reasons, but they're somewhat abstruse; see the documentation for enlightenment. If it's any comfort, many other programming languages make the same choice.  (However, many do it the intuitive way, starting at 1. Ah well.)

This way of numbering is important to biologists because they are used to numbering sequences beginning with 1, not with \verb|0| the way Perl does it. You sometimes have to add 1 to a position before printing out results so they'll make sense to nonprogrammers. It's mildly annoying, but you'll get used to it.

The same holds true for numbering the elements of an array. The first element of an array is element \verb|0|; the last is element \verb|$length-1|.

Anyway, you see that the conditional test evaluates to \verb|true| while the value of \verb|$position| is \verb|length-1| or less and fails when \verb|$position| reaches the same value as the length of the string. For example, say you have a string that contains the text "seeing." This has a length of six characters. The "s" is at position 0, and the "g" is at position 5, which is one less than the string length 6.

Back in the block, you call the \textit{substr} function to look into the string: 

\begin{lstlisting}
$base = substr($DNA, $position, 1);
\end{lstlisting}

This is a fairly general-purpose function for working with strings; you can also insert and delete things. Here, you look at just one character, so you call substr on the string \verb|$DNA|, ask it to look in position \verb|$position| for one character, and save the result in scalar variable \verb|$base|. Then you proceed to accumulate the count as in the preceding version of the program, \autoref{exam:example5.4}. 

\section{Writing to Files}
\autoref{exam:example5.7} shows one more way to count nucleotides in a string of DNA.  It uses a Perl trick that was designed with exactly this kind of job in mind. It puts a global regular expression search in the test for a \textit{while} loop, and as you'll see, it's a compact way of counting characters in a string.

One of the nice things about Perl is that if you need to do something fairly regularly, the language has probably got a relatively succinct way to do it. (The downside of this is that Perl has a lot of things about it to learn.)

The results of \autoref{exam:example5.7}, besides being printed to the screen, will also be written to a file. The code that accomplishes this writing to a file is as follows: 

\begin{lstlisting}
# Also write the results to a file called "countbase"

$outputfile = "countbase";

unless ( open(COUNTBASE, ">$outputfile")  ) {

  print "Cannot open file \"$outputfile\" to write to!!\n\n";
  exit;
}

print COUNTBASE "A=$a C=$c G=$g T=$t errors=$e\n";

close(COUNTBASE);
\end{lstlisting}

As you see, to write to a file, you do an open call, just as when reading from a file, but with a difference: you prepend a greater-than sign \verb|>| to the filename. The filehandle becomes a first argument to a \verb|print| statement (but without a comma following it). This makes the \verb|print| statement direct its output into the file.\footnote{In this case, if the file already exists, it's emptied out first. It's possible to specify several other behaviors. As mentioned earlier, the Perl documentation has all the details of the open function, which sets the options for reading from, and writing to, files as well as other actions.}

\autoref{exam:example5.7} is the third version of the Perl program that examines each base in a string of DNA. 

\textbf{Example 5-7. Determining frequency of nucleotides, take 3}
\lstinputlisting[label=exam:example5.7]{./scripts/example5-7.pl}

\autoref{exam:example5.7} looks like this when you run it:

\begin{lstlisting}
Please type the filename of the DNA sequence data: small.dna
A=40 C=27 G=24 T=17 errors=1
\end{lstlisting}

The output file countbase has the following contents after you run \autoref{exam:example5.7}:

\begin{lstlisting}
A=40 C=27 G=24 T=17 errors=1
\end{lstlisting}

The \textit{while} loop:

\begin{lstlisting}
while($dna =~ /a/ig){$a++} 
\end{lstlisting}

has as its conditional test, within the parentheses, a string-matching expression:

\begin{lstlisting}
$dna =~ /a/ig 
\end{lstlisting}

This expression is looking for the regular expression \verb|/a/|, that is, the letter \verb|a|. Since it has the \verb|i| modifier, it's a case-insensitive match, which means it matches \verb|a| or \verb|A|. It also has the global modifier, which means match all the \verb|a|'s in the string. (Without the global modifier, it just keeps returning \verb|true| every time through the loop, if there is an "a" in \verb|$dna|.)

Now, this string-matching expression, in the context of a \textit{while} loop, causes the \textit{while} loop to execute its block on every match of the regular expression. So, append the one-statement block:

\begin{lstlisting}
{$a++}
\end{lstlisting}

to increment the counter at each match of the regular expression; in other words, you're counting all the \verb|a|'s. 

One other point should be made about this third version of the program.  You'll notice some of the statements have been changed and shortened this time around. Some variables have shorter names, some statements are lined up on one line, and the \textit{print} statement at the end is more concise. These are just alternative ways of writing. As you program, you'll find yourself experimenting with different approaches: try some on for size.

The way to count bases in this third version is flexible; for instance, it allows you to count non-ACGT characters without specifying them individually. In later chapters, you'll use those \verb|while| loops to good effect. However, there's an even faster way to count bases. You can use the \textit{tr} transliteration function from \autoref{chap:chapter4}; it's faster, which is helpful if you have a lot of DNA to count: 

\begin{lstlisting}
$a = ($dna =~ tr/Aa//);
$c = ($dna =~ tr/Cc//);
$g = ($dna =~ tr/Gg//);
$t = ($dna =~ tr/Tt//);
\end{lstlisting}

The \textit{tr} function returns the count of the specified characters it finds in the string, and if the set of replacement characters is empty, it doesn't actually change the string. So it makes a good character counter. Notice that with \textit{tr}, you have to spell out the upper- and lowercase letters. Also, because \textit{tr} doesn't accept character classes, there's no direct way to count nonbases. You could, however, say: 

\begin{lstlisting}
$basecount = ($dna = ~ tr/ACGTacgt//);
$nonbase = (length $dna) - $basecount)
\end{lstlisting}

The program however, runs faster using \textit{tr} than using the \textit{while} loops of \autoref{exam:example5.7}.

You may find it a bit much to have three (really, four) versions of this base-counting program, especially since much of the code in each version is identical. The only part of the program that really changed was the part that did the counting of the bases. Wouldn't it have been convenient to have a way to just alter the part that counts the bases? In \autoref{chap:chapter6}, you'll see how subroutines allow you to partition your programs in just such a way. 

\section{Exercises}
\textcolor{red}{\textit{Exercise 5.1}}
\begin{adjustwidth}{1cm}{}
Use a loop to write a nonhalting program. The conditional must always evaluate to \verb|true|, every time through the loop. Note that some systems will catch that you're in an infinite loop and will stop the program automatically. You will stop your program differently, depending on which operating system you use. Ctrl-C works on Unix and Linux, a Windows MS-DOS command window, or a MacOS X shell window. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.2}}
\begin{adjustwidth}{1cm}{}
Prompt the user to enter two (short) strings of DNA. Concatenate the two strings of DNA by appending the second to the first using the \verb|.=| assignment operator. Print the two strings as concatenated, and then print the second string lined up over its copy at the end of the concatenated strings. For example, if the input strings are \verb|AAAA| and \verb|TTTT|, print:
\begin{verbatim}
AAAATTTT
    TTTT
\end{verbatim}

\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.3}}
\begin{adjustwidth}{1cm}{}
Write a program that prints all the numbers from 1 to 100. Your program should have much fewer than 100 lines of code! 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.4}}
\begin{adjustwidth}{1cm}{}
Write a program to calculate the reverse complement of a strand of DNA.  Do not use the \textit{s///} or the \textit{tr} functions. Use the \textit{substr} function, and examine each base one at a time in the original while you build up the reverse complement. (Hint: you might find it easier to examine the original right to left, rather than left to right, although either is possible.) 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.5}}
\begin{adjustwidth}{1cm}{}
Write a program to report on the percentage of hydrophobic amino acids in a protein sequence. (To find which amino acids are hydrophobic, consult any introductory text on proteins, molecular biology, or cell biology. You will find information sources in \autoref{chap:chapteraa}.) 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.6}}
\begin{adjustwidth}{1cm}{}
Write a program that checks if two strings given as arguments are
reverse complements of each other. Use the Perl built-in functions
\textit{split}, \textit{pop}, \textit{shift}, and \textit{eq} (\textit{eq} actually an operator). 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.7}}
\begin{adjustwidth}{1cm}{}
Write a program to report how GC-rich some sequence is. (In other words, just give the percentage of G and C in the DNA.)
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.8}}
\begin{adjustwidth}{1cm}{}
Modify \autoref{exam:example5.3} to not only find motifs by regular expressions but to print out the motif that was found. For example, if you search, using regular expressions, for the motif EE.*EE, your program should print EETVKNDEE. You can use the special variable \verb|$&|. After a successful pattern match, this special variable is set to hold the pattern that was matched. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.9}}
\begin{adjustwidth}{1cm}{}
Write a program that switches two bases in a DNA string at specified positions. (Hint: you can use the Perl functions \verb|substr| or \verb|slice|. )
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 5.10}}
\begin{adjustwidth}{1cm}{}
Write a program that writes a temporary file and then deletes it.  The \textit{unlink} function removes a file: just say, for example:
\begin{lstlisting}
unlink "tmpfile";
\end{lstlisting}
but also check to see if \verb|unlink| is successful.
\end{adjustwidth}
