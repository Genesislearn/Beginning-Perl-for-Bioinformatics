\chapter{突变和随机化}
\label{chap:chapter7}
\minitoc

正如每一个生物学家所知道的那样，突变是生物学中的一个基本主题。在细胞中，DNA上的突变时时刻刻都在发生着。绝大多数突变都不影响蛋白质行使功能，是良性的。也有一部分突变确实会影响到蛋白质，导致肿瘤等疾病的发生。突变也会造成后代无法存活，它们在发育过程中就会死亡；有时，突变也能导致进化的改变。许多细胞都有很复杂的机制，来对突变进行修复。

DNA的突变可能来源于辐射、化学制剂、复制错误等原因。我们将使用Perl的随机数生成器，把突变看成随机化事件来对其进行建模。

随机化是一种计算机技术，它经常会在日常使用的密码等程序中突然出现，比如你想生成一个不容易被猜到的密码。但随机化也是算法中的一个重要分支：许多最快的算法都用到了随机化。

使用随机化，可以来模拟和研究DNA突变的机制，以及突变对相关蛋白质生物活性的影响。模拟是研究系统和预测结果的一个强有力的工具，随机化让你可以更好地模拟生物系统中的“有序混沌”。使用计算机程序来模拟突变，这将有助于进化、疾病以及分裂和DNA修复机制等基本细胞过程的研究。细胞发育和功能的计算机模型，现在还在它们的早起阶段，在未来的几年中它将会更加精确且有用，而突变就是这些模型将要囊括在内的一个基本的生物学机制。

从编程技术以及对进化、突变和疾病建模的立场来看，随机化是一个强大的编程技巧，而幸运的是，它非常容易使用。

在本章中，我们将要完成以下内容：

\begin{itemize}
  \item 在数组中随机选取一个索引，在字符串中随机选取一个位置：这些是在DNA（或其他数据）中选取随机位置的基本工具
  \item 使用随机数对突变进行建模，学习如何随机选取DNA中的一个核苷酸并把它突变成其他（随机）的核苷酸
  \item 使用随机数来生成DNA序列数据集，这可以用来研究实际基因组的随机化程度
  \item 重复突变DNA来研究在进化过程中突变随时间累积的影响
\end{itemize}

\section{随机数生成器}
\textit{随机数生成器}是你可以调用的一个子程序。对于大多数实践操作来说，你不需要知道它里面是什么。你从计算机中得到的随机数数值，和真实世界中测量到的随机事件有一定的差别，比如，检测的核衰变事件。有些计算机确实连接着盖革计数器等设备，这样就可以有一个真实随机事件的来源了。但我敢打赌，你的计算机上并没有这样的设备。你有的只是一个代替盖革计数器的算法，它就是随机数生成器。

随机数生成器输出的数字并不是真正随机的，因此它们被叫做\textit{伪随机数}。一个随机数生成器，作为一种算法，是可以被预测的。随机数生成器需要一个种子作为输入，通过改变种子，你可以得到一系列不同的（伪）随机数。

随机数生成器生成的结果给出的是数值的均匀分布，这是随机化最重要的特性之一，并且很大程度上也决定了要根据期望的随机范围的大小来调整算法的使用。

对于随机数生成器来说，另一个要牢记在心的就是你初始化使用的种子本身也应该是随机选择的。如果你每次都使用同样的数字作为种子，那么每次你都将得到同样的“随机数字”序列。（这就并不随机了！）试着选一个具有随机性的种子，比如某些随时间任意改变的计算机事件计算出来的数字。\footnote{即使这样，对于紧要的用途来说，你还是没有跳出如来佛的五指山。除非你小心地选择种子，否则黑客还是可以猜出你是如何选择种子，从而破解你的随机数和密码。本章中使用的生成种子的方法，\verb=time|$$=，是可以被黑客中的“有志青年”所破解的。一个更好的选择是\verb=time() ^ ($$+<<15))=。如果程序安全非常重要的，你就应该好好查阅Perl的文档，以及CPAN中的\textit{Math::Random}和\textit{Math::TrulyRandom}模块。}

在接下来的例子中，我使用一个简单的方法来挑选种子，这对于大多数用途来说都是没有问题的。如果你使用随机数对存在紧要的隐私问题的数据（比如病人的记录）进行加密，你应该进一步参阅Perl中关于Perl提供给随机数生成器的几个高级选项的文档。在本书中，我使用的方法对于大多数情况的用途来说都已经足够了。

\section{使用随机化的一个程序}
\autoref{exam:example7.1}通过一个简单的程序介绍了随机化，它通过随机组合句子的片段来构造一个故事。这并不是一个生物信息学的程序，但是我发现这是学习随机化基础知识的一个有效的方法。你将学习如何从数组中随机选取一个元素，这会在后续突变DNA的程序实例中得到运用。

例子声明了几个包含句子片段的数组，然后把它们随机组合成完整的句子。这是一个微不足道的孩子的游戏，但它演示了一些编程要点。

\textbf{例7-1：使用随机数的儿童游戏}
\lstinputlisting[label=exam:example7.1]{./scripts/example7-1.pl}

下面是\autoref{exam:example7.1}一些典型的输出：

\begin{lstlisting}
Joe and Moe jumped with Rebecca in New York City. Rebecca exploded Groucho in a dream. Mom ran to Harpo over the rainbow. TV giggled with Joe and Moe over the rainbow. Harpo exploded Joe and Moe at the beach. Robin Hood giggled with Harpo at the beach. 

Type "quit" to quit, or press Enter to continue: 

Harpo put hot sauce into the orange juice of TV before dinner. Dad ran to Groucho in a dream. Joe and Moe put hot sauce into the orange juice of TV in New York City. Joe and Moe giggled with Joe and Moe over the rainbow. TV put hot sauce into the orange juice of Mom just for the fun of it. Robin Hood ran to Robin Hood at the beach. 

Type "quit" to quit, or press Enter to continue: quit
\end{lstlisting}

例子的结构非常简单。使用以下语句强制对变量进行声明并开启警告模式：

\begin{lstlisting}
use strict;
use warnings;
\end{lstlisting}

之后，对变量进行声明，并使用值对数组进行初始化。

\subsection{为随机数生成器设置种子} 
接下来，通过调用内置函数\verb|srand|，为随机数生成器设置种子。它需要一个参数，就是前面讨论的随机数生成器的种子。如前所述，为了得到一系列不同的随机数，你必须使用不同的种子。尝试把它改成像这样的语句：

\begin{lstlisting}
srand(100);
\end{lstlisting}

然后，多次运行该程序。每次，你都会得到完全相同的结果。\footnote{最新的随机数生成器会自动更改随机数序列，所以如果该实验不成功，很有可能你在使用一个非常新的随机数生成器。然而，有时你想重复一个随机数序列。注意，如果你像\verb|srand;|这样调用\verb|srand|，更新版本的Perl会自动给你一个好的种子。}你使用的种子：

\begin{lstlisting}
time|$$ 
\end{lstlisting}

每次都会计算返回不同的种子。

\textit{time}返回代表时间的一个数，\textit{\$\$}返回代表运行的Perl程序的ID（每次你运行程序它都会改变）的一个数，而|表示位元的或运算，它把两个数的位组合起来（更多细节请参看Perl文档）。还有选取种子的其他方法，但就让我们使用最流行的这种方法吧。

\subsection{控制流}
程序中的主循环是\verb|do-until|循环。当你想在每次循环中采取任何行动（比如询问用户是否要继续）之前就做一些事情（比如打印出一个小故事）时，这种循环就非常方便了。\verb|do-until|循环首先执行代码块中的语句，然后进行测试，决定它是否应该重复执行代码块中的语句。注意，这和你以前见过的其他类型的循环正好相反，它们是先进行测试后执行代码块。

既然总是向\verb|$story|变量上附加内容，那就需要在每次循环的开始先把它清空。忘记需要在特定的地方把以某种形式递增的变量进行重置，这非常常见，所以在你编程时一定要留意这一点。线索就是不断增长的长字符串或大数字。

\verb|for|循环包含着程序的主要工作。就像你前面看到的那样，这个循环初始化了一个计数器，执行测试，并在代码块的最后对计数器进行递增。

\subsection{造句}
在\autoref{exam:example7.1}中，注意造句用的语句蔓延了数行代码。这有一点点复杂，而这正是整个程序的真正内容，所以附加了一些注释帮助理解它。注意语句进行了精心的格式化，这样它就整洁德排列在了八行中。变量名也是进行选择的，这样这个过程就清晰了许多——你使用一个名词、一个动词、一个名词和一个介词短语进行造句。

然而，即使是这样，在中括号中也有多层嵌套的表达式，它用来指定数组的位置，要理解这些代码你需要进行一点仔细的分析。你会看到，你用以空格分隔的句子片段构造了一个字符串，并用一个句点和空格将其结束。字符串是通过多次使用点字符串连接操作符构建出来的，这些点字符串连接操作符被放在了每一行的开头，这样就使得整个语句的结构清晰了许多。

\subsection{随机选取数组的一个元素}
让我们仔细看看其中一个语句成分选择器吧：

\begin{lstlisting}
$verbs[int(rand(scalar @verbs))] 
\end{lstlisting}

对于这种多层嵌套的括号，要由内向外进行阅读和计算。所以包裹在括号最内层的表达式是：

\begin{lstlisting}
scalar @verbs
\end{lstlisting}

从语句前面的注释中你可以看到，内置函数\textit{scalar}返回数组元素的个数。例子中的数组\verb|@verbs|有七个元素，所以这个表达式返回7。

所以现在你得到的是：

\begin{lstlisting}
$verbs[int(rand(7))]
\end{lstlisting}

而嵌套在最内层的表达式就成了：

\begin{lstlisting}
rand(7)
\end{lstlisting}

代码中语句前帮助性的注释提醒你，这个语句返回一个大于0、小于7的（伪）随机数。这个数是一个\textit{浮点数}（有一个分数的十进制数）。回想一下，一个有七个元素的数组的元素索引是从0到6。

所以现在你得到的类似于：

\begin{lstlisting}
$verbs[int(3.47429)] 
\end{lstlisting}

而你想要对这个表达式进行计算：

\begin{lstlisting}
int(3.47429) 
\end{lstlisting}

\textit{int}函数会丢掉浮点数的小数部分，仅返回它的整数部分，在这个例子中就是3。

所以你来到了最后的一步：

\begin{lstlisting}
$verbs[3]
\end{lstlisting}

这会给你\verb|@verbs|数组的第四个元素，注释中已经给你了足够的提示。

\subsection{格式化}
为了随机选取一个动词，你调用了几个函数：

\begin{description}
  \item[\textcolor{red}{\textit{scalar}}] 确定数组的大小
  \item[\textcolor{red}{\textit{rand}}] 从数组大小决定的范围内选取一个随机数字
  \item[\textcolor{red}{\textit{int}}] 变换浮点数，\textit{rand}返回用于数组元素的整数值
\end{description}

使用嵌套的括号，这些函数调用被组合到了一行中。有时，这会生成难于阅读的代码，对于作者这种辛苦工作得来的成果，某些吹毛求疵的读者可能会直喊头疼，因为它们并不讨人喜欢。你可以使用一些额外的临时变量，试着重写这些行的代码。比如，你可以这样写：

\begin{lstlisting}
$verb_array_size = scalar @verbs;
$random_floating_point = rand ( $verb_array_size );
$random_integer = int $random_floating_point;
$verb = $verbs[$random_integer];
\end{lstlisting}

并且，对其他造句部分也进行类似的改写，最后通过这样的语句你就可以构造出句子了：

\begin{lstlisting}
$sentence = "$subject $verb $object $prepositional_phrase. ";
\end{lstlisting}

这是风格的问题。当你编程时，你总是会进行类似的抉择。\autoref{exam:example7.1}中的排版风格是基于这样的得失权衡：既要把整个任务表达清晰（得），又要避免难于阅读的高度嵌套的函数调用（失）。使用这种排版的另一个原因就是，在后面的程序中，你经常需要从数组中随机选取一个元素，所以你将对这种特殊的函数调用的嵌套习以为常。事实上，如果你将要多次重复同样的事情，你可能会对这样的调用编写一个小的子程序。

就像在大多数代码中一样，易读性是这里最重要的因素。你必须要能够阅读和理解代码，不管是你自己的还是别人的代码，这通常都要比实现其他的动人的目标重要，比如最快的速度、使用最少的内存以及最简练的程序。它并不总是很重要，但通常来说最好先把它写的易读一些，之后如果需要的话再返回去尝试提高其速度（或者其他）。你甚至可以把更加易读的代码作为注释写在那儿，这样阅读代码的人就能够对程序以及你是如何提高程序速度（或者其他）的有一个清晰的理解。

\subsection{计算随机位置的另一种方法}
Perl通常有不同的方法来完成同一个任务。下面就是编写这个随机数选择的另一种方法；它使用的同样的函数调用，但是没有使用小括号：

\begin{lstlisting}
$verbs[int rand scalar @verbs]
\end{lstlisting}

这种函数链在Perl中很常见，其中的每一个函数都需要一个参数。要计算表达式，Perl首先把\verb|@verbs|作为\textit{scalar}的参数，这会返回数组的大小。然后它把得到的值作为\verb|rand|的参数，这会返回一个大于\verb|0|、小于数组大小的浮点数。然后，它把浮点数作为\textit{int}的参数，这会返回小于浮点数的最大整数。换句话说，它计算的数字和用于数组\verb|@verbs|的下标是完全一样的。

为什么Perl允许这样呢？因为这样的计算非常频繁，并且，根据”让计算机干活“的精神，Perl的设计者拉里$\textbullet$沃尔决定让你（以及他自己）免于键入这些括号并使其配对的烦恼。

已经走了这么远了，拉里决定为了简单还要再进一步。你可以省略\textit{scalar}和\textit{int}函数的调用，直接使用：

\begin{lstlisting}
$verbs[rand @verbs]
\end{lstlisting}

这里发生了什么？既然\textit{rand}已经期望一个标量值，它就会把\verb|@verbs|放在一个标量上下文中，也就是简单的返回数组的大小。拉里聪明的设计了数组的下标（当然，它总是整数值），这样当需要下标时，会自动提取浮点数值的整数部分，所以就不需要\textit{int}了。

\section{模拟DNA突变的程序}
\autoref{exam:example7.1}给你了突变DNA时需要的工具。在接下来的例子中，你将照常使用由字母A、C、G和T构成的字符串来表示DNA。你将在字符串中随机选取位置，然后使用\textit{substr}函数来改变DNA。

这次，让我们换一种思路，在给出整个程序之前，首先来编写一些将要使用到的子程序。

\subsection{伪代码设计}
从简单的伪代码开始，这是把DNA中一个随机位置突变成一个随机核苷酸的子程序的设计：

\begin{enumerate}
  \item 选取DNA字符串中一个随机的位置。
  \item 选择一个随机的核苷酸。
  \item 把DNA随机位置替换成随机的核苷酸。
\end{enumerate}

这看上去简洁且直指要害，所以你决定把前两句分别写成子程序。
\subsubsection{在字符串中选取一个随机位置}
怎样才能在一个字符串中随机选取一个位置呢？回忆一下，内置函数\textit{length}返回的就是字符串的长度，此外，字符串中的位置是从\verb|0|到\verb|length-1|进行编号的，就像数组中的位置一样。所以你可以使用和\autoref{exam:example7.1}一样的通用策略，编写成子程序：

\begin{lstlisting}
# randomposition
#
# A subroutine to randomly select a position in a string.
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomposition {

  my($string) = @_;

  # This expression returns a random number between 0 and length-1,
  # which is how the positions in a string are numbered in Perl.

  return int(rand(length($string)));
}
\end{lstlisting}

如果不计算注释的话，\textit{randomposition}实际上是一个简短的函数。这和\autoref{exam:example7.1}中选取一个随机的数组元素的想法是一样的。

当然，如果你亲自编写这段代码，需要进行一点测试，来看看这个子程序能不能工作：

\begin{lstlisting}
#!/usr/bin/perl -w
# Test the randomposition subroutine

my $dna = 'AACCGTTAATGGGCATCGATGCTATGCGAGCT';

srand(time|$$);

for (my $i=0 ; $i < 20 ; ++$i ) {
  print randomposition($dna), " ";
}

print "\n";

exit;

sub randomposition {
  my($string) = @_;
  return int rand length $string;
}
\end{lstlisting}

下面是测试的一些典型输出（你的结果可能会有所不同）：

\begin{lstlisting}
28 26 20 1 29 7 1 27 2 24 8 1 23 7 13 14 2 12 13 27 
\end{lstlisting}

注意\verb|for|循环的新的写法：

\begin{lstlisting}
for (my $i=0 ; $i < 20 ; ++$i ) {
\end{lstlisting}

这里演示了你可以在\verb|for|循环中使用\verb|my|对计数器变量（在这个例子中就是\verb|$i|）进行声明，从而使其进入循环。

\subsubsection{选择一个随机的核苷酸}
接下来，让我们写一个子程序，从四个核苷酸中随机选取一个：

\begin{lstlisting}
# randomnucleotide
#
# A subroutine to randomly select a nucleotide
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomnucleotide {

  my(@nucs) = @_;

  # scalar returns the size of an array. 
  # The elements of the array are numbered 0 to size-1
  return $nucs[rand @nucs];
}
\end{lstlisting}

又一次，这个子程序简洁、悦目。（大多数有用的子程序都是这样的，尽管编写一个简短的子程序并不保证它是有用的。事实上，你将会看到还可以对这个子程序进行一点改进。）

让我们也对它进行以下测试：

\begin{lstlisting}
#!/usr/bin/perl -w
# Test the randomnucleotide subroutine

my @nucleotides = ('A', 'C', 'G', 'T');

srand(time|$$);

for (my $i=0 ; $i < 20 ; ++$i ) {
  print randomnucleotide(@nucleotides), " ";
}

print "\n";

exit;

sub randomnucleotide {
  my(@nucs) = @_;

  return $nucs[rand @nucs];
}
\end{lstlisting}

下面是一些典型的输出（它是随机的，所以理所当然，有很大的可能性你的输出会与此不同）：

\begin{lstlisting}
C A A A A T T T T T A C A C T A A G G G 
\end{lstlisting}

\subsubsection{把随机的核苷酸放到随机的位置}
现在轮到第三个、也是最后一个子程序了，它要进行实际的突变。下面是代码：

\begin{lstlisting}
# mutate
#
# A subroutine to perform a mutation in a string of DNA
#

sub mutate {

  my($dna) = @_;
  my(@nucleotides) = ('A', 'C', 'G', 'T');

  # Pick a random position in the DNA
  my($position) = randomposition($dna);

  # Pick a random nucleotide
  my($newbase) = randomnucleotide(@nucleotides);

  # Insert the random nucleotide into the random position in the DNA.
  # The substr arguments mean the following:
  #  In the string $dna at position $position change 1 character to
  #  the string in $newbase
  substr($dna,$position,1,$newbase);

  return $dna;
}
\end{lstlisting}

这里还是一个简短的程序。当你查看它时，会发现它阅读、理解起来都相对比较容易。通过选取一个随机的位置、随机的核苷酸，并把字符串中那个位置的核苷酸替换成那个随机的核苷酸，你实现了突变。（如果你忘记了\textit{substr}是如何使用的，可以参看\autoref{chap:chapterab}或者其他的Perl文档。如果你像我一样，你可能不得不多次查阅文档，尤其是要确保以正确的顺序使用参数。）

这里使用的声明变量的风格有点不同。以前是在程序的开头声明变量，而这里则是在第一次使用变量的时候才对它们分别进行声明。每种编程风格都各有利弊。把所有变量放在程序的顶部是一种很好的组织形式，而且对阅读代码也有所帮助；而随用随声明在编写程序时看起来则是一种更加自然的方式。选择权在你手中。

此外，注意这个子程序的大部分是如何基于其他的子程序构建起来的，仅仅需要添加一点代码。这使得代码的易读性大大提高。此时，你可能会觉得你已经把任务进行了很好的分解，并且每一个小部分都比较容易完成，而最后它们也能很好的在一起协作。但真是这样的吗？

\subsection{改进设计}
你可能会对自己这么快就编写完程序而颇感自豪，但你注意到了一些事情。你总是要声明讨厌的\verb|@nucleotides|数组变量，然后把它传递给\textit{randomnucleotide}子程序。但你使用这个数组的唯一地方只在\textit{randomnucleotide}子程序的内部。所以为什么不把设计改变一下呢？下面是一个新的尝试：

\begin{lstlisting}
# randomnucleotide
#
# A subroutine to randomly select a nucleotide
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomnucleotide {
  my(@nucs) = ('A', 'C', 'G', 'T');

  # scalar returns the size of an array. 
  # The elements of the array are numbered 0 to size-1
  return $nucs[rand @nucs];
}
\end{lstlisting}

注意这个函数现在没有参数了，要像这样调用它：

\begin{lstlisting}
$randomnucleotide = randomnucleotide( );
\end{lstlisting}

它从一个特定的数据集中选取一个随机的元素。当然，你总是在思考，并且会说“要是有一个从任意数组中随机选取一个元素的子程序该会多方便呀。我可能现在并不需要它，但我敢打赌很快我就会需要这样的子程序！”所以，你定义了两个子程序，而不是一个：

\begin{lstlisting}
# randomnucleotide
#
# A subroutine to randomly select a nucleotide
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomnucleotide {
  my(@nucleotides) = ('A', 'C', 'G', 'T');

  # scalar returns the size of an array. 
  # The elements of the array are numbered 0 to size-1
  return randomelement(@nucleotides);
}

# randomelement
#
# A subroutine to randomly select an element from an array
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub randomelement {

  my(@array) = @_;

  return $array[rand @array];
}
\end{lstlisting}

回头看一下，你会注意到并不需要更改\textit{mutate}子程序，改变的只是\textit{randomnucleotide}的内部构造，而不是它的行为。

\subsection{组合子程序来模拟突变}
现在，所有的材料都到位了，所以你要编写如\autoref{exam:example7.2}一样的主程序，来看看新的子程序是否工作。

\textbf{例7-2：突变DNA}
\lstinputlisting[label=exam:example7.2]{./scripts/example7-2.pl}

下面是\autoref{exam:example7.2}的一些典型的输出：

\begin{lstlisting}
Mutate DNA

Here is the original DNA:

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Here is the mutant DNA:

AAAAAAAAAAAAAAAAAAAAGAAAAAAAAA

Here are 10 more successive mutations:

AAAAAAAAAAAAAAAAAAAAGACAAAAAAA
AAAAAAAAAAAAAAAAAAAAGACAAAAAAA
AAAAAAAAAAAAAAAAAAAAGACAAAAAAA
AAAAAAAAAAAAAACAAAAAGACAAAAAAA
AAAAAAAAAAAAAACAACAAGACAAAAAAA
AAAAAAAAAAAAAACAACAAGACAAAAAAA
AAAAAAAAAGAAAACAACAAGACAAAAAAA
AAAAAATAAGAAAACAACAAGACAAAAAAA
AAAAAATAAGAAAACAACAAGACAAAAAAA
AAAAAATTAGAAAACAACAAGACAAAAAAA
\end{lstlisting}

\autoref{exam:example7.2} was something of a programming challenge, but you end up with the satisfaction of seeing your (simulated) DNA mutate. How about writing a graphical display for this, so that every time a base gets mutated, it makes a little explosion and the color gets highlighted, so you can watch it happening in real-time?

Before you scoff, you should know how important good graphical displays are for the success of most programs. This may be a trivial-sounding graphic, but if you can demonstrate the most common mutations in, for instance, the BRCA breast cancer genes in this way, it might be useful. 

\subsection{A Bug in Your Program?}
To return to the business at hand, you may have noticed something when you looked over the output from \autoref{exam:example7.2}. Look at the first two lines of the "10 more successive mutations." They are exactly the same! Could it be that after patting yourself on the back and telling yourself what a good bit of work you'd done, you've discovered a bug?

How can you track it down? You may want to step through the running of the program with the Perl debugger, which you saw in \autoref{chap:chapter6}. However, this time, you stop and think about your design instead. You're replacing the bases at random positions with randomly chosen bases. Aha!  Sometimes the base at the position you randomly choose is exactly the same as the base you randomly choose to plug into its place! You're replacing a base with itself on occasion!\footnote{How often? In DNA that's all one base, it's happening 1/4 of the time. In DNA that's equally populated with the four bases, it's happening...1/4 of the time!} 

Let's say you decide that behavior is not useful. At each successive mutation, you need to see one base change. How can you alter your code to ensure that? Let's start with some pseudocode for the \textit{mutate} subroutine: 

\begin{lstlisting}
Select a random position in the string of DNA

Repeat:

  Choose a random nucleotide

Until: random nucleotide differs from the nucleotide in the random position

Substitute the random nucleotide into the random position in the DNA
\end{lstlisting}

This seems like something that should work, so you alter the \textit{mutate} subroutine, calling it the \textit{mutate\_better} subroutine: 

\begin{lstlisting}
# mutate_better
#
# Subroutine to perform a mutation in a string of DNA--version 2, in which
#  it is guaranteed that one base will change on each call
#
# WARNING: make sure you call srand to seed the
#  random number generator before you call this function.

sub mutate_better {

  my($dna) = @_;
  my(@nucleotides) = ('A', 'C', 'G', 'T');

  # Pick a random position in the DNA
  my($position) = randomposition($dna);

  # Pick a random nucleotide
  my($newbase);

  do {
    $newbase = randomnucleotide(@nucleotides);

  # Make sure it's different than the nucleotide we're mutating
  }until ( $newbase ne substr($dna, $position,1));

  # Insert the random nucleotide into the random position in the DNA
  # The substr arguments mean the following:
  #  In the string $dna at position $position change 1 character to
  #  the string in $newbase
  substr($dna,$position,1,$newbase);

  return $dna;
}
\end{lstlisting}

When you plug this subroutine in place of \textit{mutate} and run the code, you get the following output:

\begin{lstlisting}
Mutate DNA

Here is the original DNA:

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

Here is the mutant DNA:

AAAAAAAAAAAAATAAAAAAAAAAAAAAAA

Here are 10 more successive mutations:

AAAAAAAAAAAAATAAAAAAAACAAAAAAA
AAAAATAAAAAAATAAAAAAAACAAAAAAA
AAATATAAAAAAATAAAAAAAACAAAAAAA
AAATATAAAAAAATAAAAAAAACAACAAAA
AATTATAAAAAAATAAAAAAAACAACAAAA
AATTATTAAAAAATAAAAAAAACAACAAAA
AATTATTAAAAAATAAAAAAAACAACACAA
AATTATTAAAAAGTAAAAAAAACAACACAA
AATTATTAAAAAGTGAAAAAAACAACACAA
AATTATTAAAAAGTGATAAAAACAACACAA
\end{lstlisting}

which seems to indeed make a real change on every iteration.

Notice one more thing about declaring variables. In this code for \textit{mutate\_better}, if you'd declared \verb|$newbase| within the loop, since the loop is enclosed in a block, the variable \verb|$newbase| would not then be visible outside of that loop. In particular, it wouldn't be available in the \verb|substr| call that does the actual base change for the mutation. So, in \textit{mutate\_better}, you had to declare the variable outside of the loop.  

This is a frequent source of confusion for programmers who like to declare variables on the fly and a powerful argument for getting into the habit of collecting variable definitions together at the top of the program.

Even so, there are often times when you want to hide a variable within a block, because that's the only place where you will use it. Then you may want to do the declaration in the block . (Perhaps at the top of the block, if it's a long one?) 

\section{Generating Random DNA} 
It's often useful to generate random data for test purposes. Random DNA can also be used to study the organization of actual DNA from an organism. In this section, we'll write some programs to generate random DNA sequences.

Such random DNA sequences have proved useful in several ways. For instance, the popular BLAST program (see \autoref{chap:chapter12}) depends on the properties of random DNA for the analytic and empirical results that underpin the sequence similarity scores, statistics that are used to rank the "hits" that BLAST returns to the user.

Let's assume what's needed is a set of random DNA fragments of varying length. Your program will have to specify a maximum and a minimum length, as well as how many fragments to generate. 

\subsection{Bottom-up Versus Top-down}
In \autoref{exam:example7.2}, you wrote the basic subroutines, then a subroutine that called the basic subroutines, and finally the main program. If you ignore the pseudocode, this is an example of \textit{bottom-up design}; start with the building blocks, then assemble them into a larger structure.

Now let's see what it's like to start with the main program, with its subroutine calls, and write the subroutines after you find a need for them. This is called \textit{top-down design}.

\subsection{Subroutines for Generating a Set of Random DNA}
Given our goal of generating random DNA, perhaps what you want is a data-generating subroutine:

\begin{lstlisting}
@random_DNA = make_random_DNA_set( $minimum_length, $maximum_length, $size_of_set );
\end{lstlisting}

This looks okay, but of course, it begs the question of how to actually accomplish the overall task. (That's top-down design for you!) So you need to move down and write pseudocode for the \textit{make\_random\_DNA\_set} subroutine: 

\begin{lstlisting}
repeat $size_of_set times:

  $length = random number between minimum and maximum length

  $dna = make_random_DNA ( $length );

  add $dna to @set
}

return @set
\end{lstlisting}

Now, continuing the top-down design, you need some pseudocode for the \textit{make\_random\_DNA} subroutine:

\begin{lstlisting}
from 1 to $size

  $base = randomnucleotide

  $dna .= $base
}

return $dna
\end{lstlisting}

Don't go any further: you've already got a \textit{randomnucleotide} subroutine from \autoref{exam:example7.2}.

(Are you bothered by the absence of balanced curly braces in the pseudocode? Here, you're relying on indentation and lining up the right braces to indicate the blocks. Since it's pseudocode, anything is allowed as long as it works.) 

\subsection{Turning the Design into Code}
Now that we've got a top-down design, how to proceed with the coding? Let's follow the top-down design, just to see how it works.

\autoref{exam:example7.3} starts with the main program and proceeds, following the order of the top-down design you did in pseudocode, then followed by the subroutines. 

\textbf{Example 7-3. Generate random DNA}
\lstinputlisting[label=exam:example7.3]{./scripts/example7-3.pl}

Here's the output from \autoref{exam:example7.3}:

\begin{lstlisting}
Here is an array of 12 randomly generated DNA sequences
  with lengths between 15 and 30:

TACGCTTGTGTTTTCGGGGGAC
GGGGTGTGGTAAGGCTGTCTCAGATGTGC
TGAACGACAACCTCCTGGACTTTACT
ATCTATGCTTTGCCATGCTAGT
CCGCTCATTCCTCTTCCTCGGC
TGTACCCCTAATACACTTTAGCCGAATTTA
ATAGGTCGGGGCGACAGCGCCGG
GATTGACCTCTGTAA
AAAATCTCTAGGATCGAGC
GTATGTGCTTGGGTAAAT
ATGGAGTTGCGAGGAAGTAGCTGAGT
GGCCCATGACCAGCATCCAGACAGCA
\end{lstlisting}

\section{Analyzing DNA}
In this final example dealing with randomization, you'll collect some statistics on DNA in order to answer the question: on average, what percentage of bases are the same between two random DNA sequences?  Although some simple mathematics can answer the question for you, the point of the program is to show that you now have the necessary programming ability to ask and answer questions about your DNA sequences. (If you were using real DNA, say a collection of some particular gene as it appears in several organisms in slightly different forms, the answer would be somewhat more interesting. You may want to try that later.)

So let's generate a set of random DNA, all the same length, then ask the following question about the set. What's the average percentage of positions that are the same between pairs of DNA sequences in this set?

As usual, let's try to sketch an idea of the program in pseudocode: 

\begin{lstlisting}
Generate a set of random DNA sequences, all the same length

For each pair of DNA sequences

  How many positions in the two sequences are identical as a fraction?

}

Report the mean of the preceding calculations as a percentage
\end{lstlisting}

Clearly, to write this code, you can reuse at least some of the work you've already done. You certainly know how to generate a set of random DNA sequences. Also, although you don't have a subroutine that compares, position by position, the bases in two sequences, you know how to look at the positions in DNA strings. So that subroutine shouldn't be hard to write. In fact, let's write some pseudocode that compares each nucleotide in one sequence with the nucleotide in the same position in another sequence: 

\begin{lstlisting}
assuming DNA1 is the same length as DNA2,

for each position from 1 to length(DNA)

  if the character at that position is the same in DNA_1 and DNA_2

    ++$count
  }
}

return count/length
\end{lstlisting}

The whole problem now seems eminently do-able. You also have to write the code that picks each pair of sequences, collects the results, and finally takes the mean of the results and report it as a percentage.  That can all go into the main program. \autoref{exam:example7.4} gives it a try, all in one shot. 

\textbf{Example 7-4. Calculate average \% identity between pairs of random DNA sequences}
\lstinputlisting[label=exam:example7.4]{./scripts/example7-4.pl}

If the code in \autoref{exam:example7.4} seems somewhat repetitive of code from previous examples, it is. In the interest of presentation, I included the subroutine code in the program. (You'll start using modules in \autoref{chap:chapter8} as a way to avoid this repetition.) 

Here's the output of \autoref{exam:example7.4}:

\begin{lstlisting}
In this run of the experiment, the average number of 
matching positions is 0.24%
\end{lstlisting}

Well, that seems reasonable. You might say, it's obvious: a quarter of the positions match, and there are four bases. But the point isn't to verify elementary probability, it's to show you have enough programming under your belt to write some programs that ask and answer questions about DNA sequences. 

\subsection{Some Notes About the Code}
Notice in the main program that when it calls:

\begin{lstlisting}
@random_DNA = make_random_DNA_set( 10, 10, 10 );
\end{lstlisting}

you don't need to declare and initialize variables such as \verb|$minimum_length|. You can just fill in the actual numbers when you call the subroutine. (However it's often a good idea to put such things in variables declared at the top of the program, where it's easy to find and change them.) Here, you set the maximum and minimum lengths to 10 and ask for 10 sequences.

Let's restate the problem we just solved. You have to compare all pairs of DNA, and for each pair, calculate the percentage of positions that have the same nucleotides. Then, you have to take the mean of these percentages.

Here's the code that accomplishes this in the main program of \autoref{exam:example7.4}:

\begin{lstlisting}
# Iterate through all pairs of sequences
for (my $k = 0 ; $k < scalar @random_DNA - 1 ; ++$k) {
  for (my $i = ($k + 1) ; $i < scalar @random_DNA ; ++$i) {

    # Calculate and save the matching percentage
    $percent = matching_percentage($random_DNA[$k], $random_DNA[$i]);
    push(@percentages, $percent);
  }
}
\end{lstlisting}

To look at each pair, you use a nested loop. A \textit{nested loop} is simply a loop within another loop. These are fairly common in programming but must be handled with care. They may seem a little complex; take some time to see how the nested loop works, because it's common to have to select all combinations of two (or more) elements from a set.

The nested loop involves looking at $(n * (n-1)) / 2$ pairs of sequences, which is a square function of the size of the data set. This can get very big! Try gradually increasing the size of the data set and rerunning the program, and you'll see your compute time increase, and more than gradually.

See how the looping works? First sequence 0 (indexed by \verb|$K|) is paired with sequences 1,2,3,...,9, in turn (indexed by \verb|$i|). Then sequence 1 is paired with 2,3,...,9, etc. Finally, 8 is paired with 9. (Recall that array elements are numbered starting at 0, so the last element of an array with 10 elements is numbered 9. Also recall that scalar \verb|@random_DNA| returns the number of elements in the array.)

You might find it a worthwhile exercise to let the number of sequences be some small value, say 3 or 4, and think through (paper and pencil in hand) how the nested loops and the variables \verb|$k| and \verb|$i| evolve during the running of the program. Or you can use the Perl debugger to watch how it happens. 

\section{Exercises}
\textcolor{red}{\textit{Exercise 7.1}}
\begin{adjustwidth}{1cm}{}
Write a program that asks you to pick an amino acid and then keeps (randomly) guessing which amino acid you picked. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.2}}
\begin{adjustwidth}{1cm}{}
Write a program that picks one of the four nucleotides and then keeps prompting until you correctly guess the nucleotide it picked.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.3}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to randomly shuffle the elements of an array. The subroutine should take an array as an argument and return an array with the same elements but shuffled in a random order. Each element of the original array should appear exactly once in the output array, just like shuffling a deck of cards. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.4}}
\begin{adjustwidth}{1cm}{}
Write a program to mutate protein sequence, similar to the code in \autoref{exam:example7.2} that mutates DNA. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.5}}
\begin{adjustwidth}{1cm}{}
Write a subroutine that, given a codon (a fragment of DNA of length 3), returns a random mutation in the codon. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.6}}
\begin{adjustwidth}{1cm}{}
Some versions of Perl automatically seed the random number generator, making it superfluous to call \verb|srand| for that purpose before using \verb|rand| to generate random numbers. Experiment to see if your implementation of \verb|rand| calls \verb|srand| automatically, or if you have to explicitly call \verb|srand| yourself, as you have seen done in the code in this chapter. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.7}}
\begin{adjustwidth}{1cm}{}
Sometimes not all choices are will be picked in a random selection. Write a subroutine that randomly returns a nucleotide, in which the probability of each nucleotide can be specified. Pass the subroutine four numbers as arguments, representing the probabilities of each nucleotide; if each probability is 0.25, the subroutine is equally likely to pick each nucleotide. As error checking, have the subroutine ensure that the sum of the four probabilities is 1.

\textit{Hint:} one way to accomplish this is to divide the range between 0 and 1 into four intervals with lengths corresponding to the probability of the respective nucleotides. Then, simply pick a random number between 0 and 1, see in which interval it falls, and return the corresponding nucleotide.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 7.8}}
\begin{adjustwidth}{1cm}{}
\textit{This is a more difficult exercise.} The \textit{study} function in Perl may speed up searches for motifs in DNA or protein. Read the Perl documentation on this function. Its use is simple: given some sequence data in a variable \verb|$sequence|, type:

\begin{lstlisting}
study $sequence;
\end{lstlisting}

before doing the searches. Do you think \textit{study} will speed up searches in DNA or protein, based on what you've read about it in the documentation?
\end{adjustwidth}

\textit{For lots of extra credit!} Now read the Perl documentation on the standard module Benchmark. (Type \verb|perldoc Benchmark|, or visit the Perl home page at \href{http://www.perl.com}{http://www.perl.com}.) See if your guess is right by writing a program that benchmarks motif searches of DNA and of protein, with and without \textit{study}. 
