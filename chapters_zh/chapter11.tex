\chapter{PDB}
\label{chap:chapter11}
\minitoc

人类基因组计划（Human Genome
Project）在解码人类基因DNA序列上的成功，已经俘获了公众的想象力，但另一个项目却没有获得如此的关注度，它也会得到同样具有变革性的结果。这个项目是进行国际性的合作努力，使用高通量分析技术，在基因组范围水平上确定大量蛋白质的3D结构。国际性的合作是结构基因组学这个新兴领域的基础。

最近技术上的突破，促进了确定蛋白质结构这场竞赛的加速。存储所有这些数据的商店就是\textit{PDB（Protein Data Bank）}，可以在网站 \href{http://www.rcsb.org/pdb/}{http://www.rcsb.org/pdb/} 上找到它。

找到氨基酸序列也就是一级序列，仅仅是蛋白质研究的开始。蛋白质会进行局部折叠，折叠成$\alpha$-螺旋、$\beta$-折叠和$\beta$-转角之类的二级结构。两个或三个临近的二级结构可能会组合成叫做“基元”或者“超二级结构”的常见折叠花式，比如$\beta$-片层或者$\alpha$-$\alpha$螺旋组合单元。这些建筑模块会进一步折叠成蛋白质的3D或者三级结构。最后，一个或者多个三级结构可能作为亚单元组合成酶或者病毒的四级结构。

在不知道一个蛋白质是如何折叠成一个3D结构之前，你很难直到这个蛋白质到底有什么功能，以及它是如何发挥功能的。即使你知道这个蛋白质在疾病中发挥作用，要想找到一个可能的治疗方案，通常还是需要知道它的三级结构。了解蛋白质的三级结构和它的\textit{活性位点}（它可能会包含那些在一级结构上相距甚远、但是在蛋白质折叠后却紧邻在一起的氨基酸），对于对于筛选新的药物靶点是至关重要的。

现在，包括人类在内的不少生物的基本遗传信息已经被解码了，接下来生物学家面临的主要挑战就是尽可能多的去了解这些基因编码的蛋白质，以及它们之间的相互作用。

事实上，现代生物学主要的问题之一就是蛋白质的一级氨基酸序列是如何决定它最终的3D结构的。如果能够找到一种计算方法，可以从蛋白质的氨基酸序列可靠地预测出它的折叠，那么生物学和医学的作用将是意义深远的。

在本章中，你将学习PDB文件的基础，以及如何从中解析出需要的信息。你将会探索更加有趣的Perl技术，寻找大量的文件并进行循环处理，以及在Perl程序中控制其他的生物信息学程序。本章末尾的练习题，在此处介绍的基本知识的基础上，让你挑战获取PDB数据的更多信息。

\section{PDB概述}
大分子（包括蛋白质、肽、病毒、蛋白质和核酸的复合物、核酸、以及碳水化合物）3D结构信息的主要资源就是PDB。并且，它的格式实际上就是交换结构信息的标准格式。PDB中的大多数结构都是通过X射线衍射（X-ray ）diffraction和核磁共振（NMR，nuclear magnetic resonance）实验确定的。

1971年PDB诞生之初，只有七个蛋白质，随后迅速增长到了20,000个结构。随着结构基因组学中国际性合作的增加，PDB仍然在延续它快速增长的态势。在短短几年的时间内，已知结构的数目将会接近100,000。

PDB文件和GenBank记录相似，都是人类可读的ASCII平面文件。文件中的文本符合特定的格式，所以可以编写计算机程序从中提取信息。和GenBank在一个“库”文件中保存许多记录不一样，PDB对于每一个结构都用一个文件来存储。

经常处理PDB文件的生物信息学家，会抱怨PDB格式在一致性上存在着严重的问题。比如，为了满足新知识的需要，随着字段和数据格式的不断变革，有些旧的文件就过时了。现在保持PDB数据一致性的工作正在进行中，直到这些工作完成、开发出一个新的数据格式之前，现有数据格式的不一致性仍然是程序员必须面对的一项挑战。如果你对PDB文件进行大量的编程，你会发现数据中有许多的不一致甚至错误，尤其是那些老的文件中。另外，许多能够成功解析新文件的工具，在老的文件上就不一定好用了。

随着你逐渐称为一个经验更加丰富的程序员，你面对的PDB这样那样的问题就显得更加重要的。比如，随着PDB的发展，你编写的和它进行交互的代码也要不断改进。你必须要时刻关注世界的变化，注意维护你的代码，让它与时俱进。随着数据库间链接得到了更好的支持，你的代码应该充分利用这些链接提供的新的机遇。数据存储的新标准正在建立中，你的代码也要更新把它们包含进去。

PDB网站上包含了大量关于如果下载搜有文件的信息。它们也以便于获取的免费的CD集进行发布，这对于那些没有高速网路连接的人来说是一个巨大的便利。

\section{文件和文件夹}
PDB以目录中的文件形式进行发布。每一个蛋白质结构都有自己单独的文件。PDB包含大量的数据，所以要处理它是一种挑战。在本节中，你将学习处理组织在目录和子目录中的大量文件。

你会发现，常常需要编写程序来操作大量的文件。比如，你可能会把多次的测序放在一个目录中，根据测序上机的日期分成子目录，把测序仪产生的数据放在对应日期的子目录中。在短短几年之后，你可能就会有相当数量的文件。

然后，有一天，你发现了一个新的DNA序列，看起来参与细胞分裂。你进行了一个BLAST搜索（参看\autoref{chap:chapter12}），但是没有找到对于新DNA的显著结果。这个时候，你想直到在以前的测序中是不是看到过这个DNA。\footnote{你可能会把所有的测序结构保存为一个大的BLAST库进行比较；可以使用本节介绍的技术构建这样的一个BLAST库。}你需要做的就是，针对多种多样的测序子目录中的成百上千的文件，运行比对的子程序。但这可能会重复耗费好几天，对于坐在计算机屏幕前的你来说这绝对是无聊透顶的工作。

你可以编写一个程序，在很短时间内完成这个工作！然后你需要做的就是回到座位上，检查一下结果中你的程序有没有找到显著的匹配。然而要编写这样的程序，你需要知道如何在Perl中操作所有的文件和文件夹。接下来的小节将向你演示如何去做。

\subsection{打开目录}
文件系统以\textit{树状}结构进行组织。这个比喻是非常贴切的。从树的任何地方开始，你可以沿着树干，得到源于从你开始之处的任何树叶。如果你从树根开始，你可以得到所有的树叶。类似的，在文件系统中，如果你从一个特定的目录开始，你可以得到源于你开始之处的子目录中的所有文件。如果你从文件系统的根（非常奇怪，它也被叫做“顶”）开始，你可以得到所有的文件。

在打开、读取、写入和关闭文件方面，你已经练习了很多。我将演示一个简单的方法，让你可以打开一个文件夹（也叫做目录），获取这个文件夹中所有文件的文件名。在那之后，你将看到如何从一个特定的地方开始，获取所有目录和子目录中的所有文件的名字。

从一些伪代码开始，让我们看一下列出文件夹中所有文件的Perl的方式：

\begin{lstlisting}
open folder

read contents of folder (files and subfolders)

print their names
\end{lstlisting}

\autoref{exam:example11.1}演示了真实的Perl代码。

%\textbf{例11-1：列出文件夹（或目录）的内容}
\lstinputlisting[label=exam:example11.1,caption={例11-1：列出文件夹（或目录）的内容}]{./scripts/example11-1.pl}

因为你在一个包含PDB文件的文件夹中运行这个程序，所以你将会看到：

\begin{lstlisting}
.
..
3c
44
pdb1a4o.ent
\end{lstlisting}

如果你想列出当前目录中的文件，你可以把代表当前目录的“.”这个特殊名字赋值给目录名，就像这样：

\begin{lstlisting}
my $folder = '.';
\end{lstlisting}

在Unix或者Linux系统中，特殊文件“.”和“..”分别代表当前目录和父目录。它们并不是“真实”的文件，至少不是你想读取的文件。使用优秀的、了不起的\textit{grep}函数，你可以避免把它们罗列出来。\textit{grep}允许你根据测试选择数组中的元素，比如一个正则表达式。下面演示的是如何把数组中的“.”和“.”过滤掉：

\begin{lstlisting}
@files = grep( !/^\.\.?$/, @files );
\end{lstlisting}

因为感叹号这个取反操作符，\textit{grep}选择了不匹配正则表达式的所有行。正则表达式\verb|/^\.\.?$/|寻找这样的行，它以点号\verb|.|（因为点号是一个元字符，所以用反斜杠进行了转义）起始（一行的开头用\verb|^|元字符表示），后面跟着0个或者1个点号\verb|\.?|（\verb|?|匹配前面的元素0次或者1次），再后面就没有其他任何东西了（\verb|$|元字符表示字符串的结尾）。

实际上，当读取一个目录的时候，这非常常用，所以通常把它们组合到一步中：

\begin{lstlisting}
@files = grep (!/^\.\.?$/, readdir(FOLDER));
\end{lstlisting}

好了，现在所有的文件都罗列出来了。但是稍等：如果这些文件不是常规文件而是子文件夹呢？你可以使用便捷的文件测试操作符来检测每一个文件名，这样就可以打开每一个子文件夹把其中的文件罗列出来了。首先是一些伪代码：

\begin{lstlisting}
open folder

for each item in the folder

    if it's a file
        print its name

    else if it's a folder
        open the folder
        print the names of the contents of the folder
    }
}
\end{lstlisting}

\autoref{exam:example11.2}演示了这个程序。

%\textbf{例11-2：列出文件夹及其子文件夹的内容}
\lstinputlisting[label=exam:example11.2,caption={例11-2：列出文件夹及其子文件夹的内容}]{./scripts/example11-2.pl}

下面是\autoref{exam:example11.2}的输出：

\begin{lstlisting}
pdb/3c/pdb43c9.ent
pdb/3c/pdb43ca.ent
pdb/44/pdb144d.ent
pdb/44/pdb144l.ent
pdb/44/pdb244d.ent
pdb/44/pdb244l.ent
pdb/44/pdb344d.ent
pdb/44/pdb444d.ent
pdb/pdb1a4o.ent
\end{lstlisting}

注意，代码中\verb|$file|和\verb|@files|这样的变量名是如何被重用的，方法就是在内层的代码块中使用\verb|my|限定词汇作用域。如果程序的整体结构不是这么简短，这样阅读起来就会相当困难。当程序中出现\verb|$file|的时候，它是表示此处的\verb|$file|还是彼处的\verb|$file|？这个代码就是一个引起麻烦的反面例子。它确实可以工作，但尽管它很简短，任然非常难于阅读。

事实上，\autoref{exam:example11.2}存在一个深层次的问题，它的设计并不好。通过对\autoref{exam:example11.1}进行扩充，它现在可以罗列出子目录了。但是如果还有更深层次的子目录呢？

\subsection{递归}
如果你有一个子程序，可以罗列出目录的内容，并且可以通过递归调用自己来罗列出它找到的任何子目录的内容，那么你就可以在顶层目录调用它，而它最终则会罗列出所有的文件。

让我们编写另一个程序来完成这个工作吧。一个\textit{递归}子程序被简单的定义为可以调用自己的子程序。下面是伪代码和代码（\autoref{exam:example11.3}，之后是对递归工作原理的讨论：

\begin{lstlisting}
subroutine list_recursively

    open folder

    for each item in the folder

        if it's a file
            print its name

        else if it's a folder
            list_recursively
    }
}
\end{lstlisting}

%\textbf{例11-3：一个罗列文件系统的递归子程序}
\lstinputlisting[label=exam:example11.3,caption={例11-3：一个罗列文件系统的递归子程序}]{./scripts/example11-3.pl}

下面是\autoref{exam:example11.3}的输出（注意它和\autoref{exam:example11.2}的输出是完全一样的）：

\begin{lstlisting}
pdb/3c/pdb43c9.ent
pdb/3c/pdb43ca.ent
pdb/44/pdb144d.ent
pdb/44/pdb144l.ent
pdb/44/pdb244d.ent
pdb/44/pdb244l.ent
pdb/44/pdb344d.ent
pdb/44/pdb444d.ent
pdb/pdb1a4o.ent
\end{lstlisting}

看一下\autoref{exam:example11.3}的代码，把它和\autoref{exam:example11.2}比较以下。如你所见，程序大体上是一样的。\autoref{exam:example11.2}整体就是一个主程序；而\autoref{exam:example11.3}拥有和它几乎完全一样的代码，只不过这些代码被打包成了一个子程序，然后在一个简短的主程序中调用这个子程序。\autoref{exam:example11.3}的主程序只是简单的调用了一个递归函数，给它一个目录名（我计算机中存在的一个目录；当你尝试在自己的计算机中运行这个程序的时候，你可能需要修改目录名）即可。下面就是这个调用

\begin{lstlisting}
list_recursively('pdb');
\end{lstlisting}

我对此有些失望，不知道你是不是也有这种感觉。这看上去和其他的子程序调用并没有什么区别。显然，递归必须在子程序内部进行定义。这出现在\textit{list\_recursively}子程序的最末尾，当程序发现（使用\verb|-d|文件测试操作符）目录列出的一个内容本身就是一个目录时，就会进行递归处理，和\autoref{exam:example11.2}中的代码相比这有着显著的不同。在这一点上，\autoref{exam:example11.2}有再一次寻找常规文件和目录的代码，
而\autoref{exam:example11.3}中的这个子程序通过简单的调用一个子程序就实现了这一点，这里的这个子程序就是它本身，叫做\textit{list\_recursively}的子程序：

\begin{lstlisting}
list_recursively("$directory/$file");
\end{lstlisting}

这就是递归。

正如你在此处所见，有很多时候，数据——比如文件系统的层次结构——正好能够匹配递归程序的这种能力。在子程序的末尾进行递归调用，这意味着它是一个特殊类型的递归，叫做\textit{尾递归（tail
recursion）}。尽管递归会很慢，归因于它创建的所有子程序调用，关于尾递归的好消息就是许多编译器会对代码进行优化，让它运行更快一些。使用递归可以得到简洁、易于理解的程序。（尽管Perl并不对它进行优化，现在Perl6的计划中包含对尾递归进行优化的支持。）

\subsection{处理大量文件}
\label{sect:section11.2.3}
Perl有可以处理各种任务的模块。有些模块是作为标准和Perl一块发布的，更多的则可以从CPAN（\href{http://www.CPAN.org/}{http://www.CPAN.org/}）或者其他地方下载安装。

上一小节的\autoref{exam:example11.3}演示了如何定位一个给定目录中的所有文件和目录。在所有近期版本的Perl中都有一个叫做\textit{File::Find}的标准模块。你可以在你的手册页中找到它：比如，在Unix或者Linux上，你可以使用命令\verb|perldoc File::Find|。这个模块让处理一个给定目录的所有文件变得简单且高效，它可以进行你指定的各种操作。

\autoref{exam:example11.4}使用了\textit{File::Find}。对于这个有用的模块的更多例子，可以参考它的文档。这个实例演示的功能和\autoref{exam:example11.3}是完全一样的，只不过现在使用了\textit{File::Find}。它只是简单的把文件和目录罗列出来。注意，你会发现，如果你找到一个好的模块，你只需要编写很少的代码即可，所以开始使用模块吧！

%\textbf{例11-4：演示File::Find}
\lstinputlisting[label=exam:example11.4,caption={例11-4：演示File::Find}]{./scripts/example11-4.pl}

注意，通过在\textit{my\_sub}子程序前面使用反斜杠字符，把指针传递给了它。就像在\autoref{chap:chapter6}中提到的那样，你还需要在它名字的前面加上\verb|&|字符。

\textit{find}的调用也可以这样实现：

\begin{lstlisting}
find sub { -f and (print $File\dotsFind\dotsname, "\n")  }, ('pdb');
\end{lstlisting}

它把一个匿名子程序放在了\textit{my\_sub}子程序指针出现的地方，对于这种简短的子程序来说，这也是一种比较简洁的写法。

下面是它的输出：

\begin{lstlisting}
pdb/pdb1a4o.ent
pdb/44/pdb144d.ent
pdb/44/pdb144l.ent
pdb/44/pdb244d.ent
pdb/44/pdb244l.ent
pdb/44/pdb344d.ent
pdb/44/pdb444d.ent
pdb/3c/pdb43c9.ent
pdb/3c/pdb43ca.ent
\end{lstlisting}

作为使用Perl处理文件的最后一个例子，下面是一个在命令行中使用的单行程序，它的作用和上面这个程序是完全一样的：

\begin{lstlisting}
perl -e 'use File::Find;find sub{-f and (print $File::Find::name,"\n")},("pdb")'
\end{lstlisting}

尽管它不可避免的让人困惑，但对于那些崇尚简洁的人来说，这简直太酷了！此外还要注意，对于Unix操作系统的用户来说，\verb|ls -R pdb|和\verb|find pdb -print|也可以完成同样的工作，而且键入的字符更少。

之所以使用你定义的一个子程序，是因为它可以让你对找到的文件进行任意的测试，然后对这些文件进行任意的处理。模块化则是另外一个例子：\textit{File::Find}模块可以轻而易举地对一个文件结构中的所有文件和目录进行递归，让你随意处理找到的文件和目录。

\section{PDB文件}
下面是一个真实PDB文件的一部分：

\begin{lstlisting}
HEADER    SUGAR BINDING PROTEIN                   03-MAR-99   1C1F              
TITLE     LIGAND-FREE CONGERIN I                                                
COMPND    MOL_ID: 1;                                                            
COMPND   2 MOLECULE: CONGERIN I;                                                
COMPND   3 CHAIN: A;                                                            
COMPND   4 FRAGMENT: CARBOHYDRATE-RECOGNITION-DOMAIN;                           
COMPND   5 BIOLOGICAL_UNIT: HOMODIMER                                           
SOURCE    MOL_ID: 1;                                                            
SOURCE   2 ORGANISM_SCIENTIFIC: CONGER MYRIASTER;                               
SOURCE   3 ORGANISM_COMMON: CONGER EEL;                                         
SOURCE   4 TISSUE: SKIN MUCUS;                                                  
SOURCE   5 SECRETION: NON-CLASSICAL                                             
KEYWDS    GALECTIN, LECTIN, BETA-GALACTOSE-BINDING, SUGAR BINDING               
KEYWDS   2 PROTEIN                                                              
EXPDTA    X-RAY DIFFRACTION                                                     
AUTHOR    T.SHIRAI,C.MITSUYAMA,Y.NIWA,Y.MATSUI,H.HOTTA,T.YAMANE,                
AUTHOR   2 H.KAMIYA,C.ISHII,T.OGAWA,K.MURAMOTO                                  
REVDAT   2   14-OCT-99 1C1F    1       SEQADV HEADER                            
REVDAT   1   08-OCT-99 1C1F    0                                                
JRNL        AUTH   T.SHIRAI,C.MITSUYAMA,Y.NIWA,Y.MATSUI,H.HOTTA,                
JRNL        AUTH 2 T.YAMANE,H.KAMIYA,C.ISHII,T.OGAWA,K.MURAMOTO                 
JRNL        TITL   HIGH-RESOLUTION STRUCTURE OF CONGER EEL GALECTIN,            
JRNL        TITL 2 CONGERIN I, IN LACTOSE- LIGANDED AND LIGAND-FREE             
JRNL        TITL 3 FORMS: EMERGENCE OF A NEW STRUCTURE CLASS BY                 
JRNL        TITL 4 ACCELERATED EVOLUTION                                        
JRNL        REF    STRUCTURE (LONDON)            V.   7  1223 1999              
JRNL        REFN   ASTM STRUE6  UK ISSN 0969-2126                 2005          
REMARK   1                                                                      
REMARK   2                                                                      
REMARK   2 RESOLUTION. 1.6 ANGSTROMS.                                           
REMARK   3                                                                      
REMARK   3 REFINEMENT.                                                          
REMARK   3   PROGRAM     : X-PLOR 3.1                                           
REMARK   3   AUTHORS     : BRUNGER                                              
REMARK   3                                                                      
REMARK   3  DATA USED IN REFINEMENT.                                            
REMARK   3   RESOLUTION RANGE HIGH (ANGSTROMS) : 1.60                           
REMARK   3   RESOLUTION RANGE LOW  (ANGSTROMS) : 8.00                           
REMARK   3   DATA CUTOFF            (SIGMA(F)) : 3.000                          
REMARK   3   DATA CUTOFF HIGH         (ABS(F)) : NULL                           
REMARK   3   DATA CUTOFF LOW          (ABS(F)) : NULL                           
REMARK   3   COMPLETENESS (WORKING+TEST)   (%) : 85.0                           
REMARK   3   NUMBER OF REFLECTIONS             : 17099                          
REMARK   3                                                                      
REMARK   3                                                                      
REMARK   3  FIT TO DATA USED IN REFINEMENT.                                     
REMARK   3   CROSS-VALIDATION METHOD          : THROUGHOUT                      
REMARK   3   FREE R VALUE TEST SET SELECTION  : RANDOM                          
REMARK   3   R VALUE            (WORKING SET) : 0.201                           
REMARK   3   FREE R VALUE                     : 0.247                           
REMARK   3   FREE R VALUE TEST SET SIZE   (%) : 5.000                           
REMARK   3   FREE R VALUE TEST SET COUNT      : 855                             
REMARK   3   ESTIMATED ERROR OF FREE R VALUE  : NULL                            
REMARK   3                                                                      
... 

(file truncated here)


REMARK   4                                                                      
REMARK   4 1C1F COMPLIES WITH FORMAT V. 2.3, 09-JULY-1998                       
REMARK   7                                                                      
REMARK   7 >>> WARNING: CHECK REMARK 999 CAREFULLY                              
REMARK   8                                                                      
REMARK   8 SIDE-CHAINS OF SER123 AND LEU124 ARE MODELED AS ALTERNATIVE          
REMARK   8 CONFORMERS.                                                          
REMARK   9                                                                      
REMARK   9 SER1 IS ACETYLATED.                                                  
REMARK  10                                                                      
REMARK  10 TER                                                                  
REMARK  10  SER: THE N-TERMINAL RESIDUE WAS NOT OBSERVED                        
REMARK 100                                                                      
REMARK 100 THIS ENTRY HAS BEEN PROCESSED BY RCSB ON 07-MAR-1999.                
REMARK 100 THE RCSB ID CODE IS RCSB000566.                                      
REMARK 200                                                                      
REMARK 200 EXPERIMENTAL DETAILS                                                 
REMARK 200  EXPERIMENT TYPE                : X-RAY DIFFRACTION                  
REMARK 200  DATE OF DATA COLLECTION        : NULL                               
REMARK 200  TEMPERATURE           (KELVIN) : 291.0                              
REMARK 200  PH                             : 9.00                               
REMARK 200  NUMBER OF CRYSTALS USED        : 1                                  
REMARK 200                                                                      
REMARK 200  SYNCHROTRON              (Y/N) : Y                                  
REMARK 200  RADIATION SOURCE               : PHOTON FACTORY                     
REMARK 200  BEAMLINE                       : BL6A                               
REMARK 200  X-RAY GENERATOR MODEL          : NULL                               
REMARK 200  MONOCHROMATIC OR LAUE    (M/L) : M                                  
REMARK 200  WAVELENGTH OR RANGE        (A) : 1.00                               
REMARK 200  MONOCHROMATOR                  : NULL                               
REMARK 200  OPTICS                         : NULL                               
REMARK 200                                                                      
... 

(file truncated here)


REMARK 500                                                                      
REMARK 500 GEOMETRY AND STEREOCHEMISTRY                                         
REMARK 500 SUBTOPIC: COVALENT BOND ANGLES                                       
REMARK 500                                                                      
REMARK 500 THE STEREOCHEMICAL PARAMETERS OF THE FOLLOWING RESIDUES              
REMARK 500 HAVE VALUES WHICH DEVIATE FROM EXPECTED VALUES BY MORE               
REMARK 500 THAN 4*RMSD (M=MODEL NUMBER; RES=RESIDUE NAME; C=CHAIN               
REMARK 500 IDENTIFIER; SSEQ=SEQUENCE NUMBER; I=INSERTION CODE).                 
REMARK 500                                                                      
REMARK 500 STANDARD TABLE:                                                      
REMARK 500 FORMAT: (10X,I3,1X,A3,1X,A1,I4,A1,3(1X,A4,2X),12X,F5.1)              
REMARK 500                                                                      
REMARK 500 EXPECTED VALUES: ENGH AND HUBER, 1991                                
REMARK 500                                                                      
REMARK 500  M RES CSSEQI ATM1   ATM2   ATM3                                     
REMARK 500    HIS A  44   N   -  CA  -  C   ANGL. DEV. =-10.3 DEGREES           
REMARK 500    LEU A 132   CA  -  CB  -  CG  ANGL. DEV. = 12.5 DEGREES           
REMARK 700                                                                      
REMARK 700 SHEET                                                                
REMARK 700 DETERMINATION METHOD: AUTHOR-DETERMINED                              
REMARK 999                                                                      
REMARK 999 SEQUENCE                                                             
REMARK 999 LEU A 135 IS NOT PRESENT IN SEQUENCE DATABASE                        
REMARK 999                                                                      
DBREF  1C1F A    1   136  SWS    P26788   LEG_CONMY        1    135             
SEQADV 1C1F LEU A  135  SWS  P26788              SEE REMARK 999                 
SEQRES   1 A  136  SER GLY GLY LEU GLN VAL LYS ASN PHE ASP PHE THR VAL          
SEQRES   2 A  136  GLY LYS PHE LEU THR VAL GLY GLY PHE ILE ASN ASN SER          
SEQRES   3 A  136  PRO GLN ARG PHE SER VAL ASN VAL GLY GLU SER MET ASN          
SEQRES   4 A  136  SER LEU SER LEU HIS LEU ASP HIS ARG PHE ASN TYR GLY          
SEQRES   5 A  136  ALA ASP GLN ASN THR ILE VAL MET ASN SER THR LEU LYS          
SEQRES   6 A  136  GLY ASP ASN GLY TRP GLU THR GLU GLN ARG SER THR ASN          
SEQRES   7 A  136  PHE THR LEU SER ALA GLY GLN TYR PHE GLU ILE THR LEU          
SEQRES   8 A  136  SER TYR ASP ILE ASN LYS PHE TYR ILE ASP ILE LEU ASP          
SEQRES   9 A  136  GLY PRO ASN LEU GLU PHE PRO ASN ARG TYR SER LYS GLU          
SEQRES  10 A  136  PHE LEU PRO PHE LEU SER LEU ALA GLY ASP ALA ARG LEU          
SEQRES  11 A  136  THR LEU VAL LYS LEU GLU                                      
FORMUL   2  HOH   *81(H2 O1)                                                    
HELIX    1   1 GLY A   66  ASN A   68  5                                   3    
SHEET    1  S1 1 GLY A   3  VAL A   6  0                                        
SHEET    1  S2 1 PHE A 121  GLY A 126  0                                        
SHEET    1  S3 1 ARG A  29  GLY A  35  0                                        
SHEET    1  S4 1 LEU A  41  ASN A  50  0                                        
SHEET    1  S5 1 GLN A  55  THR A  63  0                                        
SHEET    1  S6 1 GLN A  74  SER A  76  0                                        
SHEET    1  F1 1 ALA A 128  GLU A 136  0                                        
SHEET    1  F2 1 PHE A  16  ILE A  23  0                                        
SHEET    1  F3 1 TYR A  86  TYR A  93  0                                        
SHEET    1  F4 1 LYS A  97  ILE A 102  0                                        
SHEET    1  F5 1 ASN A 107  PRO A 111  0                                        
CRYST1   94.340   36.920   40.540  90.00  90.00  90.00 P 21 21 2     4          
ORIGX1      1.000000  0.000000  0.000000        0.00000                         
ORIGX2      0.000000  1.000000  0.000000        0.00000                         
ORIGX3      0.000000  0.000000  1.000000        0.00000                         
SCALE1      0.010600  0.000000  0.000000        0.00000                         
SCALE2      0.000000  0.027085  0.000000        0.00000                         
SCALE3      0.000000  0.000000  0.024667        0.00000                         
ATOM      1  N   GLY A   2       1.888  -8.251  -2.511  1.00 36.63           N  
ATOM      2  CA  GLY A   2       2.571  -8.428  -1.248  1.00 33.02           C  
ATOM      3  C   GLY A   2       2.586  -7.069  -0.589  1.00 30.43           C  
ATOM      4  O   GLY A   2       2.833  -6.107  -1.311  1.00 33.27           O  
ATOM      5  N   GLY A   3       2.302  -6.984   0.693  1.00 24.67           N  
ATOM      6  CA  GLY A   3       2.176  -5.723   1.348  1.00 18.88           C  
ATOM      7  C   GLY A   3       0.700  -5.426   1.526  1.00 16.58           C  
ATOM      8  O   GLY A   3      -0.187  -6.142   1.010  1.00 12.47           O  
ATOM      9  N   LEU A   4       0.494  -4.400   2.328  1.00 15.00           N  
... 

(file truncated here)


ATOM   1078  CG  GLU A 136      -0.873   9.368  16.046  1.00 38.96           C  
ATOM   1079  CD  GLU A 136      -0.399   9.054  17.456  1.00 44.66           C  
ATOM   1080  OE1 GLU A 136       0.789   8.749  17.641  1.00 47.97           O  
ATOM   1081  OE2 GLU A 136      -1.236   9.099  18.361  1.00 47.75           O  
ATOM   1082  OXT GLU A 136       0.764  12.146  12.712  1.00 26.22           O  
TER    1083      GLU A 136                                                      
HETATM 1084  O   HOH   200      -1.905  -7.624   2.822  1.00 14.50           O  
HETATM 1085  O   HOH   201      -8.374   7.981   9.202  1.00 20.77           O  
HETATM 1086  O   HOH   202      -4.047   9.199  11.632  1.00 38.24           O  
HETATM 1087  O   HOH   203       6.172  14.210   8.483  1.00 14.50           O  
HETATM 1088  O   HOH   204       2.903   7.804  15.329  1.00 24.51           O  
HETATM 1089  O   HOH   205      16.654   0.676  11.968  1.00 10.49           O  
... 

(file truncated here)


HETATM 1157  O   HOH   286       6.960  14.840  -3.025  1.00 35.59           O  
HETATM 1158  O   HOH   287      -3.222  10.410   7.061  1.00 38.91           O  
HETATM 1159  O   HOH   288      28.306   0.551   4.876  1.00 52.13           O  
HETATM 1160  O   HOH   290      21.506 -12.424   9.751  1.00 31.68           O  
HETATM 1161  O   HOH   291      12.951  10.424  -7.324  1.00 46.10           O  
HETATM 1162  O   HOH   292      18.119 -15.184  14.793  1.00 56.82           O  
HETATM 1163  O   HOH   293      13.501  22.220   8.216  1.00 43.30           O  
HETATM 1164  O   HOH   294      13.916 -11.387   9.695  1.00 47.13           O  
MASTER      240    0    0    1   11    0    0    6 1163    1    0   11          
END                                                                  
\end{lstlisting}

PDB文件非常长，主要是因为需要存储分子中每个原子的信息。这还算是一个相对简短的例子，如果全部列出来，它会非常长——有28页纸之多。此处，我把它截取了一下，缩减到了三页纸多点，把主要的部分全部都展示了出来，让你能有一个大体上的了解。

PDB网站上有基本的文档，当你阅读PDB文件并且编程处理它们的时候，你会需要这个文档的。PDB内容指南（Protein Data Bank Contents Guide，\href{http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2\_frame.html}{http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2\_frame.html}）可以说是最好的参考资料，里面有FAQs和一些额外的文档。 

在接下来的小节里，我会从这些文件中提取信息。因为这些文件描述的主要是大分子3D结构的信息，所以这些文件通常被图形程序所使用，来展示分子的空间结构。本书所讨论的范围并不包括图形，尽管如此，你还是将会看到如何从这些文件中提取出空间坐标。PDB文件中最大的一部分是包含原子坐标的ATOM记录类型行。因为这样详细的程度，PDB文件通常都比GenBank记录要长。（注意术语上的不一致——PDB的基本单元就是文件，它包含了一个结构；而GenBank的基本单元是记录，它包含了一个条目。）

\subsection{PDB文件格式}
让我们看一个PDB文件，文档告诉了我们PDB文件中的信息是如何组织的。基于这些信息，你可以解析文件，从中提取出你感兴趣的信息。

PDB文件有含有80列的多行组成，每一行都以某个预定义的记录名起始，以换行符终止。（“列“表示一行中的位置：第一个字符在第一列上，以此类推。）空列用空白填充。一个\textit{记录类型}是有相同记录名的一行或多行。不同的记录类型有在行中定义的不同类型字段。它们也据功能进行分组。

SEQRES记录类型是一级结构部分（Primary Structure Section）中的四大记录类型之一，它描述了肽或核苷酸序列的一级结构：

\textcolor{red}{\textit{DBREF}}
\begin{adjustwidth}{4em}{}
指向序列数据库中的记录
\end{adjustwidth}

\textcolor{red}{\textit{SEQADV}}
\begin{adjustwidth}{4em}{}
记录PDB与其他序列数据库的冲突
\end{adjustwidth}

\textcolor{red}{\textit{SEQRES}}
\begin{adjustwidth}{4em}{}
骨干残基的一级序列
\end{adjustwidth}

\textcolor{red}{\textit{MODRES}}
\begin{adjustwidth}{4em}{}
记录标准残基上的修饰
\end{adjustwidth}

上一节的PDB记录例子中的DBREF和SEQADV记录类型，给出了参考信息，以及PDB和原始数据库之间的冲突细节。（例子中不包含MODRES记录类型。）下面是这个记录中的这些记录类型：

\begin{lstlisting}
DBREF  1C1F A    1   136  SWS    P26788   LEG_CONMY        1    135             
SEQADV 1C1F LEU A  135  SWS  P26788              SEE REMARK 999 
\end{lstlisting}

简单来说，DBREF行声明有一个叫做\textit{1C1F}的PDB文件（来自于叫做\textit{pdb1c1f.ent}的文件），在原始的Swiss-Prot（SWS）数据库中A链的残基从1开始编号一直到136，在那个数据中它的ID号为P26788，名字为LEG\_CONMY（在许多数据库中这些都是一样的），在PDB数据库中残基从1开始编号到135。原始数据库和PDB编号上的差异在SEQADV记录类型中进行了解释，它让你参考REMARK的999行（此处未显示），在那里你会发现PDB记录对于Swiss-Prot序列上第135位的亮氨酸有歧义（也许这是两个不同小组测定的结构，它们在这个位点上有分歧）。\footnote{在老的PDB文件中，不同数据库的交叉引用是一个问题：它可能缺失，或者隐藏在REMARK的999行的某个地方。} 

你可以看到，要通过程序解析这两行的信息，需要好几步，比如跟随到达PDB记录其他行的链接，它会进一步解释重复，并且识别其他的数据库。

在生物信息学中，数据库之间的链接是非常重要的。\autoref{tab:table11.1}展示了PDB文件中参考的数据库。如你所知，有许多的生物学数据库，这儿展示的主要是和蛋白质或者结构数据相关的数据库。

\begin{table}[!htbp]
  \begin{center}
  \caption{PDB文件中参考的数据库}
  \label{tab:table11.1}
  \begin{tabu} to 0.6\linewidth {X[3,l]X[1,l]}
  \toprule
  Database & PDB code\\
  \midrule
  BioMagResBank & BMRB \\
  BLOCKS & BLOCKS\\
  European Molecular Biology Laboratory & EMBL\\
  GenBank & GB\\
  Genome Data Base & GDB\\
  Nucleic Acid Database & NDB\\
  PROSITE & PROSIT\\
  Protein Data Bank & PDB\\
  Protein Identification Resource & PIR\\
  SWISS-PROT & SWS\\
  TREMBL & TREMBL\\
  \bottomrule
  \end{tabu}
  \end{center}
\end{table}

\subsection{SEQRES}
刚刚起步，我们先用Perl来尝试一个相对简单的任务：提取氨基酸序列数据。要提取氨基酸的一级序列信息，你需要解析SEQRES记录类型。下面是先前那个PDB文件中的SEQRES行：

\begin{lstlisting}
SEQRES   1 A  136  SER GLY GLY LEU GLN VAL LYS ASN PHE ASP PHE THR VAL
\end{lstlisting}

下面展示了PDB内容指南中定义的SEQRES记录类型。SEQRES部分，是一个相对简单的记录类型，它的定义被全部展示了出来，帮助你熟悉一下这种文档。

\begin{lstlisting}
SEQRES 
 
Overview 

SEQRES records contain the amino acid or nucleic acid sequence of residues in
each chain of the 
macromolecule that was studied. 

Record Format 

COLUMNS        DATA TYPE       FIELD         DEFINITION                           
---------------------------------------------------------------------------------
 1 -  6        Record name     "SEQRES"                                           

 9 - 10        Integer         serNum        Serial number of the SEQRES record   
                                             for the current chain.  Starts at 1  
                                             and increments by one each line.     
                                             Reset to 1 for each chain.           

12             Character       chainID       Chain identifier.  This may be any   
                                             single legal character, including a  
                                             blank which is used if there is      
                                             only one chain.                      

14 - 17        Integer         numRes        Number of residues in the chain.     
                                             This value is repeated on every      
                                             record.                              

20 - 22        Residue name    resName       Residue name.                        

24 - 26        Residue name    resName       Residue name.                        

28 - 30        Residue name    resName       Residue name.                        

32 - 34        Residue name    resName       Residue name.                        

36 - 38        Residue name    resName       Residue name.                        

40 - 42        Residue name    resName       Residue name.                        

44 - 46        Residue name    resName       Residue name.                        

48 - 50        Residue name    resName       Residue name.                        

52 - 54        Residue name    resName       Residue name.                        

56 - 58        Residue name    resName       Residue name.                        

60 - 62        Residue name    resName       Residue name.                        

64 - 66        Residue name    resName       Residue name.                        

68 - 70        Residue name    resName       Residue name.                        

Details 

* PDB entries use the three-letter abbreviation for amino acid names and the
  one-letter code for nucleic acids. 

* In the case of non-standard groups, a hetID of up to three (3) alphanumeric
  characters is used. Common HET names appear in the HET dictionary. 

* Each covalently contiguous sequence of residues (connected via the "backbone"
  atoms) is represented as an individual chain. 

* Heterogens which are integrated into the backbone of the chain are listed as
  being part of the chain and are included in the SEQRES records for that chain. 

* Each set of SEQRES records and each HET group is assigned a component number.
  The component number is assigned serially beginning with 1 for the first set
  of SEQRES records. This number is given explicitly in the FORMUL record, but
  only implicitly in the SEQRES record. 

* The SEQRES records must list residues present in the molecule studied, even
  if the coordinates are not present. 

* C- and N-terminus residues for which no coordinates are provided due to
  disorder must be listed on SEQRES. 

* All occurrences of standard amino or nucleic acid residues (ATOM records)
  must be listed on a SEQRES record. This implies that a numRes of 1 is valid. 

* No distinction is made between ribo- and deoxyribonucleotides in the SEQRES
  records. These residues are identified with the same residue name (i.e., A,
  C, G, T, U, I). 

* If the entire residue sequence is unknown, the serNum in column 10 is "0",
  the number of residues thought to comprise the molecule is entered as numRes
  in columns 14 - 17, and resName in columns 20 - 22 is "UNK". 

* In case of microheterogeneity, only one of the sequences is presented. A
  REMARK is generated to explain this and a SEQADV is also generated. 

Verification/Validation/Value Authority Control 

The residues presented on the SEQRES records must agree with those found in
the ATOM records. 

The SEQRES records are checked by PDB using the sequence databases and
information provided by the depositor. 

SEQRES is compared to the ATOM records during processing, and both are checked
against the sequence database. All discrepancies are either resolved or
annotated in the entry. 

Relationships to Other Record Types 

The residues presented on the SEQRES records must agree with those found in
the ATOM records. DBREF refers to the corresponding entry in the sequence
databases. SEQADV lists all discrepancies between the entry's sequence for
which there are coordinates and that referenced in the sequence database.
MODRES describes modifications to a standard residue. 

Example 

         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890
SEQRES   1 A   21  GLY ILE VAL GLU GLN CYS CYS THR SER ILE CYS SER LEU
SEQRES   2 A   21  TYR GLN LEU GLU ASN TYR CYS ASN                    
SEQRES   1 B   30  PHE VAL ASN GLN HIS LEU CYS GLY SER HIS LEU VAL GLU
SEQRES   2 B   30  ALA LEU TYR LEU VAL CYS GLY GLU ARG GLY PHE PHE TYR
SEQRES   3 B   30  THR PRO LYS ALA                                    
SEQRES   1 C   21  GLY ILE VAL GLU GLN CYS CYS THR SER ILE CYS SER LEU
SEQRES   2 C   21  TYR GLN LEU GLU ASN TYR CYS ASN                    
SEQRES   1 D   30  PHE VAL ASN GLN HIS LEU CYS GLY SER HIS LEU VAL GLU
SEQRES   2 D   30  ALA LEU TYR LEU VAL CYS GLY GLU ARG GLY PHE PHE TYR
SEQRES   3 D   30  THR PRO LYS ALA                                    

Known Problems 

Polysaccharides do not lend themselves to being represented in SEQRES. 

There is no mechanism provided to describe sequence runs when the exact
ordering of the sequence is not known. 

For cyclic peptides, PDB arbitrarily assigns a residue as the N-terminus. 

For microheterogeneity only one of the possible residues in a given position
is provided in SEQRES. 

No distinction is made between ribo- and deoxyribonucleotides in the SEQRES
records. These residues are identified with the same residue name (i.e., A,
C, G, T, U). 
\end{lstlisting}

这行的结构包括显而易见的SEQRES记录类型，以及指定给航中特定位置或者列的字段。稍后你会看到如何利用这些位置来解析信息。注意，文档中包含了大量的细节，当你处理这样复杂的实验数据时可能会需要。

除了序列不断积累这个还算标准的问题外，多链会让它更加复杂。通过阅读刚才展示的文档，你会看到在SEQRES这个识别符后面，还有一个表示这条链的行数的数字，接下来的字段就是链信息（尽管在老的记录中，它是可选的，并且很可能会空着）。在这些字段后是表示链中残基总数的一个数字。最后，在这些内容之后，使用三字母代码表示的残基。为了实现我们的编程目的，哪些信息是需要的，哪些又可以被忽略掉呢？

\section{解析PDB文件}
首先，\autoref{exam:example11.5}演示了主程序和三个子程序，在本节将会对它们进行讨论。

%\textbf{例11-5：从PDB文件中提取序列链}
\lstinputlisting[label=exam:example11.5,caption={例11-5：从PDB文件中提取序列链}]{./scripts/example11-5.pl}

一定要注意这一点，调用读取PDB文件的子程序\verb|get_file_data|的主程序中，包含了一个对于大的PDB文件的警告。（比如，PDB文件\textit{1gav}就有3.45
MB之大。）另外，主程序中，把整个文件读取进来之后，子程序\verb|parsePDBrecordtypes|把输入文件中的所有行都进行了拷贝，用记录类型分隔开。在这一点上，程序运行时会占用文件大小两倍大的内存空间。这种设计的有点在于它的清晰化和模块化，但主内存不够用的时候它也会导致问题。如果不保存从文件中读取进来的结果，而是直接把文件数据传递给\verb|parsePDBrecordtypes|子程序，这样占用的内存会小一些，就想这样：

\begin{lstlisting}
# Get the file data and parse the record types of the PDB file
%recordtypes = parsePDBrecordtypes(get_file_data('pdb/c1/pdb1c1f.ent'));
\end{lstlisting}

进一步节省内存也是可能的。比如，你可以重写程序，让它在把数据解析成记录类型的时候一次只读入文件的一行。我之所以指出这一点，是让你明白在处理大文件的时候，有许多种选择，这在实践中是非常重要的。尽管如此，现在我们还是坚持刚才的设计。这样可能比较耗费内存，但却让整个程序结构更加清晰明了。

在\autoref{chap:chapter10}中，我演示了两种方法，把GenBank文件解析成序列和注释，之后又把注释一层层得解析出来。

第一种方法是循环处理存储着记录行的数据。回忆一下，因为多行字段的结构，当循环的时候我们需要设置一个标识来记录输入行处于那个字段中。\footnote{在GenBank中，多行信息集叫做字段；在PDB中，它们叫做记录类型。就像在生物学中，不同的研究人员可能会使用他们自己的术语来描述结构或者概念一样，在计算机科学中，大家对术语也有一定的创造性。这也是整合生物学数据资源时存在的比较有趣的困难之一。}

另外一种方法，更加适用于GenBank文件，使用的正则表达式。哪种方法对于PDB文件最适合呢？（又或者你探索一下第三种方法？）

有好多方法可以提取出这个信息。PDB使得收集记录类型比较容易，因为它们在行首都起始于同样的关键字。在上一章中，使用的正则表达式这种技术来解析文件顶层的字段，这种方法对于PDB文件来说略显笨重。（参看本章末尾的练习题。）比如，下面的这个匹配所有临近SEQRES行的正则表达式可以它们整合进一个标量字符串中：

\begin{lstlisting}
$record =~ /SEQRES.*\n(SEQRES.*\n)*/;
$seqres = $&;
\end{lstlisting}

正则表达式使用\verb|SEQRES.*\n|匹配单独的SEQRES行，然后使用\verb|(SEQRES.*\n)*|匹配零行或者多行附加行。注意最后的\verb|*|表明匹配前面的项目零次或者多次，也就是用小括号括起来的表达式\verb|(SEQRES.*\n)|。此外，还要注意\verb|.*|匹配另个或者多个非换行符字符。最后，第二行把用\verb|$&|表示的匹配到的模式捕获起来，保存到了变量\verb|$seqres|中。

要扩充它来捕获所有的记录类型，可以参看本章末尾的练习题。

对于PDB文件来说，每一行都起始于一个关键字，明确表明了该行属于哪种记录类型。在文档中，你会发现，在每一组中，每一种记录类型的行都彼此相邻。在这种情况下，简单的对所有行进行重复收集记录类型，这看起来是最简单的编程策略了。

\autoref{exam:example11.5}包含一个叫做\textit{parsePDBrecordtypes}的子程序，它从包含PDB记录行的数组中解析PDB记录类型。这是一个简洁的程序，它可以完成它需要完成的工作。注释对发生的事情进行了很好地描述，如你所知，对于编写好的代码来说注释是至关重要的一个因素。简单来说，对每一行的记录类型进行检查，然后把它添加到散列的值里面去，散列的键是记录类型。最后，散列从子程序中返回出来。

\subsection{提取一级序列}
既然记录类型已经被解析出来了，就让我们看看子程序\textit{extractSEQRES}是如何提取一级氨基酸序列的。

你需要把每条链单独提取出来，返回对应这些链的一个或多个序列字符串的一个数组，而不是仅仅一条序列。

\autoref{exam:example11.4}中前面的解析，只把需要的SEQRES记录类型保留了下来，它包含多行内容，以单个标量字符串的形式存储为散列的值，其对应的键为`\verb|SEQRES|'。先前对行进行循环处理（与对多行字符串使用正则表达式不同）的\textit{parsePDBrecordtypes}子程序的成功导致了此处同样的方法。Perl函数\textit{split}可以让你把一个多行的字符串转换成一个数组。

在对SEQRES记录类型中的行进行循环处理的时候，注意，当一个新的链开始时，会把先前的链保存到数组\verb|@results|中，重置变量\verb|$sequence|，同时也把\verb|$lastchain|标识重置为新的链。此外，当处理完所有的行后，要确保把最后的序列链保存进\verb|@results|数组。

还要注意（查阅这个函数的Perl文档进行确认），根据你给它的参数，\textit{split}会完成你所期望的工作。

\autoref{exam:example11.5}中的第三个也是最后一个子程序叫做\textit{iub3to1}。因为PDB中的序列信息使用三字母进行编码的，所以你需要这个子程序来把这些序列转变成单字母编码的形式。它直截了当的使用了一个散列查找来完成这个转换。

我们现在已经把问题分解成了几个互相协作的子程序。如何最优得把一个问题分解成协作的子程序，这总是非常有趣。你可以把\textit{iub3to1}的调用放在\textit{extractSEQRES}子程序里面，这可能是把这些子程序组合在一起的一个比较简洁明了的方法，毕竟，除了PDB文件格式，你很可能不会用到三字母编码的氨基酸字符串。

在这个关口，最重要的一个论点就是需要指出，在一个简短的主程序中把几个简短的子程序组合起来，足够来完成解析PDB文件这样复杂的任务了。

\subsection{查找原子坐标}
到现在为止，我只是对蛋白质结构进行了简单的概述，并没有试图进行更加详细的介绍。但是，在解析PDB文件的时候，你还是要面对一大堆的细节信息，关于结构和确定结构所使用的实验条件。现在，我将演示一个简短的程序，从PDB文件中提取出原子坐标。我不会进行全面的讲解，要想了解更多，你需要去仔细阅读PDB文档，以及蛋白质结构、X射线衍射和NMR技术的参考资料。

刚才说，我们要从ATOM记录类型中提取坐标。ATOM记录类型是MODEL、ATOM、SIGATM、ANISOU、SIGUIJ、TER、HETATM和ENDMDL等处理原子坐标数据的众多记录类型中的一种。此外，还有几个处理坐标转换的记录类型：ORIGXn、SCALEn、MTRIXn和TVECT。

下面是PDB文档中介绍每个ATOM记录的字段定义的部分：

\begin{lstlisting}
ATOM 

Overview 

The ATOM records present the atomic coordinates for standard residues.
They also present the occupancy and temperature factor for each atom.
Heterogen coordinates use the HETATM record type. The element symbol
is always present on each ATOM record; segment identifier and charge
are optional. 

Record Format 

COLUMNS        DATA TYPE       FIELD         DEFINITION                            
---------------------------------------------------------------------------------
 1 -  6        Record name     "ATOM  "                                            

 7 - 11        Integer         serial        Atom serial number.                   

13 - 16        Atom            name          Atom name.                            

17             Character       altLoc        Alternate location indicator.         

18 - 20        Residue name    resName       Residue name.                         

22             Character       chainID       Chain identifier.                     

23 - 26        Integer         resSeq        Residue sequence number.              

27             AChar           iCode         Code for insertion of residues.       

31 - 38        Real(8.3)       x             Orthogonal coordinates for X in       
                                             Angstroms.                       

39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in       
                                             Angstroms.                            

47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in       
                                             Angstroms.                            

55 - 60        Real(6.2)       occupancy     Occupancy.                            

61 - 66        Real(6.2)       tempFactor    Temperature factor.                   

73 - 76        LString(4)      segID         Segment identifier, left-justified.   

77 - 78        LString(2)      element       Element symbol, right-justified.      

79 - 80        LString(2)      charge        Charge on the atom.       
\end{lstlisting}

下面是一个典型的ATOM行：

\begin{lstlisting}
ATOM      1  N   GLY A   2       1.888  -8.251  -2.511  1.00 36.63           N  
\end{lstlisting}

让我们来做一些非常简单的事情：提取出每个原子的x坐标、y坐标和z坐标，以及其序列号（每个原子在分子中独一无二的整数序号）和元素符号。\autoref{exam:example11.6}是一个完成该任务的子程序，以及一个执行该子程序的主程序。

%\textbf{例11-6：从PDB文件中提取原子坐标}
\lstinputlisting[label=exam:example11.6,caption={例11-6：从PDB文件中提取原子坐标}]{./scripts/example11-6.pl}

子程序\textit{parseATOM}非常简短：ATOM记录严格规范的格式使得从中解析信息非常直截了当。首先，你把包含ATOM行的标量参数分割成一个由行组成的数组。

然后，对于每一行，使用\verb|substr|函数提取出该行特定的列，这些列包含了我们需要的数据：原子的序列号，x、y和z坐标，以及元素符号。

最后，把结果保存到一个散列中，散列的键就是序列号，散列的值是包含其他四个相关字段的字符串。现在，这可能不总是返回数据最便捷的方法。有一点要注意，散列并不对键进行排序，所以如果你要以序列号对原子进行排序，那就还需要额外的一步。尤其，要根据序列号的排序存储信息，数组是一个比较合理的选择。或者，如果你真正想要的是找到所有的金属原子，这种情况下，推荐使用另外一种数据结构。但不管怎样，这个简短的子程序演示了找到并报告信息的一种方法。

通常会发生这样的事情，你真正需要的是对数据进行重新格式化，用于其他的程序。使用这个子程序的技术，你可以看到，如何去提取需要的数据，以及通过添加\verb|print|语句来数据格式化成想要的格式。看一下\textit{printf}和\textit{sprintf}函数，它们可以对格式进行更加细致的控制。对于真正的任务繁重的格式化，有一个\textit{format}函数，在O'Reilly's详尽的\textit{Programming Perl}的一书中有单独的一章对它进行介绍。（参看本书的\autoref{chap:chapter12}和\autoref{chap:chapterab}。）

下面是\autoref{exam:example11.6}的输出：

\begin{lstlisting}
 1.888   -8.251   -2.511  N
18.955  -10.180   10.777  C
\end{lstlisting}

现在，你至少可以从PDB文件中提取出主要的原子坐标部分了。重申一次，好消息是：你不需要一个冗长或者特别复杂的程序就可以完成它需要完成的任务。

这个程序进行了一定的设计，使得其中的部分可以在后续的工作中用于其他的目的。比如，你要解析所有的记录类型，而不仅仅是ATOM记录类型。让我们看一下一个非常简短的程序，它只是从一个输入文件中把ATOm记录类型行解析了出来。如果仅仅是为了解决这个问题，你可以编写一个更加简短的程序。下面就是这个程序：

\begin{lstlisting}
while(<>) {
  /^ATOM/ or next;

  my($n, $x, $y, $z, $element)
    = ($_ =~ /^.{6}(.{5}).{19}(.{8})(.{8})(.{8}).{22}(..)/);

  # $n and $element may have leading spaces: strip them
  $n      =~ s/^\s*//;
  $element =~ s/^\s*//;

  if (($n == 1) or ($n == 1078)) {
    printf "%8.3f%8.3f%8.3f %2s\n", $x, $y, $z, $element;
  }
}
\end{lstlisting}

对于每一行，正则表达式匹配会提取出需要的信息。回忆一下，一个包含小括号元字符的正则表达式会返回一个数组，数组的元素就是小括号中匹配的字符串的特定部分。你把这些小括号中匹配到的子字符串赋值给了\verb|$number|、\verb|$x|、\verb|$y|、\verb|$z|和\verb|$element|这五个变量。

实际上，正则表达式只是简单的使用了点号和量词操作符\verb|.{num}|来表示字符的个数。用这种方法，你可以从用脱字符\verb|^|这个元字符表示的字符串的开头开始，指定这行信息中的特定的列，把你需要的信息用小括号括起来返回回来。

比如，你需要开头的六个字符，所以你用\verb|^.{6}|指定它们，但是你需要接下来的五个字符，因为它们包含了原子的序列号，所以使用\verb|(.{5})|来指定这个字段。

坦率的说，对于现在的这个目的来说，我认为使用\verb|substr|更加清晰一些，但是我也想给你演示使用能够正则表达式的另外一种方法。

我们已经看到了使用\verb|printf|函数比使用\verb|print|函数有更多的选项可以控制输出的格式。

这个程序中还有一个重要的捷径。它并没有指定打开和读取的文件。在Perl中，你可以在命令行中给出输入文件的文件名（或者把它拖放到Mac
droplet中），程序就会从那个文件中读取它的输入。像程序的第一行演示的那样，只需要使用尖括号就可以从文件中读取了。你可以把\verb|open|函数中所有的调用和测试是否成功的测试全部丢弃掉，仅仅使用尖括号。你也可以在命令行中这样调用它，假设你把程序保存到了一个叫做\textit{get\_two\_atoms}的文件中：

\begin{lstlisting}
%perl get_two_atoms pdb1a4o.ent
\end{lstlisting}

此外，你还可以通过管道把数据传递给程序，使用下面的命令：

\begin{lstlisting}
% cat pdb1a40.cat | perl get_two_atoms
\end{lstlisting}

或者进行重定向：

\begin{lstlisting}
% perl get_two__atoms < pdb1a40.ent 
\end{lstlisting}

另外，在你的程序中也可以\verb|<STDIN>|而不是\verb|<>|来读取数据。

\section{控制其他程序}
Perl使得在你的Perl程序中运行其他程序并且收集它们的输出非常简单。这是一个异常有用的能力。对于大多数程序来说，Perl都可以非常简单的完成这个任务。

很多时候，你可能需要运行一些特定的程序，比如针对PDB中的每一个文件提取出二级结构信息。程序本身可能并没有办法让它“针对所有的文件运行自己”。另外，程序的输出中可能会有各种各样无关的信息。你需要的只是一个更加简单的报告，仅仅呈现你感兴趣的信息，可能要以一种特定的格式作为其他程序输入！使用Perl，你可以编写一个程序来精确地完成该任务。

自动化执行的一种重要类型的程序就是网站上提供的在线的有用的程序或数据。使用合适的Perl模块，你可以连接到网站上，发送你的输入，收集输出，然后按照你的意愿进行解析和重格式化。这实际上并不难！作为\textit{Programming Perl}的姊妹篇，O'Reilly的\textit{Perl Cookbook}是一个简单程序和有用描述的优秀资源，可以帮助你快速起步。

Perl是自动化其他成语的一种杰出的方法。下一小节将演示一个实例，使用一个Perl程序来启动其他的程序，并且收集、解析、重格式化和输出结果。这个程序会控制同一台计算机上的另一个程序。实例基于Unix或者Linux平台环境；关于如何在你的Windows或者Macintosh平台上实现同样的功能，请参阅你的Perl文档。

\subsection{Stride二级结构预测器}
我们将会使用一个外部程序，基于一个PDB文件的3D坐标来计算它的二级结构。作为一个二级结构任务引擎，我使用叫做\textit{stride}的程序，它会输出二级结构报告。\textit{stride}可以从EMBL（\href{http://www.embl-heidelberg.de/stride/stride\_info.html}{http://www.embl-heidelberg.de/stride/stride\_info.html}\footnote{译者注：原链接已失效，请前往 \href{http://webclu.bio.wzw.tum.de/stride/}{http://webclu.bio.wzw.tum.de/stride/}。}）上获取到，它可以在Unix、Linux、Windows、Macintosh和VMS操作系统上运行。这个程序的工作原理非常简单，就是把一个PDB文件名作为命令行参数给它，并在之后的\textit{call\_stride}子程序中收集输出。

\autoref{exam:example11.7}是完整的程序，包括两个子程序和一个主程序，程序的后面是讨论。

%\textbf{例11-7：调用其他程序进行二级结构预测}
\lstinputlisting[label=exam:example11.7,caption={例11-7：调用其他程序进行二级结构预测}]{./scripts/example11-7.pl}

正如你在子程序\textit{call\_stride}中看到的那样，针对程序名（\verb|$stride|）和你想传递的选项（\verb|$options|）我们都单独创建了变量。因为这是程序中你可能需要修改的部分，所以把它们做成变量放在代码的顶部，这样就容易找到并修改它们了。子程序的参数是PDB文件的文件名（\verb|$filename|）。（当然，如果你认为选项会经常改变，也可以把它们做成子程序的另外一个参数。）

既然你正在处理的是一个读入文件的程序，那么需要进行一点点的错误检查来看看通过名字指定的这个文件是不是真的存在。使用\verb|-e|文件测试符即可。或者你可以跳过这一步，让\textit{stride}程序来检查它是否存在，然后捕获它的错误输出。但是这样的话，就需要从\textit{stride}的输出中解析错误输出，而这则需要了解\textit{stride}是如何报告错误的。这会让事情变得复杂起来，所以我还是坚持使用\verb|-e|文件测试符。

实际上，程序的运行和收集它的输出只发生在一行代码中。需要运行的程序被包裹在反引号中，它会运行程序（首先展开变量），并且返回输出结果，存储在由每一行组成的数组中。

还有其他的方法可以运行程序。一种常见的方法是进行调用\textit{system}函数。它和反引号的行为有所不同：它并不会返回它调用的命令的输出（它仅仅返回退出状态，也就是表示命令运行成功或失败的一个整数）。其他方法还包括\textit{qx}、\textit{open}系统调用，以及\textit{fork}和\textit{exec}函数。

\subsection{解析Stride的输出}
此处我不想太过深入得讲解\textit{stride}输出结果的解析。我们只看一下提取一级序列和二级结构预测的代码。可以看看本章末尾的练习题，挑战一下从PDB文件的HELIX、SHEET和TURN记录类型中提取出二级结构信息，然后把它们输出成类似此处\textit{stride}输出的格式。

下面是一个典型的\textit{stride}输出的一部分（并不是全部输出）：

\begin{lstlisting}
SEQ  1    MDKNELVQKAKLAEQAERYDDMAACMKSVTEQGAELSNEERNLLSVAYKN   50          1A4O
STR         HHHHHHHHHHHHHH  HHHHHHHHHHHHHTTT   HHHHHHHHHHHHH               1A4O
REM                                                                        1A4O
REM                .         .         .         .         .               1A4O
SEQ  51   VVGARRSSWRVVSSIEQKEKKQQMAREYREKIETELRDICNDVLSLLEKF  100          1A4O
STR       HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHT               1A4O
REM                                                                        1A4O
REM                .         .         .         .         .               1A4O
SEQ  101  LIPNAAESKVFYLKMKGDYYRYLAEVAAGDDKKGIVDQSQQAYQEAFEIS  150          1A4O
STR       TTTTT HHHHHHHHHHHHHHHHHHHH   HHHHHHHHHHHHHHHHHHHHH               1A4O
REM                                                                        1A4O
REM                .         .         .         .                         1A4O
SEQ  151  KKEMIRLGLALNFSVFYYACSLAKTAFDEAIAELLIMQLLRDNLTLW     197          1A4O
STR       TTTTHHHHHHHHHHHH   HHHHHHHHHHHHH  HHHHHHHHHH                     1A4O
\end{lstlisting}

注意，每一行的都是以一个识别码开始的，这使得收集不同的记录类型简单了许多。不需要去查阅文档（有点危险，但有时也是权宜之计）你就可以看出，一级序列有\verb|SEQ|这个关键词，结构预测有\verb|STR|这个关键词，并且我们感兴趣的数据位于每一行的第11列到第60列之间。（现在我们会把其他的都忽略掉。）

下面这个列表展示了\textit{stride}使用的单字母二级结构代码：

\begin{table}[!htbp]
  \begin{center}
  \begin{tabu} to 0.5\linewidth {X[1,l]X[2,l]}
  \toprule
  H & $\alpha$-螺旋（Alpha helix）\\
  G & 3-10螺旋（3-10 helix）\\
  I & $\pi$-螺旋（PI helix）\\
  E & 延伸构造（Extended conformation）\\
  B or b& 孤立桥（Isolated bridge）\\
  T & 转角（Turn）\\
  C & 卷曲（Coil，不属于上面的任何一类）\\
  \bottomrule
  \end{tabu}
  \end{center}
\end{table}

使用\verb|substr|函数，两个\verb|for|循环会改变两个数组的每一行，把这些字符串的第11位到第60位之间的部分保存起来。这正是我们所需要的信息所处的位置。

现在，让我们检查一下\autoref{exam:example11.7}中的子程序\textit{parse\_stride}，它以\textit{stride}的输出作为输入，返回一级序列和二级结构预测这两个字符串的组成的数组。

这是一个非常有“Perl风格”的子程序，它使用了许多处理文本的特性。让人感兴趣的是程序的简洁，正是许多Perl内置函数使其成为了可能。

首先，你在子程序中使用参数\verb|@_|获取了\textit{stride}程序的输出。接着，使用\textit{grep}函数提取出感兴趣的那些行，在输出中很容易就可以把它们识别出来，因为它们都起始于明确的识别符\verb|SEQ|和\verb|STR|。

接下来，你只想把这些行中包含序列或者结构信息的位置（或列）保存起来，你并不需要关键字、位置号，一级行尾的PDB记录名。

最后，把数组连接成单个的字符串。此处，有一个细节需要处理：你需要把这些字符串末尾的不需要的空白全部去除掉。注意\textit{stride}有时会在结构预测中留有空白，在这个例子中，结构预测的末尾就有一些空白。但是你不应该把这些字符串末尾的所有空白全部去掉，而是去掉序列字符串末尾的所有空白，因为它们仅仅是行中多余的空白而已。现在，看看序列字符串末尾有多少空白，就要丢掉结构预测字符串末尾同样数目的空白，这样就可以保留下与未确定的二级结构相对应的空白了。

\autoref{exam:example11.7}中包含一个主程序调用这两个子程序，因为子程序非常简单，就把它们都包含在内了（所以此处没有必要使用\textit{BeginPerlBioinfo}模块）。下面是\autoref{exam:example11.7}的输出： 

\begin{lstlisting}
GGLQVKNFDFTVGKFLTVGGFINNSPQRFSVNVGESMNSLSLHLDHRFNYGADQNTIVMNSTLKGDNGWETEQRSTNFTL
    TTTTTTBTTT EEEEEEETTTT EEEEEEEEETTEEEEEEEEEEEETTEEEEEEEEEETTGGG B   EEE     
\end{lstlisting}

第一行显示的是氨基酸，而第二行则是二级结构的预测。对于改善输出的子程序，可以参看下一小节。

\section{练习题}
\textcolor{red}{\textit{练习11.1}}
\begin{adjustwidth}{2em}{}
使用\textit{File::Find}和文件测试操作符来找到你计算机硬盘上最老的和最大的文件。（当你的硬盘空间不够用的时候，你可以删除它们，或者把它们保存到别的地方去。）
\end{adjustwidth}

\textcolor{red}{\textit{练习11.2}}
\begin{adjustwidth}{2em}{}
找到你计算机中的所有Perl程序。

\textit{提示}：使用\textit{File::Find}。所有的Perl程序都有什么共同点？
\end{adjustwidth}

\textcolor{red}{\textit{练习11.3}}
\begin{adjustwidth}{2em}{}
  解析你计算机上所有PDB文件的HEADER、TITLE和KEYWORDS记录类型。制作一个散列，其\textit{键}就是这些记录类型单词，\textit{值}则是包含这些单词的文件名列表。把它保存为一个DBM文件，并且为它构建一个查询程序。最后，你应该能够在询问一个单词的情况下，比如，sugar这个单词，得到在HEADER、TITLE或者KEYWORDS记录中包含这个单词的所有PDB文件列表。
\end{adjustwidth}

\textcolor{red}{\textit{练习11.4}}
\begin{adjustwidth}{2em}{}
使用正则表达式（在\autoref{chap:chapter10}中使用过），而不是对由输入行组成的数组进行循环处理（本章中就是这种方法），解析出PDB文件的记录类型。
\end{adjustwidth}

\textcolor{red}{\textit{练习11.5}}
\begin{adjustwidth}{2em}{}
编写一个程序，提取出PDB文件中HELIX、SHEET和TURN记录类型中包含的二级结构信息。同时输出二级结构和一级序列，这样就比较容易能看出某个残基是处于哪种二级结构中了。（考虑对二级结构使用一种特殊的字母表，这样的话，举个例子，螺旋中的每个残基就都可以用H来表示了。）
\end{adjustwidth}

\textcolor{red}{\textit{练习11.6}}
\begin{adjustwidth}{2em}{}
编写一个程序，找到一个给定目录中的所有PDB文件，并且运行一个程序（比如\textit{stride}），或者你在练习11.5中编写的程序，报告每个PDB文件中的二级结构。把结果保存到一个DBM文件中，用文件名作为键。
\end{adjustwidth}

\textcolor{red}{\textit{练习11.7}}
\begin{adjustwidth}{2em}{}
编写一个子程序，对于给定的两个字符串，把它们输出出来，让一个字符串在另一个字符串的上面，但是要有换行（类似与\textit{stride}程序的输出）。使用这个模块打印出\autoref{exam:example11.7}中的字符串。
\end{adjustwidth}

\textcolor{red}{\textit{练习11.8}}
\begin{adjustwidth}{2em}{}
编写一个递归的子程序，来确定一个数组的大小。你可能想要使用\verb|pop|或者\verb|unshift|函数。（暂时忽略掉\verb|scalar @array|会返回\verb|@array|的大小这个事实！）
\end{adjustwidth}

\textcolor{red}{\textit{练习11.9}}
\begin{adjustwidth}{2em}{}
编写一个递归的子程序，从一个PDB文件的SEQRES记录类型中提取出一级氨基酸序列。
\end{adjustwidth}

\textcolor{red}{\textit{练习11.10}}
\begin{adjustwidth}{2em}{}
（\textit{额外加分}）给定一个原子和距离，找到PDB文件中和这个原子相距距离范围以内的所有其他原子。
\end{adjustwidth}

\textcolor{red}{\textit{练习11.11}}
\begin{adjustwidth}{2em}{}
（\textit{额外加分}）编写一个程序，找到一级氨基酸序列和$\alpha$-螺旋定位之间的某种相关性。
\end{adjustwidth}

