\chapter{PDB}
\label{chap:chapter11}
\minitoc

人类基因组计划（Human Genome
Project）在解码人类基因DNA序列上的成功，已经俘获了公众的想象力，但另一个项目却没有获得如此的关注度，它也会得到同样具有变革性的结果。这个项目是进行国际性的合作努力，使用高通量分析技术，在基因组范围水平上确定大量蛋白质的3D结构。国际性的合作是结构基因组学这个新兴领域的基础。

最近技术上的突破，促进了确定蛋白质结构这场竞赛的加速。存储所有这些数据的商店就是\textit{PDB（Protein Data Bank）}，可以在网站\href{http://www.rcsb.org/pdb/}{http://www.rcsb.org/pdb/}上找到它。

找到氨基酸序列也就是一级序列，仅仅是蛋白质研究的开始。蛋白质会进行局部折叠，折叠成$\alpha$-螺旋、$\beta$-折叠和$\beta$-转角之类的二级结构。两个或三个临近的二级结构可能会组合成叫做“基元”或者“超二级结构”的常见折叠花式，比如$\beta$-片层或者$\alpha$-$\alpha$螺旋组合单元。这些建筑模块会进一步折叠成蛋白质的3D或者三级结构。最后，一个或者多个三级结构可能作为亚单元组合成酶或者病毒的四级结构。

在不知道一个蛋白质是如何折叠成一个3D结构之前，你很难直到这个蛋白质到底有什么功能，以及它是如何发挥功能的。即使你知道这个蛋白质在疾病中发挥作用，要想找到一个可能的治疗方案，通常还是需要知道它的三级结构。了解蛋白质的三级结构和它的\textit{活性位点}（它可能会包含那些在一级结构上相距甚远、但是在蛋白质折叠后却紧邻在一起的氨基酸），对于对于筛选新的药物靶点是至关重要的。

现在，包括人类在内的不少生物的基本遗传信息已经被解码了，接下来生物学家面临的主要挑战就是尽可能多的去了解这些基因编码的蛋白质，以及它们之间的相互作用。

事实上，现代生物学主要的问题之一就是蛋白质的一级氨基酸序列是如何决定它最终的3D结构的。如果能够找到一种计算方法，可以从蛋白质的氨基酸序列可靠地预测出它的折叠，那么生物学和医学的作用将是意义深远的。

在本章中，你将学习PDB文件的基础，以及如何从中解析出需要的信息。你将会探索更加有趣的Perl技术，寻找大量的文件并进行循环处理，以及在Perl程序中控制其他的生物信息学程序。本章末尾的练习题，在此处介绍的基本知识的基础上，让你挑战获取PDB数据的更多信息。

\section{PDB概述}
大分子（包括蛋白质、肽、病毒、蛋白质和核酸的复合物、核酸、以及碳水化合物）3D结构信息的主要资源就是PDB。并且，它的格式实际上就是交换结构信息的标准格式。PDB中的大多数结构都是通过X射线衍射（X-ray ）diffraction和核磁共振（NMR，nuclear magnetic resonance）实验确定的。

1971年PDB诞生之初，只有七个蛋白质，随后迅速增长到了20,000个结构。随着结构基因组学中国际性合作的增加，PDB仍然在延续它快速增长的态势。在短短几年的时间内，已知结构的数目将会接近100,000。

PDB文件和GenBank记录相似，都是人类可读的ASCII平面文件。文件中的文本符合特定的格式，所以可以编写计算机程序从中提取信息。和GenBank在一个“库”文件中保存许多记录不一样，PDB对于每一个结构都用一个文件来存储。

经常处理PDB文件的生物信息学家，会抱怨PDB格式在一致性上存在着严重的问题。比如，为了满足新知识的需要，随着字段和数据格式的不断变革，有些旧的文件就过时了。现在保持PDB数据一致性的工作正在进行中，直到这些工作完成、开发出一个新的数据格式之前，现有数据格式的不一致性仍然是程序员必须面对的一项挑战。如果你对PDB文件进行大量的编程，你会发现数据中有许多的不一致甚至错误，尤其是那些老的文件中。另外，许多能够成功解析新文件的工具，在老的文件上就不一定好用了。

随着你逐渐称为一个经验更加丰富的程序员，你面对的PDB这样那样的问题就显得更加重要的。比如，随着PDB的发展，你编写的和它进行交互的代码也要不断改进。你必须要时刻关注世界的变化，注意维护你的代码，让它与时俱进。随着数据库间链接得到了更好的支持，你的代码应该充分利用这些链接提供的新的机遇。数据存储的新标准正在建立中，你的代码也要更新把它们包含进去。

PDB网站上包含了大量关于如果下载搜有文件的信息。它们也以便于获取的免费的CD集进行发布，这对于那些没有高速网路连接的人来说是一个巨大的便利。

\section{文件和文件夹}
PDB以目录中的文件形式进行发布。每一个蛋白质结构都有自己单独的文件。PDB包含大量的数据，所以要处理它是一种挑战。在本节中，你将学习处理组织在目录和子目录中的大量文件。

你会发现，常常需要编写程序来操作大量的文件。比如，你可能会把多次的测序放在一个目录中，根据测序上机的日期分成子目录，把测序仪产生的数据放在对应日期的子目录中。在短短几年之后，你可能就会有相当数量的文件。

然后，有一天，你发现了一个新的DNA序列，看起来参与细胞分裂。你进行了一个BLAST搜索（参看\autoref{chap:chapter12}），但是没有找到对于新DNA的显著结果。这个时候，你想直到在以前的测序中是不是看到过这个DNA。\footnote{你可能会把所有的测序结构保存为一个大的BLAST库进行比较；可以使用本节介绍的技术构建这样的一个BLAST库。}你需要做的就是，针对多种多样的测序子目录中的成百上千的文件，运行比对的子程序。但这可能会重复耗费好几天，对于坐在计算机屏幕前的你来说这绝对是无聊透顶的工作。

你可以编写一个程序，在很短时间内完成这个工作！然后你需要做的就是回到座位上，检查一下结果中你的程序有没有找到显著的匹配。然而要编写这样的程序，你需要知道如何在Perl中操作所有的文件和文件夹。接下来的小节将向你演示如何去做。

\subsection{打开目录}
文件系统以\textit{树状}结构进行组织。这个比喻是非常贴切的。从树的任何地方开始，你可以沿着树干，得到源于从你开始之处的任何树叶。如果你从树根开始，你可以得到所有的树叶。类似的，在文件系统中，如果你从一个特定的目录开始，你可以得到源于你开始之处的子目录中的所有文件。如果你从文件系统的根（非常奇怪，它也被叫做“顶”）开始，你可以得到所有的文件。

在打开、读取、写入和关闭文件方面，你已经练习了很多。我将演示一个简单的方法，让你可以打开一个文件夹（也叫做目录），获取这个文件夹中所有文件的文件名。在那之后，你将看到如何从一个特定的地方开始，获取所有目录和子目录中的所有文件的名字。

从一些伪代码开始，让我们看一下列出文件夹中所有文件的Perl的方式：

\begin{lstlisting}
open folder

read contents of folder (files and subfolders)

print their names
\end{lstlisting}

\autoref{exam:example11.1}演示了真实的Perl代码。

\textbf{例11-1：列出文件夹（或目录）的内容}
\lstinputlisting[label=exam:example11.1]{./scripts/example11-1.pl}

因为你在一个包含PDB文件的文件夹中运行这个程序，所以你将会看到：

\begin{lstlisting}
.
..
3c
44
pdb1a4o.ent
\end{lstlisting}

如果你想列出当前目录中的文件，你可以把代表当前目录的“.”这个特殊名字赋值给目录名，就像这样：

\begin{lstlisting}
my $folder = '.';
\end{lstlisting}

在Unix或者Linux系统中，特殊文件“.”和“..”分别代表当前目录和父目录。它们并不是“真实”的文件，至少不是你想读取的文件。使用优秀的、了不起的\textit{grep}函数，你可以避免把它们罗列出来。\textit{grep}允许你根据测试选择数组中的元素，比如一个正则表达式。下面演示的是如何把数组中的“.”和“.”过滤掉：

\begin{lstlisting}
@files = grep( !/^\.\.?$/, @files );
\end{lstlisting}

因为感叹号这个取反操作符，\textit{grep}选择了不匹配正则表达式的所有行。正则表达式\verb|/^\.\.?$/|寻找这样的行，它以点号\verb|.|（因为点号是一个元字符，所以用反斜杠进行了转义）起始（一行的开头用\verb|^|元字符表示），后面跟着0个或者1个点号\verb|\.?|（\verb|?|匹配前面的元素0次或者1次），再后面就没有其他任何东西了（\verb|$|元字符表示字符串的结尾）。

实际上，当读取一个目录的时候，这非常常用，所以通常把它们组合到一步中：

\begin{lstlisting}
@files = grep (!/^\.\.?$/, readdir(FOLDER));
\end{lstlisting}

好了，现在所有的文件都罗列出来了。但是稍等：如果这些文件不是常规文件而是子文件夹呢？你可以使用便捷的文件测试操作符来检测每一个文件名，这样就可以打开每一个子文件夹把其中的文件罗列出来了。首先是一些伪代码：

\begin{lstlisting}
open folder

for each item in the folder

    if it's a file
        print its name

    else if it's a folder
        open the folder
        print the names of the contents of the folder
    }
}
\end{lstlisting}

\autoref{exam:example11.2}演示了这个程序。

\textbf{例11-2：列出文件夹及其子文件夹的内容}
\lstinputlisting[label=exam:example11.2]{./scripts/example11-2.pl}

下面是\autoref{exam:example11.2}的输出：

\begin{lstlisting}
pdb/3c/pdb43c9.ent
pdb/3c/pdb43ca.ent
pdb/44/pdb144d.ent
pdb/44/pdb144l.ent
pdb/44/pdb244d.ent
pdb/44/pdb244l.ent
pdb/44/pdb344d.ent
pdb/44/pdb444d.ent
pdb/pdb1a4o.ent
\end{lstlisting}

注意，代码中\verb|$file|和\verb|@files|这样的变量名是如何被重用的，方法就是在内层的代码块中使用\verb|my|限定词汇作用域。如果程序的整体结构不是这么简短，这样阅读起来就会相当困难。当程序中出现\verb|$file|的时候，它是表示此处的\verb|$file|还是彼处的\verb|$file|？这个代码就是一个引起麻烦的反面例子。它确实可以工作，但尽管它很简短，任然非常难于阅读。

事实上，\autoref{exam:example11.2}存在一个深层次的问题，它的设计并不好。通过对\autoref{exam:example11.1}进行扩充，它现在可以罗列出子目录了。但是如果还有更深层次的子目录呢？

\subsection{递归}
如果你有一个子程序，可以罗列出目录的内容，并且可以通过递归调用自己来罗列出它找到的任何子目录的内容，那么你就可以在顶层目录调用它，而它最终则会罗列出所有的文件。

让我们编写另一个程序来完成这个工作吧。一个\textit{递归}子程序被简单的定义为可以调用自己的子程序。下面是伪代码和代码（\autoref{exam:example11.3}，之后是对递归工作原理的讨论：

\begin{lstlisting}
subroutine list_recursively

    open folder

    for each item in the folder

        if it's a file
            print its name

        else if it's a folder
            list_recursively
    }
}
\end{lstlisting}

\textbf{例11-3：一个罗列文件系统的递归子程序}
\lstinputlisting[label=exam:example11.3]{./scripts/example11-3.pl}

下面是\autoref{exam:example11.3}的输出（注意它和\autoref{exam:example11.2}的输出是完全一样的）：

\begin{lstlisting}
pdb/3c/pdb43c9.ent
pdb/3c/pdb43ca.ent
pdb/44/pdb144d.ent
pdb/44/pdb144l.ent
pdb/44/pdb244d.ent
pdb/44/pdb244l.ent
pdb/44/pdb344d.ent
pdb/44/pdb444d.ent
pdb/pdb1a4o.ent
\end{lstlisting}

看一下\autoref{exam:example11.3}的代码，把它和\autoref{exam:example11.2}比较以下。如你所见，程序大体上是一样的。\autoref{exam:example11.2}整体就是一个主程序；而\autoref{exam:example11.3}拥有和它几乎完全一样的代码，只不过这些代码被打包成了一个子程序，然后在一个简短的主程序中调用这个子程序。\autoref{exam:example11.3}的主程序只是简单的调用了一个递归函数，给它一个目录名（我计算机中存在的一个目录；当你尝试在自己的计算机中运行这个程序的时候，你可能需要修改目录名）即可。下面就是这个调用

\begin{lstlisting}
list_recursively('pdb');
\end{lstlisting}

我对此有些失望，不知道你是不是也有这种感觉。这看上去和其他的子程序调用并没有什么区别。显然，递归必须在子程序内部进行定义。这出现在\textit{list\_recursively}子程序的最末尾，当程序发现（使用\verb|-d|文件测试操作符）目录列出的一个内容本身就是一个目录时，就会进行递归处理，和\autoref{exam:example11.2}中的代码相比这有着显著的不同。在这一点上，\autoref{exam:example11.2}有再一次寻找常规文件和目录的代码，
而\autoref{exam:example11.3}中的这个子程序通过简单的调用一个子程序就实现了这一点，这里的这个子程序就是它本身，叫做\textit{list\_recursively}的子程序：

\begin{lstlisting}
list_recursively("$directory/$file");
\end{lstlisting}

这就是递归。

正如你在此处所见，有很多时候，数据——比如文件系统的层次结构——正好能够匹配递归程序的这种能力。在子程序的末尾进行递归调用，这意味着它是一个特殊类型的递归，叫做\textit{尾递归（tail
recursion）}。尽管递归会很慢，归因于它创建的所有子程序调用，关于尾递归的好消息就是许多编译器会对代码进行优化，让它运行更快一些。使用递归可以得到简洁、易于理解的程序。（尽管Perl并不对它进行优化，现在Perl6的计划中包含对尾递归进行优化的支持。）

\subsection{处理大量文件}
Perl有可以处理各种任务的模块。有些模块是作为标准和Perl一块发布的，更多的则可以从CPAN（\href{http://www.CPAN.org/}{http://www.CPAN.org/}）或者其他地方下载安装。

上一小节的\autoref{exam:example11.3}演示了如何定位一个给定目录中的所有文件和目录。在所有近期版本的Perl中都有一个叫做\textit{File::Find}的标准模块。你可以在你的手册页中找到它：比如，在Unix或者Linux上，你可以使用命令\verb|perldoc File::Find|。这个模块让处理一个给定目录的所有文件变得简单且高效，它可以进行你指定的各种操作。

\autoref{exam:example11.4}使用了\textit{File::Find}。对于这个有用的模块的更多例子，可以参考它的文档。这个实例演示的功能和\autoref{exam:example11.3}是完全一样的，只不过现在使用了\textit{File::Find}。它只是简单的把文件和目录罗列出来。注意，你会发现，如果你找到一个好的模块，你只需要编写很少的代码即可，所以开始使用模块吧！

\textbf{例11-4：演示File::Find}
\lstinputlisting[label=exam:example11.4]{./scripts/example11-4.pl}

注意，通过在\textit{my\_sub}子程序前面使用反斜杠字符，把指针传递给了它。就像在\autoref{chap:chapter6}中提到的那样，你还需要在它名字的前面加上\verb|&|字符。

\textit{find}的调用也可以这样实现：

\begin{lstlisting}
find sub { -f and (print $File\dotsFind\dotsname, "\n")  }, ('pdb');
\end{lstlisting}

它把一个匿名子程序放在了\textit{my\_sub}子程序指针出现的地方，对于这种简短的子程序来说，这也是一种比较简洁的写法。

下面是它的输出：

\begin{lstlisting}
pdb/pdb1a4o.ent
pdb/44/pdb144d.ent
pdb/44/pdb144l.ent
pdb/44/pdb244d.ent
pdb/44/pdb244l.ent
pdb/44/pdb344d.ent
pdb/44/pdb444d.ent
pdb/3c/pdb43c9.ent
pdb/3c/pdb43ca.ent
\end{lstlisting}

作为使用Perl处理文件的最后一个例子，下面是一个在命令行中使用的单行程序，它的作用和上面这个程序是完全一样的：

\begin{lstlisting}
perl -e 'use File::Find;find sub{-f and (print $File::Find::name,"\n")},("pdb")'
\end{lstlisting}

尽管它不可避免的让人困惑，但对于那些崇尚简洁的人来说，这简直太酷了！此外还要注意，对于Unix操作系统的用户来说，\verb|ls -R pdb|和\verb|find pdb -print|也可以完成同样的工作，而且键入的字符更少。

之所以使用你定义的一个子程序，是因为它可以让你对找到的文件进行任意的测试，然后对这些文件进行任意的处理。模块化则是另外一个例子：\textit{File::Find}模块可以轻而易举地对一个文件结构中的所有文件和目录进行递归，让你随意处理找到的文件和目录。

\section{PDB文件}
下面是一个真实PDB文件的一部分：

\begin{lstlisting}
HEADER    SUGAR BINDING PROTEIN                   03-MAR-99   1C1F              
TITLE     LIGAND-FREE CONGERIN I                                                
COMPND    MOL_ID: 1;                                                            
COMPND   2 MOLECULE: CONGERIN I;                                                
COMPND   3 CHAIN: A;                                                            
COMPND   4 FRAGMENT: CARBOHYDRATE-RECOGNITION-DOMAIN;                           
COMPND   5 BIOLOGICAL_UNIT: HOMODIMER                                           
SOURCE    MOL_ID: 1;                                                            
SOURCE   2 ORGANISM_SCIENTIFIC: CONGER MYRIASTER;                               
SOURCE   3 ORGANISM_COMMON: CONGER EEL;                                         
SOURCE   4 TISSUE: SKIN MUCUS;                                                  
SOURCE   5 SECRETION: NON-CLASSICAL                                             
KEYWDS    GALECTIN, LECTIN, BETA-GALACTOSE-BINDING, SUGAR BINDING               
KEYWDS   2 PROTEIN                                                              
EXPDTA    X-RAY DIFFRACTION                                                     
AUTHOR    T.SHIRAI,C.MITSUYAMA,Y.NIWA,Y.MATSUI,H.HOTTA,T.YAMANE,                
AUTHOR   2 H.KAMIYA,C.ISHII,T.OGAWA,K.MURAMOTO                                  
REVDAT   2   14-OCT-99 1C1F    1       SEQADV HEADER                            
REVDAT   1   08-OCT-99 1C1F    0                                                
JRNL        AUTH   T.SHIRAI,C.MITSUYAMA,Y.NIWA,Y.MATSUI,H.HOTTA,                
JRNL        AUTH 2 T.YAMANE,H.KAMIYA,C.ISHII,T.OGAWA,K.MURAMOTO                 
JRNL        TITL   HIGH-RESOLUTION STRUCTURE OF CONGER EEL GALECTIN,            
JRNL        TITL 2 CONGERIN I, IN LACTOSE- LIGANDED AND LIGAND-FREE             
JRNL        TITL 3 FORMS: EMERGENCE OF A NEW STRUCTURE CLASS BY                 
JRNL        TITL 4 ACCELERATED EVOLUTION                                        
JRNL        REF    STRUCTURE (LONDON)            V.   7  1223 1999              
JRNL        REFN   ASTM STRUE6  UK ISSN 0969-2126                 2005          
REMARK   1                                                                      
REMARK   2                                                                      
REMARK   2 RESOLUTION. 1.6 ANGSTROMS.                                           
REMARK   3                                                                      
REMARK   3 REFINEMENT.                                                          
REMARK   3   PROGRAM     : X-PLOR 3.1                                           
REMARK   3   AUTHORS     : BRUNGER                                              
REMARK   3                                                                      
REMARK   3  DATA USED IN REFINEMENT.                                            
REMARK   3   RESOLUTION RANGE HIGH (ANGSTROMS) : 1.60                           
REMARK   3   RESOLUTION RANGE LOW  (ANGSTROMS) : 8.00                           
REMARK   3   DATA CUTOFF            (SIGMA(F)) : 3.000                          
REMARK   3   DATA CUTOFF HIGH         (ABS(F)) : NULL                           
REMARK   3   DATA CUTOFF LOW          (ABS(F)) : NULL                           
REMARK   3   COMPLETENESS (WORKING+TEST)   (%) : 85.0                           
REMARK   3   NUMBER OF REFLECTIONS             : 17099                          
REMARK   3                                                                      
REMARK   3                                                                      
REMARK   3  FIT TO DATA USED IN REFINEMENT.                                     
REMARK   3   CROSS-VALIDATION METHOD          : THROUGHOUT                      
REMARK   3   FREE R VALUE TEST SET SELECTION  : RANDOM                          
REMARK   3   R VALUE            (WORKING SET) : 0.201                           
REMARK   3   FREE R VALUE                     : 0.247                           
REMARK   3   FREE R VALUE TEST SET SIZE   (%) : 5.000                           
REMARK   3   FREE R VALUE TEST SET COUNT      : 855                             
REMARK   3   ESTIMATED ERROR OF FREE R VALUE  : NULL                            
REMARK   3                                                                      
... 

(file truncated here)


REMARK   4                                                                      
REMARK   4 1C1F COMPLIES WITH FORMAT V. 2.3, 09-JULY-1998                       
REMARK   7                                                                      
REMARK   7 >>> WARNING: CHECK REMARK 999 CAREFULLY                              
REMARK   8                                                                      
REMARK   8 SIDE-CHAINS OF SER123 AND LEU124 ARE MODELED AS ALTERNATIVE          
REMARK   8 CONFORMERS.                                                          
REMARK   9                                                                      
REMARK   9 SER1 IS ACETYLATED.                                                  
REMARK  10                                                                      
REMARK  10 TER                                                                  
REMARK  10  SER: THE N-TERMINAL RESIDUE WAS NOT OBSERVED                        
REMARK 100                                                                      
REMARK 100 THIS ENTRY HAS BEEN PROCESSED BY RCSB ON 07-MAR-1999.                
REMARK 100 THE RCSB ID CODE IS RCSB000566.                                      
REMARK 200                                                                      
REMARK 200 EXPERIMENTAL DETAILS                                                 
REMARK 200  EXPERIMENT TYPE                : X-RAY DIFFRACTION                  
REMARK 200  DATE OF DATA COLLECTION        : NULL                               
REMARK 200  TEMPERATURE           (KELVIN) : 291.0                              
REMARK 200  PH                             : 9.00                               
REMARK 200  NUMBER OF CRYSTALS USED        : 1                                  
REMARK 200                                                                      
REMARK 200  SYNCHROTRON              (Y/N) : Y                                  
REMARK 200  RADIATION SOURCE               : PHOTON FACTORY                     
REMARK 200  BEAMLINE                       : BL6A                               
REMARK 200  X-RAY GENERATOR MODEL          : NULL                               
REMARK 200  MONOCHROMATIC OR LAUE    (M/L) : M                                  
REMARK 200  WAVELENGTH OR RANGE        (A) : 1.00                               
REMARK 200  MONOCHROMATOR                  : NULL                               
REMARK 200  OPTICS                         : NULL                               
REMARK 200                                                                      
... 

(file truncated here)


REMARK 500                                                                      
REMARK 500 GEOMETRY AND STEREOCHEMISTRY                                         
REMARK 500 SUBTOPIC: COVALENT BOND ANGLES                                       
REMARK 500                                                                      
REMARK 500 THE STEREOCHEMICAL PARAMETERS OF THE FOLLOWING RESIDUES              
REMARK 500 HAVE VALUES WHICH DEVIATE FROM EXPECTED VALUES BY MORE               
REMARK 500 THAN 4*RMSD (M=MODEL NUMBER; RES=RESIDUE NAME; C=CHAIN               
REMARK 500 IDENTIFIER; SSEQ=SEQUENCE NUMBER; I=INSERTION CODE).                 
REMARK 500                                                                      
REMARK 500 STANDARD TABLE:                                                      
REMARK 500 FORMAT: (10X,I3,1X,A3,1X,A1,I4,A1,3(1X,A4,2X),12X,F5.1)              
REMARK 500                                                                      
REMARK 500 EXPECTED VALUES: ENGH AND HUBER, 1991                                
REMARK 500                                                                      
REMARK 500  M RES CSSEQI ATM1   ATM2   ATM3                                     
REMARK 500    HIS A  44   N   -  CA  -  C   ANGL. DEV. =-10.3 DEGREES           
REMARK 500    LEU A 132   CA  -  CB  -  CG  ANGL. DEV. = 12.5 DEGREES           
REMARK 700                                                                      
REMARK 700 SHEET                                                                
REMARK 700 DETERMINATION METHOD: AUTHOR-DETERMINED                              
REMARK 999                                                                      
REMARK 999 SEQUENCE                                                             
REMARK 999 LEU A 135 IS NOT PRESENT IN SEQUENCE DATABASE                        
REMARK 999                                                                      
DBREF  1C1F A    1   136  SWS    P26788   LEG_CONMY        1    135             
SEQADV 1C1F LEU A  135  SWS  P26788              SEE REMARK 999                 
SEQRES   1 A  136  SER GLY GLY LEU GLN VAL LYS ASN PHE ASP PHE THR VAL          
SEQRES   2 A  136  GLY LYS PHE LEU THR VAL GLY GLY PHE ILE ASN ASN SER          
SEQRES   3 A  136  PRO GLN ARG PHE SER VAL ASN VAL GLY GLU SER MET ASN          
SEQRES   4 A  136  SER LEU SER LEU HIS LEU ASP HIS ARG PHE ASN TYR GLY          
SEQRES   5 A  136  ALA ASP GLN ASN THR ILE VAL MET ASN SER THR LEU LYS          
SEQRES   6 A  136  GLY ASP ASN GLY TRP GLU THR GLU GLN ARG SER THR ASN          
SEQRES   7 A  136  PHE THR LEU SER ALA GLY GLN TYR PHE GLU ILE THR LEU          
SEQRES   8 A  136  SER TYR ASP ILE ASN LYS PHE TYR ILE ASP ILE LEU ASP          
SEQRES   9 A  136  GLY PRO ASN LEU GLU PHE PRO ASN ARG TYR SER LYS GLU          
SEQRES  10 A  136  PHE LEU PRO PHE LEU SER LEU ALA GLY ASP ALA ARG LEU          
SEQRES  11 A  136  THR LEU VAL LYS LEU GLU                                      
FORMUL   2  HOH   *81(H2 O1)                                                    
HELIX    1   1 GLY A   66  ASN A   68  5                                   3    
SHEET    1  S1 1 GLY A   3  VAL A   6  0                                        
SHEET    1  S2 1 PHE A 121  GLY A 126  0                                        
SHEET    1  S3 1 ARG A  29  GLY A  35  0                                        
SHEET    1  S4 1 LEU A  41  ASN A  50  0                                        
SHEET    1  S5 1 GLN A  55  THR A  63  0                                        
SHEET    1  S6 1 GLN A  74  SER A  76  0                                        
SHEET    1  F1 1 ALA A 128  GLU A 136  0                                        
SHEET    1  F2 1 PHE A  16  ILE A  23  0                                        
SHEET    1  F3 1 TYR A  86  TYR A  93  0                                        
SHEET    1  F4 1 LYS A  97  ILE A 102  0                                        
SHEET    1  F5 1 ASN A 107  PRO A 111  0                                        
CRYST1   94.340   36.920   40.540  90.00  90.00  90.00 P 21 21 2     4          
ORIGX1      1.000000  0.000000  0.000000        0.00000                         
ORIGX2      0.000000  1.000000  0.000000        0.00000                         
ORIGX3      0.000000  0.000000  1.000000        0.00000                         
SCALE1      0.010600  0.000000  0.000000        0.00000                         
SCALE2      0.000000  0.027085  0.000000        0.00000                         
SCALE3      0.000000  0.000000  0.024667        0.00000                         
ATOM      1  N   GLY A   2       1.888  -8.251  -2.511  1.00 36.63           N  
ATOM      2  CA  GLY A   2       2.571  -8.428  -1.248  1.00 33.02           C  
ATOM      3  C   GLY A   2       2.586  -7.069  -0.589  1.00 30.43           C  
ATOM      4  O   GLY A   2       2.833  -6.107  -1.311  1.00 33.27           O  
ATOM      5  N   GLY A   3       2.302  -6.984   0.693  1.00 24.67           N  
ATOM      6  CA  GLY A   3       2.176  -5.723   1.348  1.00 18.88           C  
ATOM      7  C   GLY A   3       0.700  -5.426   1.526  1.00 16.58           C  
ATOM      8  O   GLY A   3      -0.187  -6.142   1.010  1.00 12.47           O  
ATOM      9  N   LEU A   4       0.494  -4.400   2.328  1.00 15.00           N  
... 

(file truncated here)


ATOM   1078  CG  GLU A 136      -0.873   9.368  16.046  1.00 38.96           C  
ATOM   1079  CD  GLU A 136      -0.399   9.054  17.456  1.00 44.66           C  
ATOM   1080  OE1 GLU A 136       0.789   8.749  17.641  1.00 47.97           O  
ATOM   1081  OE2 GLU A 136      -1.236   9.099  18.361  1.00 47.75           O  
ATOM   1082  OXT GLU A 136       0.764  12.146  12.712  1.00 26.22           O  
TER    1083      GLU A 136                                                      
HETATM 1084  O   HOH   200      -1.905  -7.624   2.822  1.00 14.50           O  
HETATM 1085  O   HOH   201      -8.374   7.981   9.202  1.00 20.77           O  
HETATM 1086  O   HOH   202      -4.047   9.199  11.632  1.00 38.24           O  
HETATM 1087  O   HOH   203       6.172  14.210   8.483  1.00 14.50           O  
HETATM 1088  O   HOH   204       2.903   7.804  15.329  1.00 24.51           O  
HETATM 1089  O   HOH   205      16.654   0.676  11.968  1.00 10.49           O  
... 

(file truncated here)


HETATM 1157  O   HOH   286       6.960  14.840  -3.025  1.00 35.59           O  
HETATM 1158  O   HOH   287      -3.222  10.410   7.061  1.00 38.91           O  
HETATM 1159  O   HOH   288      28.306   0.551   4.876  1.00 52.13           O  
HETATM 1160  O   HOH   290      21.506 -12.424   9.751  1.00 31.68           O  
HETATM 1161  O   HOH   291      12.951  10.424  -7.324  1.00 46.10           O  
HETATM 1162  O   HOH   292      18.119 -15.184  14.793  1.00 56.82           O  
HETATM 1163  O   HOH   293      13.501  22.220   8.216  1.00 43.30           O  
HETATM 1164  O   HOH   294      13.916 -11.387   9.695  1.00 47.13           O  
MASTER      240    0    0    1   11    0    0    6 1163    1    0   11          
END                                                                  
\end{lstlisting}

PDB文件非常长，主要是因为需要存储分子中每个原子的信息。这还算是一个相对简短的例子，如果全部列出来，它会非常长——有28页纸之多。此处，我把它截取了一下，缩减到了三页纸多点，把主要的部分全部都展示了出来，让你能有一个大体上的了解。

PDB网站上有基本的文档，当你阅读PDB文件并且编程处理它们的时候，你会需要这个文档的。PDB内容指南（Protein Data Bank Contents Guide，\href{http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2\_frame.html}{http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2\_frame.html}）可以说是最好的参考资料，里面有FAQs和一些额外的文档。 

在接下来的小节里，我会从这些文件中提取信息。因为这些文件描述的主要是大分子3D结构的信息，所以这些文件通常被图形程序所使用，来展示分子的空间结构。本书所讨论的范围并不包括图形，尽管如此，你还是将会看到如何从这些文件中提取出空间坐标。PDB文件中最大的一部分是包含原子坐标的ATOM记录类型行。因为这样详细的程度，PDB文件通常都比GenBank记录要长。（注意术语上的不一致——PDB的基本单元就是文件，它包含了一个结构；而GenBank的基本单元是记录，它包含了一个条目。）

\subsection{PDB文件格式}
让我们看一个PDB文件，文档告诉了我们PDB文件中的信息是如何组织的。基于这些信息，你可以解析文件，从中提取出你感兴趣的信息。

PDB文件有含有80列的多行组成，每一行都以某个预定义的记录名起始，以换行符终止。（“列“表示一行中的位置：第一个字符在第一列上，以此类推。）空列用空白填充。一个\textit{记录类型}是有相同记录名的一行或多行。不同的记录类型有在行中定义的不同类型字段。它们也据功能进行分组。

SEQRES记录类型是一级结构部分（Primary Structure Section）中的四大记录类型之一，它描述了肽或核苷酸序列的一级结构：

\textcolor{red}{\textit{DBREF}}
\begin{adjustwidth}{1cm}{}
指向序列数据库中的记录
\end{adjustwidth}

\textcolor{red}{\textit{SEQADV}}
\begin{adjustwidth}{1cm}{}
记录PDB与其他序列数据库的冲突
\end{adjustwidth}

\textcolor{red}{\textit{SEQRES}}
\begin{adjustwidth}{1cm}{}
骨干残基的一级序列
\end{adjustwidth}

\textcolor{red}{\textit{MODRES}}
\begin{adjustwidth}{1cm}{}
记录标准残基上的修饰
\end{adjustwidth}

上一节的PDB记录例子中的DBREF和SEQADV记录类型，给出了参考信息，以及PDB和原始数据库之间的冲突细节。（例子中不包含MODRES记录类型。）下面是这个记录中的这些记录类型：

\begin{lstlisting}
DBREF  1C1F A    1   136  SWS    P26788   LEG_CONMY        1    135             
SEQADV 1C1F LEU A  135  SWS  P26788              SEE REMARK 999 
\end{lstlisting}

简单来说，DBREF行声明有一个叫做\textit{1C1F}的PDB文件（来自于叫做\textit{pdb1c1f.ent}的文件），在原始的Swiss-Prot（SWS）数据库中A链的残基从1开始编号一直到136，在那个数据中它的ID号为P26788，名字为LEG\_CONMY（在许多数据库中这些都是一样的），在PDB数据库中残基从1开始编号到135。原始数据库和PDB编号上的差异在SEQADV记录类型中进行了解释，它让你参考REMARK的999行（此处未显示），在那里你会发现PDB记录对于Swiss-Prot序列上第135位的亮氨酸有歧义（也许这是两个不同小组测定的结构，它们在这个位点上有分歧）。\footnote{在老的PDB文件中，不同数据库的交叉引用是一个问题：它可能缺失，或者隐藏在REMARK的999行的某个地方。} 

你可以看到，要通过程序解析这两行的信息，需要好几步，比如跟随到达PDB记录其他行的链接，它会进一步解释重复，并且识别其他的数据库。

在生物信息学中，数据库之间的链接是非常重要的。\autoref{tab:table11.1}展示了PDB文件中参考的数据库。如你所知，有许多的生物学数据库，这儿展示的主要是和蛋白质或者结构数据相关的数据库。

\begin{table}[!htbp]
  \begin{center}
  \caption{PDB文件中参考的数据库}
  \label{tab:table11.1}
  \begin{tabu} to 0.6\linewidth {X[3,l]X[1,l]}
  \toprule
  Database & PDB code\\
  \midrule
  BioMagResBank & BMRB \\
  BLOCKS & BLOCKS\\
  European Molecular Biology Laboratory & EMBL\\
  GenBank & GB\\
  Genome Data Base & GDB\\
  Nucleic Acid Database & NDB\\
  PROSITE & PROSIT\\
  Protein Data Bank & PDB\\
  Protein Identification Resource & PIR\\
  SWISS-PROT & SWS\\
  TREMBL & TREMBL\\
  \bottomrule
  \end{tabu}
  \end{center}
\end{table}

\subsection{SEQRES}
刚刚起步，我们先用Perl来尝试一个相对简单的任务：提取氨基酸序列数据。要提取氨基酸的一级序列信息，你需要解析SEQRES记录类型。下面是先前那个PDB文件中的SEQRES行：

\begin{lstlisting}
SEQRES   1 A  136  SER GLY GLY LEU GLN VAL LYS ASN PHE ASP PHE THR VAL
\end{lstlisting}

下面展示了PDB内容指南中定义的SEQRES记录类型。SEQRES部分，是一个相对简单的记录类型，它的定义被全部展示了出来，帮助你熟悉一下这种文档。

\begin{lstlisting}
SEQRES 
 
Overview 

SEQRES records contain the amino acid or nucleic acid sequence of residues in
each chain of the 
macromolecule that was studied. 

Record Format 

COLUMNS        DATA TYPE       FIELD         DEFINITION                           
---------------------------------------------------------------------------------
 1 -  6        Record name     "SEQRES"                                           

 9 - 10        Integer         serNum        Serial number of the SEQRES record   
                                             for the current chain.  Starts at 1  
                                             and increments by one each line.     
                                             Reset to 1 for each chain.           

12             Character       chainID       Chain identifier.  This may be any   
                                             single legal character, including a  
                                             blank which is used if there is      
                                             only one chain.                      

14 - 17        Integer         numRes        Number of residues in the chain.     
                                             This value is repeated on every      
                                             record.                              

20 - 22        Residue name    resName       Residue name.                        

24 - 26        Residue name    resName       Residue name.                        

28 - 30        Residue name    resName       Residue name.                        

32 - 34        Residue name    resName       Residue name.                        

36 - 38        Residue name    resName       Residue name.                        

40 - 42        Residue name    resName       Residue name.                        

44 - 46        Residue name    resName       Residue name.                        

48 - 50        Residue name    resName       Residue name.                        

52 - 54        Residue name    resName       Residue name.                        

56 - 58        Residue name    resName       Residue name.                        

60 - 62        Residue name    resName       Residue name.                        

64 - 66        Residue name    resName       Residue name.                        

68 - 70        Residue name    resName       Residue name.                        

Details 

* PDB entries use the three-letter abbreviation for amino acid names and the
  one-letter code for nucleic acids. 

* In the case of non-standard groups, a hetID of up to three (3) alphanumeric
  characters is used. Common HET names appear in the HET dictionary. 

* Each covalently contiguous sequence of residues (connected via the "backbone"
  atoms) is represented as an individual chain. 

* Heterogens which are integrated into the backbone of the chain are listed as
  being part of the chain and are included in the SEQRES records for that chain. 

* Each set of SEQRES records and each HET group is assigned a component number.
  The component number is assigned serially beginning with 1 for the first set
  of SEQRES records. This number is given explicitly in the FORMUL record, but
  only implicitly in the SEQRES record. 

* The SEQRES records must list residues present in the molecule studied, even
  if the coordinates are not present. 

* C- and N-terminus residues for which no coordinates are provided due to
  disorder must be listed on SEQRES. 

* All occurrences of standard amino or nucleic acid residues (ATOM records)
  must be listed on a SEQRES record. This implies that a numRes of 1 is valid. 

* No distinction is made between ribo- and deoxyribonucleotides in the SEQRES
  records. These residues are identified with the same residue name (i.e., A,
  C, G, T, U, I). 

* If the entire residue sequence is unknown, the serNum in column 10 is "0",
  the number of residues thought to comprise the molecule is entered as numRes
  in columns 14 - 17, and resName in columns 20 - 22 is "UNK". 

* In case of microheterogeneity, only one of the sequences is presented. A
  REMARK is generated to explain this and a SEQADV is also generated. 

Verification/Validation/Value Authority Control 

The residues presented on the SEQRES records must agree with those found in
the ATOM records. 

The SEQRES records are checked by PDB using the sequence databases and
information provided by the depositor. 

SEQRES is compared to the ATOM records during processing, and both are checked
against the sequence database. All discrepancies are either resolved or
annotated in the entry. 

Relationships to Other Record Types 

The residues presented on the SEQRES records must agree with those found in
the ATOM records. DBREF refers to the corresponding entry in the sequence
databases. SEQADV lists all discrepancies between the entry's sequence for
which there are coordinates and that referenced in the sequence database.
MODRES describes modifications to a standard residue. 

Example 

         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890
SEQRES   1 A   21  GLY ILE VAL GLU GLN CYS CYS THR SER ILE CYS SER LEU
SEQRES   2 A   21  TYR GLN LEU GLU ASN TYR CYS ASN                    
SEQRES   1 B   30  PHE VAL ASN GLN HIS LEU CYS GLY SER HIS LEU VAL GLU
SEQRES   2 B   30  ALA LEU TYR LEU VAL CYS GLY GLU ARG GLY PHE PHE TYR
SEQRES   3 B   30  THR PRO LYS ALA                                    
SEQRES   1 C   21  GLY ILE VAL GLU GLN CYS CYS THR SER ILE CYS SER LEU
SEQRES   2 C   21  TYR GLN LEU GLU ASN TYR CYS ASN                    
SEQRES   1 D   30  PHE VAL ASN GLN HIS LEU CYS GLY SER HIS LEU VAL GLU
SEQRES   2 D   30  ALA LEU TYR LEU VAL CYS GLY GLU ARG GLY PHE PHE TYR
SEQRES   3 D   30  THR PRO LYS ALA                                    

Known Problems 

Polysaccharides do not lend themselves to being represented in SEQRES. 

There is no mechanism provided to describe sequence runs when the exact
ordering of the sequence is not known. 

For cyclic peptides, PDB arbitrarily assigns a residue as the N-terminus. 

For microheterogeneity only one of the possible residues in a given position
is provided in SEQRES. 

No distinction is made between ribo- and deoxyribonucleotides in the SEQRES
records. These residues are identified with the same residue name (i.e., A,
C, G, T, U). 
\end{lstlisting}

这行的结构包括显而易见的SEQRES记录类型，以及指定给航中特定位置或者列的字段。稍后你会看到如何利用这些位置来解析信息。注意，文档中包含了大量的细节，当你处理这样复杂的实验数据时可能会需要。

除了序列不断积累这个还算标准的问题外，多链会让它更加复杂。通过阅读刚才展示的文档，你会看到在SEQRES这个识别符后面，还有一个表示这条链的行数的数字，接下来的字段就是链信息（尽管在老的记录中，它是可选的，并且很可能会空着）。在这些字段后是表示链中残基总数的一个数字。最后，在这些内容之后，使用三字母代码表示的残基。为了实现我们的编程目的，哪些信息是需要的，哪些又可以被忽略掉呢？

\section{解析PDB文件}
首先，\autoref{exam:example11.5}演示了主程序和三个子程序，在本节将会对它们进行讨论。

\textbf{例11-5：从PDB文件中提取序列链}
\lstinputlisting[label=exam:example11.5]{./scripts/example11-5.pl}

一定要注意这一点，调用读取PDB文件的子程序\verb|get_file_data|的主程序中，包含了一个对于大的PDB文件的警告。（比如，PDB文件\textit{1gav}就有3.45
MB之大。）另外，主程序中，把整个文件读取进来之后，子程序\verb|parsePDBrecordtypes|把输入文件中的所有行都进行了拷贝，用记录类型分隔开。在这一点上，程序运行时会占用文件大小两倍大的内存空间。这种设计的有点在于它的清晰化和模块化，但主内存不够用的时候它也会导致问题。如果不保存从文件中读取进来的结果，而是直接把文件数据传递给\verb|parsePDBrecordtypes|子程序，这样占用的内存会小一些，就想这样：

\begin{lstlisting}
# Get the file data and parse the record types of the PDB file
%recordtypes = parsePDBrecordtypes(get_file_data('pdb/c1/pdb1c1f.ent'));
\end{lstlisting}

进一步节省内存也是可能的。比如，你可以重写程序，让它在把数据解析成记录类型的时候一次只读入文件的一行。我之所以指出这一点，是让你明白在处理大文件的时候，有许多种选择，这在实践中是非常重要的。尽管如此，现在我们还是坚持刚才的设计。这样可能比较耗费内存，但却让整个程序结构更加清晰明了。

在\autoref{chap:chapter10}中，我演示了两种方法，把GenBank文件解析成序列和注释，之后又把注释一层层得解析出来。

第一种方法是循环处理存储着记录行的数据。回忆一下，因为多行字段的结构，当循环的时候我们需要设置一个标识来记录输入行处于那个字段中。\footnote{在GenBank中，多行信息集叫做字段；在PDB中，它们叫做记录类型。就像在生物学中，不同的研究人员可能会使用他们自己的术语来描述结构或者概念一样，在计算机科学中，大家对术语也有一定的创造性。这也是整合生物学数据资源时存在的比较有趣的困难之一。}

另外一种方法，更加适用于GenBank文件，使用的正则表达式。哪种方法对于PDB文件最适合呢？（又或者你探索一下第三种方法？）

有好多方法可以提取出这个信息。PDB使得收集记录类型比较容易，因为它们在行首都起始于同样的关键字。在上一章中，使用的正则表达式这种技术来解析文件顶层的字段，这种方法对于PDB文件来说略显笨重。（参看本章末尾的练习题。）比如，下面的这个匹配所有临近SEQRES行的正则表达式可以它们整合进一个标量字符串中：

\begin{lstlisting}
$record =~ /SEQRES.*\n(SEQRES.*\n)*/;
$seqres = $&;
\end{lstlisting}

正则表达式使用\verb|SEQRES.*\n|匹配单独的SEQRES行，然后使用\verb|(SEQRES.*\n)*|匹配零行或者多行附加行。注意最后的\verb|*|表明匹配前面的项目零次或者多次，也就是用小括号括起来的表达式\verb|(SEQRES.*\n)|。此外，还要注意\verb|.*|匹配另个或者多个非换行符字符。最后，第二行把用\verb|$&|表示的匹配到的模式捕获起来，保存到了变量\verb|$seqres|中。

要扩充它来捕获所有的记录类型，可以参看本章末尾的练习题。

对于PDB文件来说，每一行都起始于一个关键字，明确表明了该行属于哪种记录类型。在文档中，你会发现，在每一组中，每一种记录类型的行都彼此相邻。在这种情况下，简单的对所有行进行重复收集记录类型，这看起来是最简单的编程策略了。

\autoref{exam:example11.5}包含一个叫做\textit{parsePDBrecordtypes}的子程序，它从包含PDB记录行的数组中解析PDB记录类型。这是一个简洁的程序，它可以完成它需要完成的工作。注释对发生的事情进行了很好地描述，如你所知，对于编写好的代码来说注释是至关重要的一个因素。简单来说，对每一行的记录类型进行检查，然后把它添加到散列的值里面去，散列的键是记录类型。最后，散列从子程序中返回出来。

\subsection{提取一级序列}
既然记录类型已经被解析出来了，就让我们看看子程序\textit{extractSEQRES}是如何提取一级氨基酸序列的。

你需要把每条链单独提取出来，返回对应这些链的一个或多个序列字符串的一个数组，而不是仅仅一条序列。

\autoref{exam:example11.4}中前面的解析，只把需要的SEQRES记录类型保留了下来，它包含多行内容，以单个标量字符串的形式存储为散列的值，其对应的键为`\verb|SEQRES|'。先前对行进行循环处理（与对多行字符串使用正则表达式不同）的\textit{parsePDBrecordtypes}子程序的成功导致了此处同样的方法。Perl函数\textit{split}可以让你把一个多行的字符串转换成一个数组。

在对SEQRES记录类型中的行进行循环处理的时候，注意，当一个新的链开始时，会把先前的链保存到数组\verb|@results|中，重置变量\verb|$sequence|，同时也把\verb|$lastchain|标识重置为新的链。此外，当处理完所有的行后，要确保把最后的序列链保存进\verb|@results|数组。

还要注意（查阅这个函数的Perl文档进行确认），根据你给它的参数，\textit{split}会完成你所期望的工作。

\autoref{exam:example11.5}中的第三个也是最后一个子程序叫做\textit{iub3to1}。因为PDB中的序列信息使用三字母进行编码的，所以你需要这个子程序来把这些序列转变成单字母编码的形式。它直截了当的使用了一个散列查找来完成这个转换。

我们现在已经把问题分解成了几个互相协作的子程序。如何最优得把一个问题分解成协作的子程序，这总是非常有趣。你可以把\textit{iub3to1}的调用放在\textit{extractSEQRES}子程序里面，这可能是把这些子程序组合在一起的一个比较简洁明了的方法，毕竟，除了PDB文件格式，你很可能不会用到三字母编码的氨基酸字符串。

在这个关口，最重要的一个论点就是需要指出，在一个简短的主程序中把几个简短的子程序组合起来，足够来完成解析PDB文件这样复杂的任务了。

\subsection{Finding Atomic Coordinates}
So far, I've tried not to give more than a very brief overview of protein structure. However, in parsing PDB files, you will be faced with a great deal of detailed information about the structures and the experimental conditions under which they were determined. I will now present a short program that extracts the coordinates of atoms in a PDB file. I don't cover the whole story: for that, you will want to read the PDB documentation in detail and consult texts on protein structure, X-ray crystallography, and NMR techniques.

That said, let's extract the coordinates from the ATOM record type. ATOM record types are the most numerous of the several record types that deal with atomic-coordinate data: MODEL, ATOM, SIGATM, ANISOU, SIGUIJ, TER, HETATM, and ENDMDL. There are also several record types that handle coordinate transformation: ORIGXn, SCALEn, MTRIXn, and TVECT.

Here is part of the PDB documentation that shows the field definitions of each ATOM record: 

\begin{lstlisting}
ATOM 

Overview 

The ATOM records present the atomic coordinates for standard residues.
They also present the occupancy and temperature factor for each atom.
Heterogen coordinates use the HETATM record type. The element symbol
is always present on each ATOM record; segment identifier and charge
are optional. 

Record Format 

COLUMNS        DATA TYPE       FIELD         DEFINITION                            
---------------------------------------------------------------------------------
 1 -  6        Record name     "ATOM  "                                            

 7 - 11        Integer         serial        Atom serial number.                   

13 - 16        Atom            name          Atom name.                            

17             Character       altLoc        Alternate location indicator.         

18 - 20        Residue name    resName       Residue name.                         

22             Character       chainID       Chain identifier.                     

23 - 26        Integer         resSeq        Residue sequence number.              

27             AChar           iCode         Code for insertion of residues.       

31 - 38        Real(8.3)       x             Orthogonal coordinates for X in       
                                             Angstroms.                       

39 - 46        Real(8.3)       y             Orthogonal coordinates for Y in       
                                             Angstroms.                            

47 - 54        Real(8.3)       z             Orthogonal coordinates for Z in       
                                             Angstroms.                            

55 - 60        Real(6.2)       occupancy     Occupancy.                            

61 - 66        Real(6.2)       tempFactor    Temperature factor.                   

73 - 76        LString(4)      segID         Segment identifier, left-justified.   

77 - 78        LString(2)      element       Element symbol, right-justified.      

79 - 80        LString(2)      charge        Charge on the atom.       
\end{lstlisting}

Here is a typical ATOM line:

\begin{lstlisting}
ATOM      1  N   GLY A   2       1.888  -8.251  -2.511  1.00 36.63           N  
\end{lstlisting}

Let's do something fairly simple: let's extract all x, y, and z coordinates for each atom, plus the serial number (a unique integer for each atom in the molecule) and the element symbol. \autoref{exam:example11.6} is a subroutine that accomplishes that, with a main program to exercise the subroutine. 

\textbf{Example 11-6. Extract atomic coordinates from PDB file}
\lstinputlisting[label=exam:example11.6]{./scripts/example11-6.pl}

The \textit{parseATOM} subroutine is quite short: the strict format of these ATOM records makes parsing the information quite straightforward. You first split the scalar argument, which contains the ATOM lines, into an array of lines.

Then, for each line, use the \verb|substr| function to extract the specific columns of the line that contains the needed data: the serial number of the atom; the x, y, and z coordinates; and the element symbol.

Finally, save the results by making a hash with keys equal to the serial numbers and values set to strings containing the other four relevant fields. Now, this may not always be the most convenient way to return the data. For one thing, hashes are not sorted on the keys, so that would need to be an additional step if you had to sort the atoms by serial number. In particular, an array is a logical choice to store information sorted by serial number. Or, it could be that what you really want is to find all the metals, in which case, another data structure would be suggested. Nevertheless, this short subroutine shows one way to find and report information.

It often happens that what you really need is a reformatting of the data for use by another program. Using the technique of this subroutine, you can see how to extract the needed data and add a \verb|print| statement that formats the data into the desired form. Take a look at the \textit{printf} and \textit{sprintf} functions to get more specific control over the format. For real heavy-duty formatting, there's the \textit{format} function, which merits its own chapter in O'Reilly's comprehensive \textit{Programming Perl}. (See also \autoref{chap:chapter12} and \autoref{chap:chapterab} of this book.)

Here's the output from \autoref{exam:example11.6}:

\begin{lstlisting}
 1.888   -8.251   -2.511  N
18.955  -10.180   10.777  C
\end{lstlisting}

You can now extract at least the major portion of the atomic coordinates from a PDB file. Again, notice the good news: it doesn't take a long or particularly complex program to do what is needed.

This program has been designed so that its parts can be used in the future to work well for other purposes. You parse all record types, for instance, not only the ATOM record types. Let's take a look at a very short program that just parses the ATOM record type lines from an input file; by targeting only this one problem, you can write a much shorter program. Here's the program: 

\begin{lstlisting}
while(<>) {
  /^ATOM/ or next;

  my($n, $x, $y, $z, $element)
    = ($_ =~ /^.{6}(.{5}).{19}(.{8})(.{8})(.{8}).{22}(..)/);

  # $n and $element may have leading spaces: strip them
  $n      =~ s/^\s*//;
  $element =~ s/^\s*//;

  if (($n == 1) or ($n == 1078)) {
    printf "%8.3f%8.3f%8.3f %2s\n", $x, $y, $z, $element;
  }
}
\end{lstlisting}

For each line, a regular-expression match extracts just the needed information. Recall that a regular expression that contains parentheses metacharacters returns an array whose elements are the parts of the string that matched within the parentheses. You assign the five variables \verb|$number|, \verb|$x|, \verb|$y|, \verb|$z|, and \verb|$element| to the substrings from these matched parentheses.

The actual regular expression is simply using dots and the quantifier operator \verb|.{num}| to stand for num characters. In this way, you can, starting from the beginning of the string as represented by the caret \verb|^| metacharacter, specify the columns with the information you want returned by surrounding them with parentheses.

For instance, you don't want the first six characters, so you specify them as \verb|^.{6}|, but you do want the next five characters because they contain the serial number of the atom; so, specify that field as \verb|(.{5})|.

Frankly, I think that the use of \verb|substr| is clearer for this purpose, but I wanted to show you an alternative way using regular expressions as well.

We've already seen the use of the \verb|printf| function to format output with more options then with the \verb|print| function.

This program has another important shortcut. It doesn't specify the file to open and read from. In Perl, you can give the input filename on the command line (or drag and drop it onto a Mac droplet), and the program takes its input from that file. Just use the angle brackets as shown in the first line of the program to read from the file. For short, fast programs, such as the one demonstrated here, this is a great convenience. You can leave out all the calls and tests for success of the \verb|open| function and just use the angle brackets. You would call it from the command line like so, assuming you saved the program in a file called \textit{get\_two\_atoms}: 

\begin{lstlisting}
%perl get_two_atoms pdb1a4o.ent
\end{lstlisting}

Alternatively, you can pipe data to the program with the commands:

\begin{lstlisting}
% cat pdb1a40.cat | perl get_two_atoms
\end{lstlisting}

or:

\begin{lstlisting}
% perl get_two__atoms < pdb1a40.ent 
\end{lstlisting}

and use \verb|<STDIN>| instead of \verb|<>| in your program to read the data. 

\section{Controlling Other Programs}
Perl makes it easy to start other programs and collect their output, all from within your Perl program. This is an extremely useful capability; for most programs, Perl makes it fairly simple to accomplish.

You may need to run some particular program many times, for instance over every file in PDB to extract secondary structure information. The program itself may not have a way to tell it "run yourself over all these files." Also, the output of the program may have all sorts of extraneous information. What you need is a much simpler report that just presents the information that interests you—perhaps in a format that could then be input to another program! With Perl you can write a program to do exactly this.

An important kind of program to automate is a web site that provides some useful program or data online. Using the appropriate Perl modules, you can connect to the web site, send it your input, collect the output, and then parse and reformat as you wish. It's actually not hard to do!  O'Reilly's \textit{Perl Cookbook}, a companion volume to \textit{Programming Perl}, is an excellent source of short programs and helpful descriptions to get you started.

Perl is a great way to automate other programs. The next section shows an example of a Perl program that starts another program and collects, parses, reformats, and outputs the results. This program will control another program on the same computer. The example will be from a Unix or Linux environment; consult your Perl documentation on how to get the same functionality from your Windows or Macintosh platform. 

\subsection{The Stride Secondary Structure Predictor}
We will use an external program to calculate the secondary structure from the 3D coordinates of a PDB file. As a secondary structure assignment engine, I use a program that outputs a secondary structure report, called \textit{stride}. \textit{stride} is available from EMBL (\href{http://www.embl-heidelberg.de/stride/stride\_info.html}{http://www.embl-heidelberg.de/stride/stride\_info.html}) and runs on Unix, Linux, Windows, Macintosh, and VMS systems. The program works very simply; just give it a command-line argument of a PDB filename and collect the output in the subroutine \textit{call\_stride} that follows.

\autoref{exam:example11.7} is the entire program: two subroutines and a main program, followed by a discussion. 

\textbf{Example 11-7. Call another program for secondary structure prediction}
\lstinputlisting[label=exam:example11.7]{./scripts/example11-7.pl}

As you can see in the subroutine \textit{call\_stride}, variables have been made for the program name (\verb|$stride|) and for the options you may want to pass (\verb|$options|). Since these are parts of the program you may want to change, put them as variables near the top of the code, to make them easy to find and alter. The argument to the subroutine is the PDB filename (\verb|$filename|). (Of course, if you expect the options to change frequently, you can make them another argument to the subroutine.)

Since you're dealing with a program that takes a file, do a little error checking to see if a file by that name actually exists. Use the \verb|-e| file test operator. Or you can omit this and let the \textit{stride} program figure it out, and capture its error output. But that requires parsing the stride output for its error output, which involves figuring out how \textit{stride} reports errors. This can get complicated, so I'd stick with using the \verb|-e| file test operator.

The actual running of the program and collecting its output happens in just one line. The program to be run is enclosed in backticks, which run the program (first expanding variables) and return the output as an array of lines.

There are other ways to run a program. One common way is the system function call. It behaves differently from the backticks: it doesn't return the output of the command it calls (it just returns the exit status, an integer indicating success or failure of the command). Other methods include \textit{qx}, the \textit{open} system call, and the \textit{fork} and \textit{exec} functions. 

\subsection{Parsing Stride Output}
I don't go into too much detail here about parsing the output of \textit{stride}. Let's just exhibit some code that extracts the primary sequence and the secondary structure prediction. See the exercises at the end of the chapter for a challenge to extract the secondary structure information from a PDB file's HELIX, SHEET, and TURN record types and output the information in a similar format as \textit{stride} does here.
  
Here is a typical section of a \textit{stride} output (not the entire output):

\begin{lstlisting}
SEQ  1    MDKNELVQKAKLAEQAERYDDMAACMKSVTEQGAELSNEERNLLSVAYKN   50          1A4O
STR         HHHHHHHHHHHHHH  HHHHHHHHHHHHHTTT   HHHHHHHHHHHHH               1A4O
REM                                                                        1A4O
REM                .         .         .         .         .               1A4O
SEQ  51   VVGARRSSWRVVSSIEQKEKKQQMAREYREKIETELRDICNDVLSLLEKF  100          1A4O
STR       HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHT               1A4O
REM                                                                        1A4O
REM                .         .         .         .         .               1A4O
SEQ  101  LIPNAAESKVFYLKMKGDYYRYLAEVAAGDDKKGIVDQSQQAYQEAFEIS  150          1A4O
STR       TTTTT HHHHHHHHHHHHHHHHHHHH   HHHHHHHHHHHHHHHHHHHHH               1A4O
REM                                                                        1A4O
REM                .         .         .         .                         1A4O
SEQ  151  KKEMIRLGLALNFSVFYYACSLAKTAFDEAIAELLIMQLLRDNLTLW     197          1A4O
STR       TTTTHHHHHHHHHHHH   HHHHHHHHHHHHH  HHHHHHHHHH                     1A4O
\end{lstlisting}

Notice that each line is prefaced by an identifier, which should make collecting the different record types easy. Without even consulting the documentation (a slightly dangerous but sometimes expedient approach), you can see that the primary sequence has keyword \verb|SEQ|, the structure prediction has keyword \verb|STR|, and the data of interest lies from position 11 up to position 60 on each line. (We'll ignore everything else for now.)

The following list shows the one-letter secondary structure codes used by \textit{stride}: 

\begin{table}[!htbp]
  \begin{center}
  \begin{tabu} to 0.5\linewidth {X[1,l]X[2,l]}
  \toprule
  H & Alpha helix\\
  G & 3-10 helix\\
  I & PI helix\\
  E & Extended conformation\\
  B or b& Isolated bridge\\
  T & Turn\\
  C & Coil (none of the above)\\
  \bottomrule
  \end{tabu}
  \end{center}
\end{table}

Using the \verb|substr| function, the two \verb|for| loops alter each line of the two arrays by saving the 11th to the 60th positions of those strings. This is where the desired information lies.

Now let's examine the subroutine \textit{parse\_stride} in \autoref{exam:example11.7} that takes \textit{stride} output and returns an array of two strings, the primary sequence and the structure prediction.

This is a very "Perlish" subroutine that uses some features that manipulate text. What's interesting is the brevity of the program, which some of Perl's built-in functions make possible.

First, you receive the output of the \textit{stride} program in the subroutine argument \verb|@_|. Next, use the \textit{grep} function to extract those lines of interest, which are easy to identify in this output, as they begin with clear identifiers \verb|SEQ| and \verb|STR|.  

Next, you want to save just those positions (or columns) of these lines that have the sequence or structure information; you don't need the keywords, position numbers, or the PDB entry name at the end of the lines.

Finally, join the arrays into single strings. Here, there's one detail to handle; you need to remove any unneeded spaces from the ends of the strings. Notice that \textit{stride} sometimes leaves spaces in the structure prediction, and in this example, has left some at the end of the structure prediction. So you shouldn't throw away all the spaces at the ends of the strings. Instead, throw away all the spaces at the end of the sequence string, because they are just superfluous spaces on the line. Now, see how many spaces that was, and throw the equal amount away at the end of the structure prediction string, thus preserving spaces that correspond to undetermined secondary structure.

\autoref{exam:example11.7} contains a main program that calls two subroutines, which, since they are short, are all included (so there's no need here for the \textit{BeginPerlBioinfo} module). Here's the output of \autoref{exam:example11.7}: 

\begin{lstlisting}
GGLQVKNFDFTVGKFLTVGGFINNSPQRFSVNVGESMNSLSLHLDHRFNYGADQNTIVMNSTLKGDNGWETEQRSTNFTL
    TTTTTTBTTT EEEEEEETTTT EEEEEEEEETTEEEEEEEEEEEETTEEEEEEEEEETTGGG B   EEE     
\end{lstlisting}

The first line shows the amino acids, and the second line shows the prediction of the secondary structure. Check the next section for a subroutine that will improve that output. 


\textcolor{red}{\textit{}}
\begin{adjustwidth}{1cm}{}

\end{adjustwidth}


\textbf{}
\lstinputlisting[label=exam:example11.1]{./scripts/example11-1.pl}



\section{Exercises}
\textcolor{red}{\textit{Exercise 11.1}}
\begin{adjustwidth}{1cm}{}
Use \textit{File::Find} and the file test operators to find the oldest and largest files on the hard drive of your computer. (You can delete them or store them elsewhere if you're running short on disk space.)
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.2}}
\begin{adjustwidth}{1cm}{}
Find all the Perl programs on your computer.

\textit{Hint}: Use \textit{File::Find}. What do all Perl programs have in common?
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.3}}
\begin{adjustwidth}{1cm}{}
Parse the HEADER, TITLE, and KEYWORDS record types of all PDB files on your computer. Make a hash with \textit{key} as a word from those record types and \textit{value} as a list of filenames that contained that word. Save it as a DBM file and build a query program for it. In the end, you should be able to ask for, say, sugar, and get a list of all PDB files that contain that word in the HEADER, TITLE, or KEYWORDS records.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.4}}
\begin{adjustwidth}{1cm}{}
Parse out the record types of a PDB file using regular expressions (as used in \autoref{chap:chapter10}) instead of iterating through an array of input lines (as in this chapter.) 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.5}}
\begin{adjustwidth}{1cm}{}
Write a program that extracts the secondary structure information contained in the HELIX, SHEET, and TURN record types of PDB files. Print out the secondary structure and the primary sequence together, so that it's easy to see by what secondary structure a given residue is included. (Consider using a special alphabet for secondary structure, so that every residue in a helix is represented by H, for example.)
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.6}}
\begin{adjustwidth}{1cm}{}
Write a program that finds all PDB files under a given folder and runs a program (such as \textit{stride}, or the program you wrote in Exercise 11.5) that reports on the secondary structure of each PDB file. Store the results in a DBM file keyed on the filename.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.7}}
\begin{adjustwidth}{1cm}{}
Write a subroutine that, given two strings, prints them out one over the other, but with line breaks (similar to the \textit{stride} program output). Use this subroutine to print out the strings from \autoref{exam:example11.7}. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.8}}
\begin{adjustwidth}{1cm}{}
Write a recursive subroutine to determine the size of an array. You may want to use the \verb|pop| or \verb|unshift| functions. (Ignore the fact that the \verb|scalar @array| returns the size of \verb|@array|!)
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.9}}
\begin{adjustwidth}{1cm}{}
Write a recursive subroutine that extracts the primary amino acid sequence from the SEQRES record type of a PDB file. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.10}}
\begin{adjustwidth}{1cm}{}
(\textit{Extra credit}) Given an atom and a distance, find all other atoms in a PDB file that are within that distance of the atom. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 11.11}}
\begin{adjustwidth}{1cm}{}
(\textit{Extra credit}) Write a program to find some correlation between the primary amino acid sequence and the location of alpha helices. 
\end{adjustwidth}

