\chapter{GenBank}
\label{chap:chapter10}
\minitoc

GenBank（Genetic Sequence Data Bank）是一个快速增长的国际性知识库，存储的是各种各样生物的已知遗传序列。它的使用对于现代生物学和生物信息学来说至关重要。

本章将向你展示如何编写Perl程序来从GenBank文件和库中提取信息。练习题包括查找模式、创建特定的库，以及解析平面文件格式来提取DNA、注释和特征。你将学习如何制作一个DBM数据库，实现自己在GenBank库中对特定数据进行快速的访问与查找。

Perl是处理GenBank文件的一个优秀的工具。它可以让你提取并使用序列以及FEATURES表和其他等注释中的任何细节性的数据。当我第一次使用Perl的时候，我编写了一个程序，检索GenBank中所有被注释为位于人类第22号染色体上的序列记录。我发现许多基因，它们的信息被深深地隐藏在了注释中，以至于GDB（Genome
Database）这个主要的基因图谱数据库都没有把它们包含在自己的染色体图谱中。我相信，当你开始应用Perl处理GenBank文件的时候，你也会对其中的信息有与我同样强烈的感觉。

大多数生物学家对GenBank都非常熟悉。研究人员可以进行检索，比如对于某个查询序列的BLAST检索，也可以把相关序列的一系列GenBank文件作为结果收集起来。因为GenBank记录是由发现序列的特定科学家进行维护的，所以如果你发现了某个新的有趣的序列，你也可以把它发布到GenBank上。

GenBank文件中除了序列数据以外，还有一大堆的信息，包括登录号和基因名这样的识别号、系谱分类和发表文献的参考信息等。一个GenBank文件可能还包含详细的FEATURES表，对序列的情况进行了总结，比如调控区域、蛋白质翻译以及外显子和内含子的定位区域。

GenBank有时被看做是\textit{数据银行（databank）}或者\textit{数据商店（data store）}，这和\textit{数据库（database）}有一定的区别。数据库通常给数据强加一个关系型的结构，包括相关的指数、链接和查询语言。相比之下，GenBank就是一个\textit{平面文件（flat file）}，换言之，就是一个对于人类易读的ASCII码文本文件。\footnote{GenBank也有ASN.1格式的发布，你需要使用NCBI提供特定工具才能对其进行处理。} 

从它毫不起眼的诞生之初，GenBank就开始了飞速增长，而在增长过程中平面文件则凸显了其不足之处。随着知识体的快速发展，尤其是像遗传数据这种知识的快速增长，要想让数据银行的这种设计与时俱进已经很难了。对GenBank进行重新整理设计的许多共组已经完成了，但是平面文件——顶着它逐渐褪色的皇冠——仍然存在着。

归咎于GenBank记录中某些小节内容的一定灵活性，从中提取要寻找的信息可能会比较复杂。这种灵活性有好的一面，它允许你把你认为是最重要的东西都放到数据的注释中；但同时它也有不好的一面，因为同样是灵活性，它会使编写程序来寻找并提取需要的注释信息变得更加困难。正因为如此，现在的趋势是让注释中的内容更具结构化。

Perl的数据结构和正则表达式的应用使得它成为处理平面文件的优秀工具，尤其适合用来处理GenBank数据。使用Perl的这些特性，基于前面章节训练的技能，你可以编写程序来访问GenBank中对于科学界来说日益积累的遗传知识。

因为这是本不需要编程经验的初学者指南书籍，所以你不要指望从中找到完美无瑕、包治百病的软件。与之相反，你会找到对于对于GenBank文件进行解析和构建快速查找表的详尽介绍。如果你还从没有做过类似的事情，我强烈推荐你去探索一下NIH（National Institutes of Health）（\href{http://www.ncbi.nlm.nih.gov}{http://www.ncbi.nlm.nih.gov}）的NCBI（National Center for Biotechnology Information）。当你开始之后，停止在 \href{http://www.ebi.ac.uk}{http://www.ebi.ac.uk} 的EBI（European Bioinformatics Institute）和 \href{http://www.embl-heidelberg.de/}{http://www.embl-heidelberg.de/} 的生物信息学分支EMBL（European Molecular Biology Laboratory）即可。它们都是大型的、由重金赞助支持的政府性的生物信息学中心，并且它们都有（并且发布了）大量的顶尖的生物信息学软件。

\section{GenBank文件}
主要的遗传信息库就是NCBI GenBank、欧洲的EMBL和日本的DDBJ（DNA Data Bank
of
Japan）。因为有国际合作协定，它们都有几乎完全相同的信息。GenBank或者它的镜像站点中的每一个条目或者记录都包含确定的描述性的遗传信息，存储在ASCII格式的文件中。每一个记录都用特定的标准格式进行编写与组织，这样不管是人还是计算机程序都可以比较容易地从中提取需要的信息。

让我们看一个相对较短的GenBank记录，在编写代码之前先看看字段是如何定义的。我会把这些信息保存在一个叫做\textit{record.gb}的文件中，便于后面程序的使用。

\begin{lstlisting}[language={},basicstyle=\small\tt,breaklines=false]
LOCUS       AB031069     2487 bp    mRNA            PRI       27-MAY-2000
DEFINITION  Homo sapiens PCCX1 mRNA for protein containing CXXC domain 1,
            complete cds.
ACCESSION   AB031069
VERSION     AB031069.1  GI:8100074
KEYWORDS    .
SOURCE      Homo sapiens embryo male lung fibroblast cell_line:HuS-L12 cDNA to
            mRNA.
  ORGANISM  Homo sapiens
            Eukaryota; Metazoa; Chordata; Craniata; Vertebrata; Euteleostomi;
            Mammalia; Eutheria; Primates; Catarrhini; Hominidae; Homo.
REFERENCE   1  (sites)
  AUTHORS   Fujino,T., Hasegawa,M., Shibata,S., Kishimoto,T., Imai,Si. and
            Takano,T.
  TITLE     PCCX1, a novel DNA-binding protein with PHD finger and CXXC domain,
            is regulated by proteolysis
  JOURNAL   Biochem. Biophys. Res. Commun. 271 (2), 305-310 (2000)
  MEDLINE   20261256
REFERENCE   2  (bases 1 to 2487)
  AUTHORS   Fujino,T., Hasegawa,M., Shibata,S., Kishimoto,T., Imai,S. and
            Takano,T.
  TITLE     Direct Submission
  JOURNAL   Submitted (15-AUG-1999) to the DDBJ/EMBL/GenBank databases.
            Tadahiro Fujino, Keio University School of Medicine, Department of
            Microbiology; Shinanomachi 35, Shinjuku-ku, Tokyo 160-8582, Japan
            (E-mail:fujino@microb.med.keio.ac.jp,
            Tel:+81-3-3353-1211(ex.62692), Fax:+81-3-5360-1508)
FEATURES             Location/Qualifiers
     source          1..2487
                     /organism="Homo sapiens"
                     /db_xref="taxon:9606"
                     /sex="male"
                     /cell_line="HuS-L12"
                     /cell_type="lung fibroblast"
                     /dev_stage="embryo"
     gene            229..2199
                     /gene="PCCX1"
     CDS             229..2199
                     /gene="PCCX1"
                     /note="a nuclear protein carrying a PHD finger and a CXXC
                     domain"
                     /codon_start=1
                     /product="protein containing CXXC domain 1"
                     /protein_id="BAA96307.1"
                     /db_xref="GI:8100075"
                     /translation="MEGDGSDPEPPDAGEDSKSENGENAPIYCICRKPDINCFMIGCD
                     NCNEWFHGDCIRITEKMAKAIREWYCRECREKDPKLEIRYRHKKSRERDGNERDSSEP
                     RDEGGGRKRPVPDPDLQRRAGSGTGVGAMLARGSASPHKSSPQPLVATPSQHHQQQQQ
                     QIKRSARMCGECEACRRTEDCGHCDFCRDMKKFGGPNKIRQKCRLRQCQLRARESYKY
                     FPSSLSPVTPSESLPRPRRPLPTQQQPQPSQKLGRIREDEGAVASSTVKEPPEATATP
                     EPLSDEDLPLDPDLYQDFCAGAFDDHGLPWMSDTEESPFLDPALRKRAVKVKHVKRRE
                     KKSEKKKEERYKRHRQKQKHKDKWKHPERADAKDPASLPQCLGPGCVRPAQPSSKYCS
                     DDCGMKLAANRIYEILPQRIQQWQQSPCIAEEHGKKLLERIRREQQSARTRLQEMERR
                     FHELEAIILRAKQQAVREDEESNEGDSDDTDLQIFCVSCGHPINPRVALRHMERCYAK
                     YESQTSFGSMYPTRIEGATRLFCDVYNPQSKTYCKRLQVLCPEHSRDPKVPADEVCGC
                     PLVRDVFELTGDFCRLPKRQCNRHYCWEKLRRAEVDLERVRVWYKLDELFEQERNVRT
                     AMTNRAGLLALMLHQTIQHDPLTTDLRSSADR"
BASE COUNT      564 a    715 c    768 g    440 t
ORIGIN      
        1 agatggcggc gctgaggggt cttgggggct ctaggccggc cacctactgg tttgcagcgg
       61 agacgacgca tggggcctgc gcaataggag tacgctgcct gggaggcgtg actagaagcg
      121 gaagtagttg tgggcgcctt tgcaaccgcc tgggacgccg ccgagtggtc tgtgcaggtt
      181 cgcgggtcgc tggcgggggt cgtgagggag tgcgccggga gcggagatat ggagggagat
      241 ggttcagacc cagagcctcc agatgccggg gaggacagca agtccgagaa tggggagaat
      301 gcgcccatct actgcatctg ccgcaaaccg gacatcaact gcttcatgat cgggtgtgac
      361 aactgcaatg agtggttcca tggggactgc atccggatca ctgagaagat ggccaaggcc
      421 atccgggagt ggtactgtcg ggagtgcaga gagaaagacc ccaagctaga gattcgctat
      481 cggcacaaga agtcacggga gcgggatggc aatgagcggg acagcagtga gccccgggat
      541 gagggtggag ggcgcaagag gcctgtccct gatccagacc tgcagcgccg ggcagggtca
      601 gggacagggg ttggggccat gcttgctcgg ggctctgctt cgccccacaa atcctctccg
      661 cagcccttgg tggccacacc cagccagcat caccagcagc agcagcagca gatcaaacgg
      721 tcagcccgca tgtgtggtga gtgtgaggca tgtcggcgca ctgaggactg tggtcactgt
      781 gatttctgtc gggacatgaa gaagttcggg ggccccaaca agatccggca gaagtgccgg
      841 ctgcgccagt gccagctgcg ggcccgggaa tcgtacaagt acttcccttc ctcgctctca
      901 ccagtgacgc cctcagagtc cctgccaagg ccccgccggc cactgcccac ccaacagcag
      961 ccacagccat cacagaagtt agggcgcatc cgtgaagatg agggggcagt ggcgtcatca
     1021 acagtcaagg agcctcctga ggctacagcc acacctgagc cactctcaga tgaggaccta
     1081 cctctggatc ctgacctgta tcaggacttc tgtgcagggg cctttgatga ccatggcctg
     1141 ccctggatga gcgacacaga agagtcccca ttcctggacc ccgcgctgcg gaagagggca
     1201 gtgaaagtga agcatgtgaa gcgtcgggag aagaagtctg agaagaagaa ggaggagcga
     1261 tacaagcggc atcggcagaa gcagaagcac aaggataaat ggaaacaccc agagagggct
     1321 gatgccaagg accctgcgtc actgccccag tgcctggggc ccggctgtgt gcgccccgcc
     1381 cagcccagct ccaagtattg ctcagatgac tgtggcatga agctggcagc caaccgcatc
     1441 tacgagatcc tcccccagcg catccagcag tggcagcaga gcccttgcat tgctgaagag
     1501 cacggcaaga agctgctcga acgcattcgc cgagagcagc agagtgcccg cactcgcctt
     1561 caggaaatgg aacgccgatt ccatgagctt gaggccatca ttctacgtgc caagcagcag
     1621 gctgtgcgcg aggatgagga gagcaacgag ggtgacagtg atgacacaga cctgcagatc
     1681 ttctgtgttt cctgtgggca ccccatcaac ccacgtgttg ccttgcgcca catggagcgc
     1741 tgctacgcca agtatgagag ccagacgtcc tttgggtcca tgtaccccac acgcattgaa
     1801 ggggccacac gactcttctg tgatgtgtat aatcctcaga gcaaaacata ctgtaagcgg
     1861 ctccaggtgc tgtgccccga gcactcacgg gaccccaaag tgccagctga cgaggtatgc
     1921 gggtgccccc ttgtacgtga tgtctttgag ctcacgggtg acttctgccg cctgcccaag
     1981 cgccagtgca atcgccatta ctgctgggag aagctgcggc gtgcggaagt ggacttggag
     2041 cgcgtgcgtg tgtggtacaa gctggacgag ctgtttgagc aggagcgcaa tgtgcgcaca
     2101 gccatgacaa accgcgcggg attgctggcc ctgatgctgc accagacgat ccagcacgat
     2161 cccctcacta ccgacctgcg ctccagtgcc gaccgctgag cctcctggcc cggacccctt
     2221 acaccctgca ttccagatgg gggagccgcc cggtgcccgt gtgtccgttc ctccactcat
     2281 ctgtttctcc ggttctccct gtgcccatcc accggttgac cgcccatctg cctttatcag
     2341 agggactgtc cccgtcgaca tgttcagtgc ctggtggggc tgcggagtcc actcatcctt
     2401 gcctcctctc cctgggtttt gttaataaaa ttttgaagaa accaaaaaaa aaaaaaaaaa
     2461 aaaaaaaaaa aaaaaaaaaa aaaaaaa
//
\end{lstlisting}

即使你已经习惯了看GenBank文件，当你考虑如何编写一个程序来提取数据的各个部分时，再花一些时间从头到尾看一下也是值得的。比如，你该如何提取序列数据呢？FEATURES表和它的各个子字段的格式是什么样子的？

在一个典型的GenBank条目中，压缩进了大量信息，能把这些不同的部分分隔开来是非常重要的。比如，如果你能提取出序列，你就可以查找基序、计算序列的统计信息、寻找它和其他序列的相似性，等等。类似的，你可能想把数据注释的各个部分分割开来或者进行解析。在GenBank中，这包括ID号、基因名、属种和发表文献等。注释中的FEATURES表部分包含了DNA的特定信息，像外显子、调控区域、重要突变的位置等。

GenBank文件的格式规范，以及关于GenBank的各种其他信息可以在GenBank的版本注释文件\textit{gbrel.txt}文件中找到，这个文件位与GenBank的网站 \href{ftp://ncbi.nlm.nih.gov/genbank/gbrel.txt}{ftp://ncbi.nlm.nih.gov/genbank/gbrel.txt} 上。

\textit{gbrel.txt}给出了GenBank文件结构的完整详细的信息，对于程序员有很大的帮助，所以当你的检索越来越复杂的时候，你可能会想去看一看它。作为一名Perl程序员，你并不需要所有的细节，因为你可以使用正则表达式或者\textit{split}函数来解析数据。你需要把数据提取出来，让你的程序可以使用它。就像你在本章中将要看到的，完成该任务的代码其实非常简单。

\section{GenBank库}
GenBank以一系列的库进行发布，也就是包含连续的多个记录的平面文件。\footnote{数据也以ASN.1格式进行发布。}对于2001年8月份发布的GenBank的125.0版，一共有243个文件，大多数文件的大小都超过了200
MB。总算起啦，GenBank包含了来自12,813,526条报道序列的12,813516个位点和13,543,364,296个碱基。GenBank库同样以压缩格式进行发布，这也就意味着你可以下载相对较小的文件，但是在你获取到它们后你需要对它们进行解压缩。解压缩后数据的总量大约有50 GB。从1982年开始，大约每14各月GenBank中序列的数目就会翻番。

根据它们包含的序列类型，或者是系统发育，或者是测序技术，GenBank库又进一步组织、分成不同的类。下面是这些类别：

\begin{itemize}
  \item PRI（primate sequences）：灵长类动物序列
  \item ROD（rodent sequences）：啮齿类动物序列
  \item MAM（other mammalian sequences）：其他哺乳动物序列
  \item VRT（other vertebrate sequences）：其他脊椎动物序列
  \item INV（invertebrate sequences）：无脊椎动物序列
  \item PLN（plant, fungal, and algal sequences）：植物、真菌和藻类序列
  \item BCT（bacterial sequences）：细菌序列
  \item VRL（viral sequences）：病毒序列
  \item PHG（bacteriophage sequences）：噬菌体序列
  \item SYN（synthetic and chimeric sequences）：合成和嵌合序列
  \item UNA（unannotated sequences）：未注释序列
  \item EST（EST（expressed sequence tags） sequences）：EST（表达序列标签）序列
  \item PAT（patent sequences）：专利序列
  \item STS（STS（sequence tagged sites） sequences）：STS（序列标签位点）序列
  \item GSS（GSS（genome survey sequences） sequences）：GSS（基因组勘测序列）序列
  \item HTG（HTGS（high throughput genomic sequencing data） sequences）：HTGS（高通量基因组测序数据）序列
  \item HTC（HTC（high throughput cDNA sequencing data) sequences）：HTC（高通量cDNA测序数据）序列
\end{itemize}

有些类别非常大：最大的就是EST（表达序列标签）类别，它由123个库文件构成！人类DNA的一部分存储在PRI类别中，它包含13个库文件（本书撰写期间），总共大约有3.5 GB的数据。人类的数据还存储在STS、GSS、HTGS和HTC类别中。单单是GenBank中人类的数据就有近5百万记录条目，序列的碱基数超过了8兆（万亿）。

\href{http://www.ncbi.nlm.nih.gov/}{http://www.ncbi.nlm.nih.gov/} 上的Entrez和BLAST等公共数据库服务器，可以让你访问进行良好维护和升级的序列数据和程序，但是许多研究人员发现它们需要编写自己的程序来处理和分析这些数据。问题在于，数据量实在太大了。对于大多数的研究目的，你只需要从NCBI或者其他地方下载选定的一部分记录，但有时候你需要全部的数据集。

可以构建一个（Windows、Mac、Unix或者Linux）桌面工作站，把所有的GenBank都包含在内，但是一定要确保购买了一个足够大的硬盘！然而，把所有的数据都下载到你的硬盘中是非常困难的。一个叫做\textit{mirror.pl}的程序可以帮你完成这个工作。即使是大学标准的高速因特网连接，下载这些数据也是一个非常耗时的工作；如果使用调制解调器下载全部的数据集一定会让你抓狂的。最好的解决方案是只下载你需要的文件，而且是压缩格式的文件。比如，EST数据，它大约是整个数据库的一半，除非你真的需要它，否则不要去下载它。如果你需要下载GenBank，我推荐你联系NCBI的服务台。它们会帮助你获取最新的信息。

既然你在学习编程，那在一个小的、只有五条记录的库文件上练习就完全够了，当然，你编写的程序在真实的文件中也是完全可以工作的。

\section{分割序列和注释}
在上一章中，你看到了如何使用Perl的数组操作来检查文件的行。通常，你会把数据保存到一个数组中，每一行都是数组的一个元素。

让我们看看从GenBank文件中提取注释和DNA的两种方法。在第一种方法中，你会把文件一股脑的都放进数组中，然后像上一章的程序一样逐行进行处理。在第二种方法中，你会把整个的GenBank记录放到一个标量变量中，然后使用正则表达式来解析信息。是不是某种方法比另一种更好一些？并不一定，这取决于你的数据。每一种方法都有自己的优缺点，但不管怎样，它们都可以完成任务。

我已经把五条GenBank记录放在了一个叫做\textit{library.gb}的文件中。就像前面一样，你可以从本书的网站上下载这个文件。在接下来的几个例子中，你将使用这个数据文件和\textit{record.gb}这个文件。

\subsection{使用数组}
\autoref{exam:example10.1}演示了第一种方法，它对包含GenBank记录行的数组进行操作。主程序后面跟着的是真正起作用的子程序。

%\textbf{例10-1：从GenBank文件中提取注释和序列}
\lstinputlisting[label=exam:example10.1,caption={例10.1：从GenBank文件中提取注释和序列}]{./scripts/example10-1.pl}

下面是\autoref{exam:example10.1}输出的序列数据的开头和结尾部分：

\begin{lstlisting}
agatggcggcgctgaggggtcttgggggctctaggccggccacctactgg
tttgcagcggagacgacgcatggggcctgcgcaataggagtacgctgcct
gggaggcgtgactagaagcggaagtagttgtgggcgcctttgcaaccgcc
tgggacgccgccgagtggtctgtgcaggttcgcgggtcgctggcgggggt
cgtgagggagtgcgccgggagcggagatatggagggagatggttcagacc
...
cggtgcccgtgtgtccgttcctccactcatctgtttctccggttctccct
gtgcccatccaccggttgaccgcccatctgcctttatcagagggactgtc
cccgtcgacatgttcagtgcctggtggggctgcggagtccactcatcctt
gcctcctctccctgggttttgttaataaaattttgaagaaaccaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
\end{lstlisting}

在\autoref{exam:example10.1}中，子程序 \verb|parse1|中的 \verb|foreach|循环把存储在数组 \verb|@GenBankFile|中的GenBank文件的行进行逐行处理。它充分利用了GenBank文件的结构，其中的注释从开头开始一直到下面这一行结束：

 \verb|ORIGIN|

其后便是序列，一直到记录终止行 \verb|//|为止。循环使用一个标识变量 \verb|$in_sequence|来记住它已经找到了 \verb|ORIGIN|行、现在正在读取序列行。

 \verb|foreach|循环有一个新的特性：Perl的内置函数 \verb|last|，它会跳出包裹在最内层的循环。这会由记录终止行 \verb|//|触发，只有当整个记录都被处理后才会到达这一行。

为了寻找记录终止行，使用了一个正则表达式。为了能够正确地匹配记录终止行中的（正）斜杠，你必须在每一个前面都放上反斜杠对它们进行转义，这样Perl就不会把它们解释成模式的提前终止了。正则表示式也以换行符结束 \verb|\/\/\n|，所以把它放到匹配的定界符中间： \verb|/\/\/\n/|。（当你在一个正则表达式中有许多正斜杠时，你可以使用其他的定界符把正则表达式包裹起来，并在其前面使用 \verb|m|，这样就可以避免在正斜杠前面使用反斜杠了。就像这样： \verb|m!//\n!|）。

对于子程序 \verb|parse1|来说，比较有趣的一点是 \verb|foreach|循环对GenBank记录进行逐行处理时的检测顺序。当你逐行阅读记录时，你会想首先收集注释行，当读到序列开始行 \verb|ORIGIN|时设置一个标识，然后收集序列行，直到记录终止行 \verb|//|为止。

注意检测的顺序是完全相反的。首先，你检测记录终止行，如果 \verb|$in_sequence|标识被设置了就收集序列，然后检测序列开始行 \verb|ORIGIN|。最后，你收集注释信息。

逐行读取文件和使用标识变量来标记文件小节的技术，是一个很常见的编程技术。所以，花点时间来想一下，如果你改变了检测的顺序，循环的行为会有什么变化。如果你在检测记录终止行之前就收集序列行，那么你将永远也不会进行记录终止行的检测！

使用其他方法收集注释和序列行也是可以的，尤其是当你多次遍历数组的行时。你可以扫描整个数组，记住序列开始行和记录终止行的行号，然后返回去，使用数组切片（在\autoref{exam:example9.2}的子程序 \verb|parseREBASE|中对其进行过介绍）提取注释和序列。下面是一个例子：

\begin{lstlisting}
# find line numbers of ORIGIN and // in the GenBank record

$linenumber = 0;
foreach my $line (@GenBankFile) {
  if ( $line =~ /^//\n/ ) {  # end-of-record // line
    $end = $linenumber;
    last;
  } elsif ( $line =~ /^ORIGIN/ ) { # end annotation, begin sequence
    $origin = $linenumber;
  }
  $linenumber++;
}

# extract annotation and sequence with "array splice"

@annotation = @GenBankFile[0..($origin-1)];
@sequence   = @GenBankFile[($origin+1)..($end-1)];
\end{lstlisting}

\subsection{使用标量}
第二种把GenBank记录中的注释和序列分开的方法是，把整个记录读取到一个标量变量中，然后用正则表达式操作它。对于某些类型的数据来说，（和\autoref{exam:example10.1}中的遍历数组相比，）这种方法可能是解析输入更加方便的一种方法。

通常对于字符串数据来说，都是把一行存储到单个的标量变量中，如果字符串末尾还有换行符，也会把换行符包含在内。然而，有时你也可以把多行连接在一起，把连接起来的单个字符串保存到一个单独的标量变量中。这种多行组成的字符串并不常见。还记得吗，在\autoref{exam:example6.2}和\autoref{exam:example6.3}中你曾经使用它们来从FASTA文件中收集序列。正则表达式有专门的模式修饰符，让你可以轻松处理含有换行符的多行字符串。

\subsubsection{模式修饰符}
到现在为止，我们使用过的模式修饰符包括用于全局匹配的 \verb|/g|和不去分大小写进行匹配的 \verb|/i|。让我们看一下另外两个模式修饰符，它们可以影响正则表达式处理含有换行符的标量的行为。

回顾一下，前面的正则表达式已经使用过脱字符号（ \verb|^|）、点号（ \verb|.|）和美元符号（ \verb|$|）这三个元字符。 \verb|^|默认会把一个正则表达式锚定到字符串的开头，所以 \verb|/^THE BEGUINE/|匹配以“THE BEGUINE”起始的字符串。与之类似， \verb|$|把一个正则表达式锚定到字符串的末尾，点号（ \verb|.|）会匹配除换行符以外的任意一个字符。

下面的这些模式修饰符会影响这三个元字符的行为：

\begin{itemize}
  \item  \verb|/s|修饰符假设你想把真个字符串作为单独的一行，即使其中有换行符也是一样，所以它使得点号元字符可以匹配\textit{包括}换行符在内的任意一个字符。
  \item
     \verb|/m|修饰符假设你像把整个字符串作为含有换行符的当行进行处理，所以它使得 \verb|^|和 \verb|$|可以匹配字符串内部换行符的后面和前面。
\end{itemize}

\subsubsection{模式修饰符实例}
下面是展示脱字符号（ \verb|^|）、点号（ \verb|.|）和美元符号（ \verb|$|）默认行为的例子：

\begin{lstlisting}
use warnings;
"AAC\nGTT" =~ /^.*$/;
print $&, "\n";
\end{lstlisting}

它演示的是在没有使用 \verb|/m|和 \verb|/s|修饰符的情况下的默认行为，它会输出警告信息：

\begin{lstlisting}
Use of uninitialized value in print statement at line 3.
\end{lstlisting}

 \verb|print|语句试图输出 \verb|$&|，这是一个特殊变量，它总是会被赋值为上一个成功匹配的模式。在这个例子中，无法匹配模式，变量 \verb|$&|并没有被赋值，所以在尝试输出一个未初始化的值的时候你会得到警告信息。

为什么匹配不能够成功呢？首先，让我们检查一下 \verb|^.*$|这个模式。它以 \verb|^|起始，表示必须从字符串的开头进行匹配。它以 \verb|$|结尾，表示必须同时对字符串的末尾（字符串的末尾可能会包含一个换行符，但不允许有更多的换行符存在）进行匹配。 \verb|.*|表示它必须匹配除换行符以外的任意一个字符（ \verb|.|）零次或者多次（ \verb|*|）。所以，换言之，模式 \verb|^.*$|匹配不包含换行符在内的任意一个字符串，除非可能存在的单个换行符是最后的字符。但是上面这个例子中的字符串“ \verb|ACC\nGTT|”，却包含一个不是最后字符的内部的换行符，所以模式匹配失败。

在下面两个例子中，模式修饰符 \verb|/m|和 \verb|/s|会改变元字符 \verb|^|、 \verb|$|和点号的默认行为：

\begin{lstlisting}
"AAC\nGTT" =~ /^.*$/m;
print $&, "\n";
\end{lstlisting}

这个代码片段会输出 \verb|AAC|，演示了 \verb|/m|修饰符的作用。 \verb|/m|会扩展 \verb|^|和 \verb|$|的含义，这样它们也会对包含在内部的换行符的周边进行匹配了。此处，模式会从字符串的开头一直匹配到第一个内部换行符为止。

接下来的这个代码片段演示了 \verb|/s|修饰符的作用：

\begin{lstlisting}
"AAC\nGTT" =~ /^.*$/s;
print $&, "\n";
\end{lstlisting}

这会输出：

\begin{lstlisting}
AAC
GTT
\end{lstlisting}

 \verb|/s|修饰符会改变点号元字符的含义，这样它就能够匹配包含换行符在内的的任意一个字符了。通过使用 \verb|/s|修饰符，模式会从字符串的开头开始一直匹配到字符串的结尾，包括换行符在内的所有东西。注意当它输出时，它把内部的换行符也输出出来了。

\subsubsection{把注释和序列分割开来}
既然你已经学习了模式匹配修饰符，那么接下来正则表达式将是你把GenBank文件作为一个标量进行解析的主要工具，让我们试着把注释和序列分割开来吧。

第一步是把GenBank记录存储到一个标量变量中。回顾一下，GenBank记录开始于以“LOCUS”起始的一行，终止于记录终止分隔符，也就是包含两个正斜杠的行。

首先，你想把GenBank记录读取进来，并存储到一个标量变量中。有一个叫做\textit{输入记录分隔符}的设备，它用特殊变量 \verb|$/|表示，可以让你指定输入记录的分隔符。输入记录分隔符通常设定为换行符，所以当从一个文件句柄中获取记录保存到标量时得到的是一行。可以像下面这样把它设置成GenBank的记录终止分隔符：

\begin{lstlisting}
$/ = "//\n";
\end{lstlisting}

这样，当从文件句柄读取一个标量时，会把到GenBank记录终止分隔符的所有数据都读进来。所以\autoref{exam:example10.2}中的 \verb|$record = <GBFILE>|这行语句会把多行的GenBank记录存储到标量变量 \verb|$record|中。稍后你会看到，可以持续进行调用，把GenBank库文件中连续的多个GenBank记录读取进来。

在读取完记录后，你要使用 \verb|/s|和 \verb|/m|模式修饰符，把它解析成注释和序列两个部分。提取注释和序列是比较容易的，而解析注释则将占据本章剩余的大部分内容。

%\textbf{例10-2：从GenBank记录中提取注释和序列}
\lstinputlisting[label=exam:example10.2,caption={例10.2：从GenBank记录中提取注释和序列}]{./scripts/example10-2.pl}

该程序的输出和前面展示的GenBank文件的内容是完全一样的，但是没有最后一行，也就是没有记录终止分隔符 \verb|//|。

让我们把焦点放在从 \verb|$record|变量中解析注释和序列的正则表达式上。这是到现在为止最复杂的一个正则表达式：

\begin{lstlisting}
$record = /^(LOCUS.*ORIGIN\s*\n)(.*)\/\/\n/s.
\end{lstlisting}

在正则表达式中有两对括号： \verb|(LOCUS.*ORIGIN\s*\n)|和 \verb|(.*)|。小括号是元字符，它的目的是捕获数据中匹配小括号内模式的部分，换言之，就是此处的注释和序列。还要注意，模式匹配返回的是一个数组，这个数组的元素就是匹配的被小括号括起来的模式。在你用正则表达式中成对的小括号对注释和序列进行匹配之后，就可以简单地把匹配到的模式赋值给 \verb|$annotation|和 \verb|$dna|这两个变量了，就像这样：

\begin{lstlisting}
($annotation, $dna) = ($record =~ /^(LOCUS.*ORIGIN\s*\n)(.*)\/\/\n/s);
\end{lstlisting}

注意，在模式的最后，我们加上了 \verb|/s|这个模式匹配修饰符，就像你在前面看到的那样，它允许点号去匹配包括内部换行符在内的任意一个字符。（当然，因为我们把整个的GenBank记录都放到了 \verb|$record|变量中，所以其中有很多个嵌入的内部换行符。）

接下来，先看一下第一对小括号：

\begin{lstlisting}
(LOCUS.*ORIGIN\s*\n)
\end{lstlisting}

因为前面有一个 \verb|^|元字符，所以整个表达式都被锚定在了字符串的开头。（ \verb|/s|并不改变正则表达式中 \verb|^|字符的含义。） 

在小括号内部，你从GenBank记录开头的 \verb|LOCUS|字符串出现的地方开始匹配，接着是使用 \verb|.*|表示的任意数目的包括换行符在内的任意字符，然后是 \verb|ORIGIN|字符串，用 \verb|\s*|表示其后可能有一些空白，最后是一个换行符 \verb|\n|。它匹配的其实就是GenBank记录中的注释部分。

接下来，让我们再看一下第二个小括号和剩余的部分：

\begin{lstlisting}
(.*)\/\/\n
\end{lstlisting}

这个相对简单一些。 \verb|.*|匹配的是包括换行符在内的任意一个字符，因为在模式匹配的后面使用了 \verb|/s|模式修饰符。小括号后面紧跟着的是记录终止行 \verb|//|，以及最后的换行符。反斜杠前面的正斜杠表明你是想要匹配它们本身。它们并不是模式匹配操作符的分隔符。最后的结果就是，GenBank记录中的注释和序列被分开，分别保存到了变量 \verb|$annotation|和变量 \verb|$sequence|中。尽管我使用的正则表达式需要一定的解释，但它吸引人的地方在于只需要一行Perl代码就可以同时把注释和序列提取出来。

\section{解析注释}
既然现在你已经成功把序列提取出来了，那么接下来就让我们解析GenBank文件的注释吧。

看看GenBank记录，你会发现思考如何把有用的信息提取出来还是比较有趣的。FEATURES表肯定是我们此处的重中之重。它的结构比较繁杂，哪些是需要保留的，哪些是不需要的呢？比如，有时你只想看看像“endonuclease”这个的一个单词是否在记录的某个地方出现了。像这种情况，你只需要一个可以在注释中查找任意正则表达式的子程序即可。有时这就足够了，但当需要更详尽的调研时，Perl有你需要的工具来保证任务顺利完成。

\subsection{使用数组}
\autoref{exam:example10.3}解析了GenBank文件中注释的一部分信息。它通过把数据保存到数组中完成了该任务。
  
%\textbf{例10-3：使用数组解析GenBank的注释}
\lstinputlisting[label=exam:example10.3,caption={例10.3：使用数组解析GenBank的注释}]{./scripts/example10-3.pl}

下面是\autoref{exam:example10.3}的输出：

\begin{lstlisting}
*** LOCUS ***
AB031069     2487 bp    mRNA            PRI       27-MAY-2000
*** ACCESSION ***
AB031069
*** ORGANISM ***
Homo sapiens
\end{lstlisting}

现在，我们来稍微扩充一下程序，让它可以处理DEFINITION字段。注意，DEFINITION字段的内容可能不止一行。要收集该字段，使用在\autoref{exam:example10.1}中学到的技巧：当你在收集定义的“状态”时就设置一个标识。毋庸置疑，标识变量还是叫做 \verb|$flag|。

%\textbf{例10-4：使用数组解析GenBank注释，第二次尝试}
\lstinputlisting[label=exam:example10.4,caption={例10.4：使用数组解析GenBank注释，第二次尝试}]{./scripts/example10-4.pl}

\autoref{exam:example10.4}的输出：

\begin{lstlisting}
*** LOCUS ***
AB031069     2487 bp    mRNA            PRI       27-MAY-2000
*** DEFINITION ***
Homo sapiens PCCX1 mRNA for protein containing CXXC domain 1, complete
cds.
*** ACCESSION ***
AB031069
*** ORGANISM ***
Homo sapiens
\end{lstlisting}

当从含有多行小节的文件中提取信息时，从循环的一次跌倒到下一次迭代，使用标识去记住你现在在文件的哪一部分，这是一种非常常见的技术。随着文件和其字段越来越复杂，在代码中需要一次使用多个标识，记住是处于文件的哪一部分，需要从中提取什么信息。这是完全可行的，但随着文件越来越复杂，代码也会越来越复杂，要阅读和修改它就变得困难起来了。所以，让我们看看如何使用正则表达式这个媒介来解析注释吧。

\subsection{何时使用正则表达式}
我们已经使用了两种方法来解析GenBank文件：使用正则表达式和循环处理存储行的数组并设置标识。本章前面的小节中，在分割注释和序列的时候，这两种方法我们都使用过。两种方法没有优劣之分，都完全适用，因为在GenBank文件中，注释后面紧跟着的就是序列，两者被 \verb|ORIGIN|行明确分割开来，这是一个比较简单的结构。然而，要解析注释看起来就要复杂一些了，因此，让我尝试使用正则表达式来完成这个任务吧。

作为开始，我们先把先前的代码整理一下，把它们整理进一些便捷的子程序，这样我们就可以把精力集中在注释的解析上了。你可能会想从库（一个库文件包含一条或多条GenBank记录）中一次只获取一条GenBank记录，提取出注释和序列，然后如果需要的话就解析注释。这样是非常有用的，比如当你在GenBank库中寻找一些基序的时候。然后你就可以查找基序，如果找到了，你再解析注释来找到和序列相关的其他信息。

前面已经提到了，我们将使用文件\textit{library.gb}，你可以从本书的网站上下载到它。

既然处理注释数据有些复杂，就让我们花一分钟来把我们的任务分割成几个比较容易处理的子程序吧。下面是伪代码：

\begin{lstlisting}
sub open_file
    given the filename, return the filehandle

sub get_next_record
    given the filehandle, get the record
    (we can get the offset by first calling "tell")

sub get_annotation_and_dna
    given a record, split it into annotation and cleaned-up sequence

sub search_sequence
    given a sequence and a regular expression,
      return array of locations of hits

sub search_annotation
    given a GenBank annotation and a regular expression,
      return array of locations of hits

sub parse_annotation
    separate out the fields of the annotation in a convenient form

sub parse_features
    given the features field, separate out the components
\end{lstlisting}

思路就是让每一个子程序都只完成一个重要的任务，然后把它们组合成最后有用的程序。其中的某些也可以组合进其他的子程序里，比如，你可能想要打开一个文件并从中获得记录，只需要一个子程序调用就可以了。

你设计这些子程序来处理库文件，也就是含有多个GenBank记录的文件。你把文件句柄作为一个参数传递给子程序，这样你的子程序就可以访问打开的用文件句柄代表的库文件了。这样做，你就要有一个 \verb|get_next_record|函数，便于在循环中使用。使用Perl函数\textit{tell}可以让你保存任何感兴趣的记录的字节偏移量，稍后再回来，快速地从这个字节偏移量处提取记录。（所谓\textit{byte offset（字节偏移量）}就是到达文件中感兴趣的信息所在地所要经过的字符数。）操作系统对Perl的支持，可以让你立即跳转到任意字节偏移量的地方，就算是巨大的文件也没问题，这样就不需要像通常那样，打开文件后从头开始读取直到到达你要去的那个地方。

当你处理大文件使，使用字节偏移量是非常重要的。Perl有内置的变量，像是 \verb|seek|可以让你立即跳转到已打开文件的任意一个地方。思路就是，当你在一个文件中寻找某些东西的时候，你可以使用Perl函数\textit{tell}把字节偏移量保存下来。然后，当你想返回到文件中的那个地方的时候，你可以直接使用字节偏移量作为参数调用Perl函数 \verb|seek|。在本章的后面，当你创建DBM文件，基于它们的索引号来查找记录的时候，你会看到这样的用法。要点在于，对于一个250-MB的文件，要从头开始查找某些东西会花费很唱得时间，有一些办法可以避免这一点。

根据设计，通过三步来完成对数据的解析：

\begin{enumerate}
  \item 首先，你把注释和序列（此处，你要清洁数据，进行删除空白之类的工作，这样就可以得到一个简单的序列字符串了）分隔开来。就算在这一步，你也可以在序列中查找基序，在注释中寻找文本。
  \item 然后，提取出各个字段。
  \item 最后，解析特征表。
\end{enumerate}

这三步看起来一气呵成。依据目的的不同，你可以在任意深度上对数据进行解析。

下面使用伪代码描述的主程序，它演示了如何使用这些子程序：

\begin{lstlisting}
open_file 

while ( get_next_record  )

  get_annotation_and_dna

  if ( search_sequence for a motif AND 
       search_annotation for chromosome 22 )

       parse_annotation

       parse_features to get sizes of exons, look for small sizes
  }
}

return accession numbers of records meeting the criteria
\end{lstlisting}

这个例子演示了如何使用这些子程序来回答一个问题，比如：在22号染色体上有哪些基因包含特定的基序，并且有小的外显子？
  
\subsection{主程序}
让我们使用\autoref{exam:example10.5}来测试一下这些子程序吧，其中的一些子程序定义将会添加到\textit{BeginPerlBioinfo.pm}模块里面：
  
%\textbf{例10-5：GenBank库的子程序}
\lstinputlisting[label=exam:example10.5,caption={例10.5：GenBank库的子程序}]{./scripts/example10-5.pl}

对于我们小巧的GenBank库，\autoref{exam:example10.5}会生成以下输出：

\begin{lstlisting}
Sequence found in record at offset 0
Annotation found in record at offset 0
Sequence found in record at offset 6256
Annotation found in record at offset 6256
Sequence found in record at offset 12366
Annotation found in record at offset 12366
Sequence found in record at offset 17730
Annotation found in record at offset 17730
Sequence found in record at offset 22340
Annotation found in record at offset 22340
\end{lstlisting}

\textit{tell}函数会报告到达文件当前读取位置的字节偏移量，所以你需要首先调用\textit{tell}一次，然后读取记录得到从记录开头开始的正确的偏移量。

\subsection{在顶层解析注释}
现在，让我们来解析注释。

前面已经提到过，NCBI上有一个文档，对GenBank记录结构的细节进行了描述。这个文件就是\textit{gbrel.txt}，它是GenBank发布的一部分，可以从NCBI网站或者它们的FTP站点上找到这个文件。每次发布的时候（现在是每两个月发布一个新版本），它都会更新，其中会注明格式发生的变化。如果你编程处理GenBank记录，你应该读读这个文档，并且在手边保留一份拷贝供参考用，还要定期去查看一下宣告的GenBank记录格式的变化。

如果你回头去看看本章前面部分那个完整的GenBank记录，你会发现注释部分有特定的结构。其中有一些字段，像是LOCUS、DEFINITION、ACCESSION、VERSION、KEYWORDS、SOURCE、REFERENCE、FEATURES和BASE COUNT等，这些字段都起始于一行的开头。有些字段还有子字段，尤其是FEATURE字段，它的结构异常复杂。

但是现在，我们只提取顶层的字段。你需要使用一个正则表达式，来匹配从一行开头的单词到另一行开头的别的单词之前的换行符之间的所有内容。

下面是匹配一个我们定义的字段的正则表达式：

\begin{lstlisting}
/^[A-Z].*\n(^\s.*\n)*/m
\end{lstlisting}

这个正则表达式什么含义？首先，它有 \verb|/m|模式匹配修饰符，表示脱字符 \verb|^|和美元符号 \verb|$|也可以匹配包含在内部的换行符附近的位置（并不仅仅匹配整个字符串的开头和结尾，这是它的默认行为）。

正则表达式的第一部分：
  
\begin{lstlisting}
^[A-Z].*\n
\end{lstlisting}

匹配一行开头的大写字母，紧跟着任意数目的字符（换行符除外），最后是一个换行符。它对你试图匹配的字段的第一行进行了很好的描述。

正则表达式的第二部分：
  
\begin{lstlisting}
(^\s.*\n)*
\end{lstlisting}

匹配一行开头的空格或制表符 \verb|\s|，紧跟着任意数目的字符（换行符除外），最后是一个换行符。它用小括号括了起来，后面紧跟着使用了 \verb|*|，这表示可以有0个或者多个这样的行。它匹配一个字段中的后续行，就是那些以空白开头的行。一个字段可能没有额外的这样的行，也有可能有多个这样的后续行。

所以，正则表达式的这两部分组合起来，匹配字段及其后面可选的附加行。

\autoref{exam:example10.6}演示了一个子程序，对于给定的存储在标量变量中的GenBank记录的注释部分，它会返回一个散列，散列的键就是顶层的字段名，散列的值就是这些字段的具体内容。

%\textbf{例10-6：解析GenBank注释}
\lstinputlisting[label=exam:example10.6,caption={例10.6：解析GenBank注释}]{./scripts/example10-6.pl}

在子程序\textit{parse\_annotation}中，注意变量 \verb|$key|和 \verb|$value|是如何限制在 \verb|while|代码块作用范围内的。这种做法的一个好处就是，你不需要在每次进行循环的时候都对变量进行重新初始化。此外还要注意，散列的键是字段名，而散列的值则是整个字段的内容。

你可能需要花些时间来理解为键提取字段名的整个正则表达式：

\begin{lstlisting}
(my $key = $value) =~ s/^([A-Z]+).*/$1/s;
\end{lstlisting}

它首先把 \verb|$value|的值赋给了 \verb|$key|。然后，它把 \verb|$key|中的所有内容（注意针对嵌入换行符的 \verb|/s|修饰符）都替换成了 \verb|$1|，它是一个特殊变量，保存的是第一对小括号之间的模式（ \verb|[A-Z]+|）。这个模式是一个或多个大写字母（锚定在字符串的开头，也就是字段名），所以它把 \verb|$key|的值设置成了字段名中的第一个单词。


对于\autoref{exam:example10.6}，你会得到下面的输出（这次尝试仅仅获取了GenBank库的第一条记录）：

\begin{lstlisting}[language={},basicstyle=\small\tt,breaklines=false]
******** SOURCE *********
SOURCE      Homo sapiens embryo male lung fibroblast cell_line:HuS-L12 cDNA to
            mRNA.
  ORGANISM  Homo sapiens
            Eukaryota; Metazoa; Chordata; Craniata; Vertebrata; Euteleostomi;
            Mammalia; Eutheria; Primates; Catarrhini; Hominidae; Homo.
******** DEFINITION *********
DEFINITION  Homo sapiens PCCX1 mRNA for protein containing CXXC domain 1,
            complete cds.
******** KEYWORDS *********
KEYWORDS    .
******** VERSION *********
VERSION     AB031069.1  GI:8100074
******** FEATURES *********
FEATURES             Location/Qualifiers
     source          1..2487
                     /organism="Homo sapiens"
                     /db_xref="taxon:9606"
                     /sex="male"
                     /cell_line="HuS-L12"
                     /cell_type="lung fibroblast"
                     /dev_stage="embryo"
     gene            229..2199
                     /gene="PCCX1"
     CDS             229..2199
                     /gene="PCCX1"
                     /note="a nuclear protein carrying a PHD finger and a CXXC
                     domain"
                     /codon_start=1
                     /product="protein containing CXXC domain 1"
                     /protein_id="BAA96307.1"
                     /db_xref="GI:8100075"
                     /translation="MEGDGSDPEPPDAGEDSKSENGENAPIYCICRKPDINCFMIGCD
                     NCNEWFHGDCIRITEKMAKAIREWYCRECREKDPKLEIRYRHKKSRERDGNERDSSEP
                     RDEGGGRKRPVPDPDLQRRAGSGTGVGAMLARGSASPHKSSPQPLVATPSQHHQQQQQ
                     QIKRSARMCGECEACRRTEDCGHCDFCRDMKKFGGPNKIRQKCRLRQCQLRARESYKY
                     FPSSLSPVTPSESLPRPRRPLPTQQQPQPSQKLGRIREDEGAVASSTVKEPPEATATP
                     EPLSDEDLPLDPDLYQDFCAGAFDDHGLPWMSDTEESPFLDPALRKRAVKVKHVKRRE
                     KKSEKKKEERYKRHRQKQKHKDKWKHPERADAKDPASLPQCLGPGCVRPAQPSSKYCS
                     DDCGMKLAANRIYEILPQRIQQWQQSPCIAEEHGKKLLERIRREQQSARTRLQEMERR
                     FHELEAIILRAKQQAVREDEESNEGDSDDTDLQIFCVSCGHPINPRVALRHMERCYAK
                     YESQTSFGSMYPTRIEGATRLFCDVYNPQSKTYCKRLQVLCPEHSRDPKVPADEVCGC
                     PLVRDVFELTGDFCRLPKRQCNRHYCWEKLRRAEVDLERVRVWYKLDELFEQERNVRT
                     AMTNRAGLLALMLHQTIQHDPLTTDLRSSADR"
******** REFERENCE *********
REFERENCE   2  (bases 1 to 2487)
  AUTHORS   Fujino,T., Hasegawa,M., Shibata,S., Kishimoto,T., Imai,S. and
            Takano,T.
  TITLE     Direct Submission
  JOURNAL   Submitted (15-AUG-1999) to the DDBJ/EMBL/GenBank databases.
            Tadahiro Fujino, Keio University School of Medicine, Department of
            Microbiology; Shinanomachi 35, Shinjuku-ku, Tokyo 160-8582, Japan
            (E-mail:fujino@microb.med.keio.ac.jp,
            Tel:+81-3-3353-1211(ex.62692), Fax:+81-3-5360-1508)
******** ACCESSION *********
ACCESSION   AB031069
******** LOCUS *********
LOCUS       AB031069     2487 bp    mRNA            PRI       27-MAY-2000
******** ORIGIN *********
ORIGIN      
******** BASE *********
BASE COUNT      564 a    715 c    768 g    440 t
\end{lstlisting}

如你所见，这种方法完全可行，除了阅读正则表达式比较困难以外（随着练习的增多这也会越来越容易），整个代码都简单明了，就是几个简短的子程序而已。

\subsection{解析FEATURES表}
让我们更进一步，解析一下下一个层面的FEATURES表，它由 \verb|source|、 \verb|gene|和 \verb|CDS|这几个\textit{特征键（features keys）}组成。（参看本节后面的更加全面的特征键列表。）在本章末尾的练习题中，你将会看到进一步深入FEATURES表的挑战。

要研究FEATURES表，你应该首先去看一下前面提到的NCBI中的\textit{gbrel.txt}文档。然后你要再好好研究一下FEATURES表的更加详尽的文档，在 \href{http://www.ncbi.nlm.nih.gov/collab/FT/index.html}{http://www.ncbi.nlm.nih.gov/collab/FT/index.html} 上可以找到它。

\subsubsection{特征}
尽管我们的GenBank条目非常简单，只包含三个特征，实际上特征非常多。注意解析代码会把它们全部找到，因为代码只是处理文档的结构，并不针对特定的特征。

下面是GenBank记录中定义的特征的一个列表。尽管非常长，但我认为最好还是通读一下，对可能会出现在GenBank记录中的信息有一个大体的了解。

\textcolor{red}{\textit{allele}}
\begin{adjustwidth}{4em}{}
等位基因，废弃；参看变异（ \verb|variation|）特征键
\end{adjustwidth}

\textcolor{red}{\textit{attenuator}}
\begin{adjustwidth}{4em}{}
弱化子，和转录终止相关的序列
\end{adjustwidth}

\textcolor{red}{\textit{C\_region}}
\begin{adjustwidth}{4em}{}
C-免疫特征区
\end{adjustwidth}

\textcolor{red}{\textit{CAAT\_signal}}
\begin{adjustwidth}{4em}{}
真核生物启动子区的CAAT盒
CAAT box in eukaryotic promoters
\end{adjustwidth}

\textcolor{red}{\textit{CDS}}
\begin{adjustwidth}{4em}{}
编码蛋白质中氨基酸的序列（包括终止密码子）
\end{adjustwidth}

\textcolor{red}{\textit{conflict}}
\begin{adjustwidth}{4em}{}
不同测定结果所得差异序列
\end{adjustwidth}

\textcolor{red}{\textit{D-loop}}
\begin{adjustwidth}{4em}{}
置换环\footnote{译者注：指DNA双链的局部，由具有互补性单链DNA与之结合所产生的环状结构。}
\end{adjustwidth}

\textcolor{red}{\textit{D\_segment}}
\begin{adjustwidth}{4em}{}
D-免疫特征区\footnote{译者注：免疫功能中免疫球蛋白重链的多变区}
\end{adjustwidth}

\textcolor{red}{\textit{enhancer}}
\begin{adjustwidth}{4em}{}
增强启动子功能的顺式作用增强子
\end{adjustwidth}

\textcolor{red}{\textit{exon}}
\begin{adjustwidth}{4em}{}
外显子，编码剪接mRNA部分的区域
\end{adjustwidth}

\textcolor{red}{\textit{gene}}
\begin{adjustwidth}{4em}{}
基因，确定一个功能性基因的区域，可能包括上游（启动子、增强子，等）和下游的调控元件，每一个都有特定的名字
\end{adjustwidth}

\textcolor{red}{\textit{GC\_signal}}
\begin{adjustwidth}{4em}{}
真核生物启动子中的GC盒
\end{adjustwidth}

\textcolor{red}{\textit{iDNA}}
\begin{adjustwidth}{4em}{}
重组引入的插入DNA
\end{adjustwidth}

\textcolor{red}{\textit{intron}}
\begin{adjustwidth}{4em}{}
内含子，被mRNA剪接切除的转录区域
\end{adjustwidth}

\textcolor{red}{\textit{J\_region}}
\begin{adjustwidth}{4em}{}
J-免疫特征区\footnote{译者注：免疫功能中的连接区，位于免疫球蛋白等分子的V区与C区之间。}
\end{adjustwidth}

\textcolor{red}{\textit{LTR}}
\begin{adjustwidth}{4em}{}
长末端重复序列（Long terminal repeat）
\end{adjustwidth}

\textcolor{red}{\textit{mat\_peptide}}
\begin{adjustwidth}{4em}{}
成熟肽编码区域（不包括终止密码子）
\end{adjustwidth}

\textcolor{red}{\textit{misc\_binding}}
\begin{adjustwidth}{4em}{}
其他结合位点
\end{adjustwidth}

\textcolor{red}{\textit{misc\_difference}}
\begin{adjustwidth}{4em}{}
其他特征区
\end{adjustwidth}

\textcolor{red}{\textit{misc\_feature}}
\begin{adjustwidth}{4em}{}
无法用任何其他特征描述的重要生物功能区
\end{adjustwidth}

\textcolor{red}{\textit{misc\_recomb}}
\begin{adjustwidth}{4em}{}
其他重组特征区
\end{adjustwidth}

\textcolor{red}{\textit{misc\_RNA}}
\begin{adjustwidth}{4em}{}
不能用其他RNA名字定义的转录特征区
\end{adjustwidth}

\textcolor{red}{\textit{misc\_signal}}
\begin{adjustwidth}{4em}{}
其他信号区
\end{adjustwidth}

\textcolor{red}{\textit{misc\_structure}}
\begin{adjustwidth}{4em}{}
其他DNA或RNA结构
\end{adjustwidth}

\textcolor{red}{\textit{modified\_base}}
\begin{adjustwidth}{4em}{}
被修饰的核苷酸碱基
\end{adjustwidth}

\textcolor{red}{\textit{mRNA}}
\begin{adjustwidth}{4em}{}
信使RNA（Messenger RNA）
\end{adjustwidth}

\textcolor{red}{\textit{mutation}}
\begin{adjustwidth}{4em}{}
突变，废弃；参看变异（ \verb|variation|）特征键
\end{adjustwidth}

\textcolor{red}{\textit{N\_region}}
\begin{adjustwidth}{4em}{}
N-免疫特征区
\end{adjustwidth}

\textcolor{red}{\textit{old\_sequence}}
\begin{adjustwidth}{4em}{}
修订自旧版本的序列
\end{adjustwidth}

\textcolor{red}{\textit{polyA\_signal}}
\begin{adjustwidth}{4em}{}
polyA信号，剪切的多聚腺苷酸信号
\end{adjustwidth}

\textcolor{red}{\textit{polyA\_site}}
\begin{adjustwidth}{4em}{}
polyA位点，mRNA的多聚腺苷酸添加位点
\end{adjustwidth}

\textcolor{red}{\textit{precursor\_RNA}}
\begin{adjustwidth}{4em}{}
还不是成熟RNA产物的前体RNA
\end{adjustwidth}

\textcolor{red}{\textit{prim\_transcript}}
\begin{adjustwidth}{4em}{}
初始（未加工的）转录本
\end{adjustwidth}

\textcolor{red}{\textit{primer}}
\begin{adjustwidth}{4em}{}
PCR中使用的引物结合区域
\end{adjustwidth}

\textcolor{red}{\textit{primer\_bind}}
\begin{adjustwidth}{4em}{}
非共价引物结合位点
\end{adjustwidth}

\textcolor{red}{\textit{promoter}}
\begin{adjustwidth}{4em}{}
启动子，转录起始的区域
\end{adjustwidth}

\textcolor{red}{\textit{protein\_bind}}
\begin{adjustwidth}{4em}{}
蛋白质结合在DNA或RNA上的非共价结合位点
\end{adjustwidth}

\textcolor{red}{\textit{RBS}}
\begin{adjustwidth}{4em}{}
核糖体结合位点
\end{adjustwidth}

\textcolor{red}{\textit{rep\_origin}}
\begin{adjustwidth}{4em}{}
双链DNA的复制起始区
\end{adjustwidth}

\textcolor{red}{\textit{repeat\_region}}
\begin{adjustwidth}{4em}{}
包含重复的子序列的重复序列
\end{adjustwidth}

\textcolor{red}{\textit{repeat\_unit}}
\begin{adjustwidth}{4em}{}
重复序列区域的单个重复单元
\end{adjustwidth}

\textcolor{red}{\textit{rRNA}}
\begin{adjustwidth}{4em}{}
核糖体RNA（Ribosomal RNA）
\end{adjustwidth}

\textcolor{red}{\textit{S\_region}}
\begin{adjustwidth}{4em}{}
S-免疫特征区
\end{adjustwidth}

\textcolor{red}{\textit{satellite}}
\begin{adjustwidth}{4em}{}
卫星DNA重复序列
\end{adjustwidth}

\textcolor{red}{\textit{scRNA}}
\begin{adjustwidth}{4em}{}
小胞浆RNA
\end{adjustwidth}

\textcolor{red}{\textit{sig\_peptide}}
\begin{adjustwidth}{4em}{}
信号肽编码区域
\end{adjustwidth}

\textcolor{red}{\textit{snRNA}}
\begin{adjustwidth}{4em}{}
小核RNA
\end{adjustwidth}

\textcolor{red}{\textit{source}}
\begin{adjustwidth}{4em}{}
一个GenBank记录代表的序列数据的生物学来源；每个记录都有一个或多个必须的特征；对于那些已经被收录进NCBI分类学数据库的生物，会有一个与之相关的 \verb|/db_xref="taxon:NNNN"|分类号（其中的 \verb|NNNNN|就是NCBI分类学数据库中为该生物分配的数字识别号）
\end{adjustwidth}

\textcolor{red}{\textit{stem\_loop}}
\begin{adjustwidth}{4em}{}
DNA或RNA中的发卡环结构
\end{adjustwidth}

\textcolor{red}{\textit{STS}}
\begin{adjustwidth}{4em}{}
序列标签位点（Sequence Tagged Site）：操作上和PCR实验中使用的引物结合的唯一序列
\end{adjustwidth}

\textcolor{red}{\textit{TATA\_signal}}
\begin{adjustwidth}{4em}{}
真核生物启动子中的TATA盒
\end{adjustwidth}

\textcolor{red}{\textit{terminator}}
\begin{adjustwidth}{4em}{}
终止子，导致转录终止的序列
\end{adjustwidth}

\textcolor{red}{\textit{transit\_peptide}}
\begin{adjustwidth}{4em}{}
转运肽编码区域
\end{adjustwidth}

\textcolor{red}{\textit{transposon}}
\begin{adjustwidth}{4em}{}
转座子元件（Transposable element，TN）
\end{adjustwidth}

\textcolor{red}{\textit{tRNA}}
\begin{adjustwidth}{4em}{}
转运（Transfer RNA）
\end{adjustwidth}

\textcolor{red}{\textit{unsure}}
\begin{adjustwidth}{4em}{}
作者不确定该区域中的序列
\end{adjustwidth}

\textcolor{red}{\textit{V\_region}}
\begin{adjustwidth}{4em}{}
V-免疫特征区
\end{adjustwidth}

\textcolor{red}{\textit{variation}}
\begin{adjustwidth}{4em}{}
变异，一个相关的群体包含稳定的突变
\end{adjustwidth}

\textcolor{red}{\textit{-}}
\begin{adjustwidth}{4em}{}
占位符（连字符）
\end{adjustwidth}

\textcolor{red}{\textit{-10\_signal}}
\begin{adjustwidth}{4em}{}
原核生物启动子中的Pribnow盒
\end{adjustwidth}

\textcolor{red}{\textit{-35\_signal}}
\begin{adjustwidth}{4em}{}
原核生物启动子中的-35盒
\end{adjustwidth}

\textcolor{red}{\textit{3'clip}}
\begin{adjustwidth}{4em}{}
转录本前体在加工过程中被切除的3'端区域
\end{adjustwidth}

\textcolor{red}{\textit{3'UTR}}
\begin{adjustwidth}{4em}{}
3'端非翻译区（untranslated region）（后缀）
\end{adjustwidth}

\textcolor{red}{\textit{5'clip}}
\begin{adjustwidth}{4em}{}
转录本前体在加工过程中被切除的5'端区域
\end{adjustwidth}

\textcolor{red}{\textit{5'UTR}}
\begin{adjustwidth}{4em}{}
5'端非翻译区（untranslated region）（先导）
\end{adjustwidth}

这些特征键都可以有它们自己的附加特征，在这里以及后面的联系中你会看到的。

\subsubsection{解析}
\autoref{exam:example10.7}寻找出现的特征，并返回用它们填充的数组。它并不会去寻找上一小节中列出的全部特征，它只寻找GenBank记录中出现的那些特征，返回它们已备后续之用。

比较常见的一种情况是，在一个记录中有多个同样的特征。比如，在一个GenBank记录的FEATURES表中可能会有好几个外显子。正因为如此，我们把特征作为元素存储到一个数组中，而不是以特征名作为键存储到一个散列中（它只允许你存储一个，比如，仅仅一个外显子而已）。

%\textbf{例10-7：测试解析特征的子程序}
\lstinputlisting[label=exam:example10.7,caption={例10.7：测试解析特征的子程序}]{./scripts/example10-7.pl}

\autoref{exam:example10.7}会给出下面的输出：

\begin{lstlisting}[language={},basicstyle=\small\tt,breaklines=false]
******** source *********
      source          1..2487
                      /organism="Homo sapiens"
                      /db_xref="taxon:9606"
                      /sex="male"
                      /cell_line="HuS-L12"
                      /cell_type="lung fibroblast"
                      /dev_stage="embryo"
******** gene *********
      gene            229..2199
                      /gene="PCCX1"
******** CDS *********
      CDS             229..2199
                      /gene="PCCX1"
                      /note="a nuclear protein carrying a PHD finger and a CXXC
                      domain"
                      /codon_start=1
                      /product="protein containing CXXC domain 1"
                      /protein_id="BAA96307.1"
                      /db_xref="GI:8100075"
                      /translation="MEGDGSDPEPPDAGEDSKSENGENAPIYCICRKPDINCFMIGCD
                      NCNEWFHGDCIRITEKMAKAIREWYCRECREKDPKLEIRYRHKKSRERDGNERDSSEP
                      RDEGGGRKRPVPDPDLQRRAGSGTGVGAMLARGSASPHKSSPQPLVATPSQHHQQQQQ
                      QIKRSARMCGECEACRRTEDCGHCDFCRDMKKFGGPNKIRQKCRLRQCQLRARESYKY
                      FPSSLSPVTPSESLPRPRRPLPTQQQPQPSQKLGRIREDEGAVASSTVKEPPEATATP
                      EPLSDEDLPLDPDLYQDFCAGAFDDHGLPWMSDTEESPFLDPALRKRAVKVKHVKRRE
                      KKSEKKKEERYKRHRQKQKHKDKWKHPERADAKDPASLPQCLGPGCVRPAQPSSKYCS
                      DDCGMKLAANRIYEILPQRIQQWQQSPCIAEEHGKKLLERIRREQQSARTRLQEMERR
                      FHELEAIILRAKQQAVREDEESNEGDSDDTDLQIFCVSCGHPINPRVALRHMERCYAK
                      YESQTSFGSMYPTRIEGATRLFCDVYNPQSKTYCKRLQVLCPEHSRDPKVPADEVCGC
                      PLVRDVFELTGDFCRLPKRQCNRHYCWEKLRRAEVDLERVRVWYKLDELFEQERNVRT
                      AMTNRAGLLALMLHQTIQHDPLTTDLRSSADR
\end{lstlisting}

在\autoref{exam:example10.7}的子程序 \verb|parse_features|中，提取特征的正则表达式，和\autoref{exam:example10.6}中使用的解析顶层注释所使用的正则表达式非常相似。让我看一下\autoref{exam:example10.7}中最基本的解析代码：

\begin{lstlisting}
while( $features =~ /^ {5}\S.*\n(^ {21}\S.*\n)*/gm ) {
\end{lstlisting}

从整体上看，简单来说，这个正则表达式寻找特定格式的特征，第一行以5个空白起始，后面是可有可无的以21个空白起始的行。

首先，注意模式修饰符 \verb|/m|使得 \verb|^|元字符可以匹配嵌入换行符后面的位置。此外 \verb|{5}|和 \verb|{21}|是量词，指定前面的项目必须出现正好5次和21次，在这两个例子中前面的项目都是一个空白。

根据特征的第一行和可选的后续行，正则表达式分为两部分。第一部分 \verb|^ {5}\S.*\n|表示一行的开头（ \verb|^|）有5个（ \verb|{5}|）空白，后面紧跟着的是一个非空白字符（ \verb|\S|），之后是任意数目的非换行符字符（ \verb|.*|），最后是一个换行符 \verb|\n|）。正则表达式的第二部分 \verb|(^ {21}\S.*\n)*|，表示一行的开头（ \verb|^|）有21个（ \verb|{21}）空白，后面紧跟着的是一个非空白字符（ \verb|\S|），之后是任意数目的非换行符字符（ \verb|.*|），最后是一个换行符（ \verb|\n|）；并且这样的行可以有 \verb|0|个或者多个，这是用包裹住整个表达式的 \verb|()*|来表明的。

主程序中也有一个简短的正则表达式处理类似的行，来从特征中提取出特征名（也叫做特征键）。

所以，又一次成功了。FEATURES表现在被详细地分解或说“解析”了，一直到了能把各个特征分割开的水平。解析FEATURES表的下一步就是从每一个特征中提取出具体的信息了。这包括定位（和特征名在同一行上，也可能在其他行上）；用正斜杠表明的限定词，包括一个限定词名称，如何合适的话，还有一个等号和各种各样的附加信息，附加信息可能持续多行。

我会把这最后的一步作为练习。这是对我们用来解析特征的方法的一个理所当然的扩充。在尝试从一个特征中解析定位和限定词之前，你可能想去参考一下NCBI网站上关于FEATURES表结构的完整细节的文档。

我用来解析FEATURES表的方法保留了信息的结构。然后，有时，你可能只想看看像是“endonulease”这样的某些单词是否在记录中的某个地方出现了。如果是这样，回忆一下你在\autoref{exam:example10.5}中创建的 \verb|search_annotation|子程序，它在整个注释中查找正则表达式。在多数情况下，这就是你真正需要的。然而，就想你刚刚看到的那样，当你真的需要对FEATURES表进行深入解析的时候，Perl有它独特的特性，可以让这个工作变得可行甚至非常简单。

\section{使用DBM对GenBank进行索引}
DBM表示数据库管理（Database
Management）。Perl提供了内置函数，让Perl程序员可以访问DBM文件。

\subsection{DBM基础}
当你打开一个DBM文件时，你就像使用一个散列那样访问它：你给它键，它返回值，并且你可以添加和删除键-值对。DBM之所以有用，是因为它把键-值数据保存在了你计算机中的永久硬盘上。它可以在你运行程序的间歇保存信息，也可以作为在需要同样数据的不同程序间共享信息的一种方法。在吃尽计算机内容之前，一个DBM文件可能会变得非常大，这样它会使你的程序以及其他所有东西慢的像乌龟爬一样。

有两个函数把一个散列“绑定”到一个DBM文件上，它们就是\textit{dbmopen}和\textit{dbmclose}，绑定之后你就使用散列就行了。正如你已经看到的那样，使用散列的话，就像它的定义那样，查找会非常容易。对一个叫做 \verb|%my_hash|的散列，你键入 \verb|keys %my_hash|就可以得到这个散列的所有键了。之后，你键入 \verb|values %%my_hash|就可以得到所有的只。对于大的DBM文件来说，你可能不会想这么做。Perl函数 \verb|each|允许你一次读取一个键-值对，这样就能节省你运行程序 的内存了。也有一个\textit{delete}函数可以删除键的定义：

\begin{lstlisting}
delete $my_hash{'DNA'}
\end{lstlisting}

它会把键从散列中完全删除掉。

DBM文件是一个非常简单的数据库。它们没有\textit{MySQL}、\textit{Oracle}或者\textit{PostgreSQL}这些关系数据库强大，然而，通常对于一个问题来说，它就是我们真正需要的，而这样简单的数据库表现也异常出色。当你有一个键-值数据集（或者多个这样的数据集）时，考虑使用DBM吧。对于Perl来说，它真的非常容易使用。

使用DBM主要的问题在于，有多种稍有不同的DBM实现——NDBM、GDBM、SDBM和Berkeley DB。它们之间的区别很小，但确实存在。但对于绝大多数的目的来说，这些实现是完全通用的。新版本的Perl默认使用Berkeley DB，如果你想的话，对于你的Perl来说它非常容易获得并安装上。如果你真的不需要长的键或者值，这并不是一个问题。一些老的DBMs需要你给键添加空字节（null bytes）并且从值中删除它们。

\begin{lstlisting}
$value = $my_hash{"$key\0"};
chop $value;
\end{lstlisting}

如果你不需要这样做，那就再好不过了。Berkeley DB可以很好得处理长字符串（其他的一些DBM实现有一定的限制）。因为在生物学中，你可能会有一些长的字符串，所以如果你没有Berkeley DB的话，我推荐你安装上。

\subsection{一个用于GenBank的DBM数据库}
你已经看到了，如何从一个GenBank记录或者GenBank记录库中提取信息。你刚刚看到了在程序运行时DBM文件是如何把你的散列数据保存到你的硬盘上的。你也看过了使用 \verb|tell|和 \verb|seek|来快速访问一个文件中的某个位置。

现在，我们把这三个想法组合起来，使用DBM来构建一个关于GenBank库信息的数据库。在一定程度上这非常简单：你提取出索引号作为键，把GenBank库中记录的字节偏移量存储为值。你要添加一些代码，对于给定的一个库和某个偏移量，返回在那个偏移量处的记录，并且编写主程序，允许用户使用索引号交互式得获取GenBank记录。当完成后，如果给它一个索引号，你的程序应该会非常快得返回一个GenBank记录。

此处基本的想法会在本章末尾的练习题中进行扩展，扩展到一个相当大的程度。你现在可能会想先去看一下，这样你对我现在介绍的这种技术的强大就有一定的了解了。

为了避免后面过度的杂乱，现在先给出打开（如果需要会先创建）一个DBM文件的代码片段：

\begin{lstlisting}
unless(dbmopen(%my_hash, 'DBNAME', 0644)) {
  
  print "Cannot open DBM file DBNAME with mode 0644\n";
  exit;
}
\end{lstlisting}

 \verb|%my_hash|就像Perl的其他散列一样，但是通过这个语句，它会被绑定到DBM文件上。 \verb|DBNAME|是将要实际创建的DBM文件的基名。某些DBM版本会创建一个完全叫做这个名字的文件，其他的则会创建使用文件扩展名\textit{.dir}和\textit{.pag}的两个文件。

另一个参数叫做\textit{模式（mode）}。Unix或者Linux用户对于使用这种形式的文件权限会非常熟悉。有多种可能存在，下面是最常见的几个：

\textcolor{red}{\textit{0644}}
\begin{adjustwidth}{4em}{}
你可以读取并写入，其他人只能读取。
\end{adjustwidth}

\textcolor{red}{\textit{0600}}
\begin{adjustwidth}{4em}{}
你有你自己可以读取或写入。
\end{adjustwidth}

\textcolor{red}{\textit{0666}}
\begin{adjustwidth}{4em}{}
任何人都可以读取或写入。
\end{adjustwidth}

\textcolor{red}{\textit{0444}}
\begin{adjustwidth}{4em}{}
任何人都可以读取（但是没人能够写入）。
\end{adjustwidth}

\textcolor{red}{\textit{0400}}
\begin{adjustwidth}{4em}{}
只有你可以读取（其他人都不能对它进行任何操作）。
\end{adjustwidth}

当DBM文件创建的时候它会被授予一定的权限，如果你尝试使用更多的权限去打开它，\textit{dbmopen}函数的调用会失败。通常，如果只有所有者被允许写入的话，所有者会对文件使用0644模式，而读取者则会使用0444模式。如果想要让任何人都可以读取或者写入文件，所有者会赋予它0666模式。

基本上就这些，DBM文件就是这么简单。\autoref{exam:example10.8}演示了一个DBM文件，它存储的键-值对中，键是GenBank记录的索引号，值是记录的字节偏移量。

%\textbf{例10-8：一个GenBank库的DBM索引}
\lstinputlisting[label=exam:example10.8,caption={例10.8：一个GenBank库的DBM索引}]{./scripts/example10-8.pl}

下面是\autoref{exam:example10.8}截断的输出：

\begin{lstlisting}
Here are the available accession numbers:
XM_006271
NM_021964
XM_009873
AB031069
XM_006269
Enter accession number (or quit): NM_021964
LOCUS       NM_021964    3032 bp    mRNA            PRI       14-MAR-2001
DEFINITION  Homo sapiens zinc finger protein 148 (pHZ-52) (ZNF148), mRNA.
...
//

Enter accession number (or quit): q
\end{lstlisting}

\section{练习题}
\textcolor{red}{\textit{习题10.1}}
\begin{adjustwidth}{4em}{}
去逛逛NCBI、EMBL和EBI的网站，熟悉一下它们的使用。
\end{adjustwidth}

\textcolor{red}{\textit{习题10.2}}
\begin{adjustwidth}{4em}{}
阅读GenBank格式的文档\textit{gbrel.txt}。
\end{adjustwidth}

\textcolor{red}{\textit{习题10.3}}
\begin{adjustwidth}{4em}{}
编写一个子程序，通过值传递一个散列。现在重写它，通过指针传递散列。
\end{adjustwidth}

\textcolor{red}{\textit{习题 10.4}}
\begin{adjustwidth}{4em}{}
设计由几个子程序构成的模块，来处理下面这些类型的数据：一个包含记录的平面文件，记录由位于一行的基因名和位于后续行的各种附加信息组成，最后是一个空白行。你的子程序应该能够读取数据，之后对和一个基因名相关的信息进行快速查询。你还应该能够添加新的记录到这个平面文件中。现在重用这些模块，来构建一个地址簿程序。
\end{adjustwidth}

\textcolor{red}{\textit{习题10.5}}
\begin{adjustwidth}{4em}{}
进一步深入FEATURES表。解析表中特征的下一层信息，主要是特征名、定位和限定词这几个特征。对于字段结构的定义，可以查阅文档\textit{gbrel.txt}。
\end{adjustwidth}

\textcolor{red}{\textit{习题10.6}}
\begin{adjustwidth}{4em}{}
编写一个程序，以一个长的DNA序列作为输入，输出以频率进行排序的所有四碱基子序列（一共有256个）的计数。一个四碱基子序列可以起始于1、2、3等各个位置。（这种类型的词频分析在许多研究领域都非常常见，包括语言学、计算机科学和音乐学。）
\end{adjustwidth}

\textcolor{red}{\textit{习题10.7}}
\begin{adjustwidth}{4em}{}
扩展习题10.6中的程序，让它可以对一个GenBank库中的所有序列进行计数。
\end{adjustwidth}

\textcolor{red}{\textit{习题10.8}}
\begin{adjustwidth}{4em}{}
对于给定的一个氨基酸，找到一个DNA序列或者一个GenBank库中它临近氨基酸的出现频率。
\end{adjustwidth}

\textcolor{red}{\textit{习题10.9}}
\begin{adjustwidth}{4em}{}
  从GenBank记录库的注释中提取出所有的单词（除了“the”或者其他无用的类似单词以外）。对于找到的每一个单词，都把库中GenBank记录的偏移量添加到DBM文件中，DBM文件的键就是单词，值使用空格分隔开的偏移量字符串。换言之，一个键对应的值可以是用空格分隔开的偏移量列表。然后，通过一个简单的查找，你就可以露艾苏找到含有像“fibroblast”这样的单词的所有记录了，之后，提取出这些偏移量，使用它们在库中进行进行找寻（\textit{seek}）。与GenBank库先比，你的DBM文件有多大？如果要针对所有GenBank中的注释构建一个搜索引擎，又该如何呢？如果是仅仅针对人类的DNA呢？
\end{adjustwidth}

\textcolor{red}{\textit{习题10.10}}
\begin{adjustwidth}{4em}{}
编写一个程序，从GenBank的GBPRI分类中构建一个个性化的肿瘤基因库。
\end{adjustwidth}

