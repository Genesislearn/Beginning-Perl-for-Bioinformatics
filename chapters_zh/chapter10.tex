\chapter{GenBank}
\label{chap:chapter10}
\minitoc

GenBank（Genetic Sequence Data Bank）是一个快速增长的国际性知识库，存储的是各种各样生物的已知遗传序列。它的使用对于现代生物学和生物信息学来说至关重要。

本章将向你展示如何编写Perl程序来从GenBank文件和库中提取信息。练习题包括查找模式、创建特定的库，以及解析平面文件格式来提取DNA、注释和特征。你将学习如何制作一个DBM数据库，实现自己在GenBank库中对特定数据进行快速的访问与查找。

Perl是处理GenBank文件的一个优秀的工具。它可以让你提取并使用序列以及FEATURES表和其他等注释中的任何细节性的数据。当我第一次使用Perl的时候，我编写了一个程序，检索GenBank中所有被注释为位于人类第22号染色体上的序列记录。我发现许多基因，它们的信息被深深地隐藏在了注释中，以至于GDB（Genome
Database）这个主要的基因图谱数据库都没有把它们包含在自己的染色体图谱中。我相信，当你开始应用Perl处理GenBank文件的时候，你也会对其中的信息有与我同样强烈的感觉。

大多数生物学家对GenBank都非常熟悉。研究人员可以进行检索，比如对于某个查询序列的BLAST检索，也可以把相关序列的一系列GenBank文件作为结果收集起来。因为GenBank记录是由发现序列的特定科学家进行维护的，所以如果你发现了某个新的有趣的序列，你也可以把它发布到GenBank上。

GenBank文件中除了序列数据以外，还有一大堆的信息，包括登录号和基因名这样的识别号、系谱分类和发表文献的参考信息等。一个GenBank文件可能还包含详细的FEATURES表，对序列的情况进行了总结，比如调控区域、蛋白质翻译以及外显子和内含子的定位区域。

GenBank有时被看做是\textit{数据银行（databank）}或者\textit{数据商店（data store）}，这和\textit{数据库（database）}有一定的区别。数据库通常给数据强加一个关系型的结构，包括相关的指数、链接和查询语言。相比之下，GenBank就是一个\textit{平面文件（flat file）}，换言之，就是一个对于人类易读的ASCII码文本文件。\footnote{GenBank也有ASN.1格式的发布，你需要使用NCBI提供特定工具才能对其进行处理。} 

从它毫不起眼的诞生之初，GenBank就开始了飞速增长，而在增长过程中平面文件则凸显了其不足之处。随着知识体的快速发展，尤其是像遗传数据这种知识的快速增长，要想让数据银行的这种设计与时俱进已经很难了。对GenBank进行重新整理设计的许多共组已经完成了，但是平面文件——顶着它逐渐褪色的皇冠——仍然存在着。

归咎于GenBank记录中某些小节内容的一定灵活性，从中提取要寻找的信息可能会比较复杂。这种灵活性有好的一面，它允许你把你认为是最重要的东西都放到数据的注释中；但同时它也有不好的一面，因为同样是灵活性，它会使编写程序来寻找并提取需要的注释信息变得更加困难。正因为如此，现在的趋势是让注释中的内容更具结构化。

Perl的数据结构和正则表达式的应用使得它成为处理平面文件的优秀工具，尤其适合用来处理GenBank数据。使用Perl的这些特性，基于前面章节训练的技能，你可以编写程序来访问GenBank中对于科学界来说日益积累的遗传知识。

因为这是本不需要编程经验的初学者指南书籍，所以你不要指望从中找到完美无瑕、包治百病的软件。与之相反，你会找到对于对于GenBank文件进行解析和构建快速查找表的详尽介绍。如果你还从没有做过类似的事情，我强烈推荐你去探索一下NIH（National Institutes of Health）（\href{http://www.ncbi.nlm.nih.gov}{http://www.ncbi.nlm.nih.gov}）的NCBI（National Center for Biotechnology Information）。当你开始之后，停止在\href{http://www.ebi.ac.uk}{http://www.ebi.ac.uk}的EBI（European Bioinformatics Institute）和\href{http://www.embl-heidelberg.de/}{http://www.embl-heidelberg.de/}的生物信息学分支EMBL（European Molecular Biology Laboratory）即可。它们都是大型的、由重金赞助支持的政府性的生物信息学中心，并且它们都有（并且发布了）大量的顶尖的生物信息学软件。

\section{GenBank文件}
主要的遗传信息库就是NCBI GenBank、欧洲的EMBL和日本的DDBJ（DNA Data Bank
of
Japan）。因为有国际合作协定，它们都有几乎完全相同的信息。GenBank或者它的镜像站点中的每一个条目或者记录都包含确定的描述性的遗传信息，存储在ASCII格式的文件中。每一个记录都用特定的标准格式进行编写与组织，这样不管是人还是计算机程序都可以比较容易地从中提取需要的信息。

让我们看一个相对较短的GenBank记录，在编写代码之前先看看字段是如何定义的。我会把这些信息保存在一个叫做\textit{record.gb}的文件中，便于后面程序的使用。

\begin{lstlisting}[language={},basicstyle=\small\tt,breaklines=false]
LOCUS       AB031069     2487 bp    mRNA            PRI       27-MAY-2000
DEFINITION  Homo sapiens PCCX1 mRNA for protein containing CXXC domain 1,
            complete cds.
ACCESSION   AB031069
VERSION     AB031069.1  GI:8100074
KEYWORDS    .
SOURCE      Homo sapiens embryo male lung fibroblast cell_line:HuS-L12 cDNA to
            mRNA.
  ORGANISM  Homo sapiens
            Eukaryota; Metazoa; Chordata; Craniata; Vertebrata; Euteleostomi;
            Mammalia; Eutheria; Primates; Catarrhini; Hominidae; Homo.
REFERENCE   1  (sites)
  AUTHORS   Fujino,T., Hasegawa,M., Shibata,S., Kishimoto,T., Imai,Si. and
            Takano,T.
  TITLE     PCCX1, a novel DNA-binding protein with PHD finger and CXXC domain,
            is regulated by proteolysis
  JOURNAL   Biochem. Biophys. Res. Commun. 271 (2), 305-310 (2000)
  MEDLINE   20261256
REFERENCE   2  (bases 1 to 2487)
  AUTHORS   Fujino,T., Hasegawa,M., Shibata,S., Kishimoto,T., Imai,S. and
            Takano,T.
  TITLE     Direct Submission
  JOURNAL   Submitted (15-AUG-1999) to the DDBJ/EMBL/GenBank databases.
            Tadahiro Fujino, Keio University School of Medicine, Department of
            Microbiology; Shinanomachi 35, Shinjuku-ku, Tokyo 160-8582, Japan
            (E-mail:fujino@microb.med.keio.ac.jp,
            Tel:+81-3-3353-1211(ex.62692), Fax:+81-3-5360-1508)
FEATURES             Location/Qualifiers
     source          1..2487
                     /organism="Homo sapiens"
                     /db_xref="taxon:9606"
                     /sex="male"
                     /cell_line="HuS-L12"
                     /cell_type="lung fibroblast"
                     /dev_stage="embryo"
     gene            229..2199
                     /gene="PCCX1"
     CDS             229..2199
                     /gene="PCCX1"
                     /note="a nuclear protein carrying a PHD finger and a CXXC
                     domain"
                     /codon_start=1
                     /product="protein containing CXXC domain 1"
                     /protein_id="BAA96307.1"
                     /db_xref="GI:8100075"
                     /translation="MEGDGSDPEPPDAGEDSKSENGENAPIYCICRKPDINCFMIGCD
                     NCNEWFHGDCIRITEKMAKAIREWYCRECREKDPKLEIRYRHKKSRERDGNERDSSEP
                     RDEGGGRKRPVPDPDLQRRAGSGTGVGAMLARGSASPHKSSPQPLVATPSQHHQQQQQ
                     QIKRSARMCGECEACRRTEDCGHCDFCRDMKKFGGPNKIRQKCRLRQCQLRARESYKY
                     FPSSLSPVTPSESLPRPRRPLPTQQQPQPSQKLGRIREDEGAVASSTVKEPPEATATP
                     EPLSDEDLPLDPDLYQDFCAGAFDDHGLPWMSDTEESPFLDPALRKRAVKVKHVKRRE
                     KKSEKKKEERYKRHRQKQKHKDKWKHPERADAKDPASLPQCLGPGCVRPAQPSSKYCS
                     DDCGMKLAANRIYEILPQRIQQWQQSPCIAEEHGKKLLERIRREQQSARTRLQEMERR
                     FHELEAIILRAKQQAVREDEESNEGDSDDTDLQIFCVSCGHPINPRVALRHMERCYAK
                     YESQTSFGSMYPTRIEGATRLFCDVYNPQSKTYCKRLQVLCPEHSRDPKVPADEVCGC
                     PLVRDVFELTGDFCRLPKRQCNRHYCWEKLRRAEVDLERVRVWYKLDELFEQERNVRT
                     AMTNRAGLLALMLHQTIQHDPLTTDLRSSADR"
BASE COUNT      564 a    715 c    768 g    440 t
ORIGIN      
        1 agatggcggc gctgaggggt cttgggggct ctaggccggc cacctactgg tttgcagcgg
       61 agacgacgca tggggcctgc gcaataggag tacgctgcct gggaggcgtg actagaagcg
      121 gaagtagttg tgggcgcctt tgcaaccgcc tgggacgccg ccgagtggtc tgtgcaggtt
      181 cgcgggtcgc tggcgggggt cgtgagggag tgcgccggga gcggagatat ggagggagat
      241 ggttcagacc cagagcctcc agatgccggg gaggacagca agtccgagaa tggggagaat
      301 gcgcccatct actgcatctg ccgcaaaccg gacatcaact gcttcatgat cgggtgtgac
      361 aactgcaatg agtggttcca tggggactgc atccggatca ctgagaagat ggccaaggcc
      421 atccgggagt ggtactgtcg ggagtgcaga gagaaagacc ccaagctaga gattcgctat
      481 cggcacaaga agtcacggga gcgggatggc aatgagcggg acagcagtga gccccgggat
      541 gagggtggag ggcgcaagag gcctgtccct gatccagacc tgcagcgccg ggcagggtca
      601 gggacagggg ttggggccat gcttgctcgg ggctctgctt cgccccacaa atcctctccg
      661 cagcccttgg tggccacacc cagccagcat caccagcagc agcagcagca gatcaaacgg
      721 tcagcccgca tgtgtggtga gtgtgaggca tgtcggcgca ctgaggactg tggtcactgt
      781 gatttctgtc gggacatgaa gaagttcggg ggccccaaca agatccggca gaagtgccgg
      841 ctgcgccagt gccagctgcg ggcccgggaa tcgtacaagt acttcccttc ctcgctctca
      901 ccagtgacgc cctcagagtc cctgccaagg ccccgccggc cactgcccac ccaacagcag
      961 ccacagccat cacagaagtt agggcgcatc cgtgaagatg agggggcagt ggcgtcatca
     1021 acagtcaagg agcctcctga ggctacagcc acacctgagc cactctcaga tgaggaccta
     1081 cctctggatc ctgacctgta tcaggacttc tgtgcagggg cctttgatga ccatggcctg
     1141 ccctggatga gcgacacaga agagtcccca ttcctggacc ccgcgctgcg gaagagggca
     1201 gtgaaagtga agcatgtgaa gcgtcgggag aagaagtctg agaagaagaa ggaggagcga
     1261 tacaagcggc atcggcagaa gcagaagcac aaggataaat ggaaacaccc agagagggct
     1321 gatgccaagg accctgcgtc actgccccag tgcctggggc ccggctgtgt gcgccccgcc
     1381 cagcccagct ccaagtattg ctcagatgac tgtggcatga agctggcagc caaccgcatc
     1441 tacgagatcc tcccccagcg catccagcag tggcagcaga gcccttgcat tgctgaagag
     1501 cacggcaaga agctgctcga acgcattcgc cgagagcagc agagtgcccg cactcgcctt
     1561 caggaaatgg aacgccgatt ccatgagctt gaggccatca ttctacgtgc caagcagcag
     1621 gctgtgcgcg aggatgagga gagcaacgag ggtgacagtg atgacacaga cctgcagatc
     1681 ttctgtgttt cctgtgggca ccccatcaac ccacgtgttg ccttgcgcca catggagcgc
     1741 tgctacgcca agtatgagag ccagacgtcc tttgggtcca tgtaccccac acgcattgaa
     1801 ggggccacac gactcttctg tgatgtgtat aatcctcaga gcaaaacata ctgtaagcgg
     1861 ctccaggtgc tgtgccccga gcactcacgg gaccccaaag tgccagctga cgaggtatgc
     1921 gggtgccccc ttgtacgtga tgtctttgag ctcacgggtg acttctgccg cctgcccaag
     1981 cgccagtgca atcgccatta ctgctgggag aagctgcggc gtgcggaagt ggacttggag
     2041 cgcgtgcgtg tgtggtacaa gctggacgag ctgtttgagc aggagcgcaa tgtgcgcaca
     2101 gccatgacaa accgcgcggg attgctggcc ctgatgctgc accagacgat ccagcacgat
     2161 cccctcacta ccgacctgcg ctccagtgcc gaccgctgag cctcctggcc cggacccctt
     2221 acaccctgca ttccagatgg gggagccgcc cggtgcccgt gtgtccgttc ctccactcat
     2281 ctgtttctcc ggttctccct gtgcccatcc accggttgac cgcccatctg cctttatcag
     2341 agggactgtc cccgtcgaca tgttcagtgc ctggtggggc tgcggagtcc actcatcctt
     2401 gcctcctctc cctgggtttt gttaataaaa ttttgaagaa accaaaaaaa aaaaaaaaaa
     2461 aaaaaaaaaa aaaaaaaaaa aaaaaaa
//
\end{lstlisting}

即使你已经习惯了看GenBank文件，当你考虑如何编写一个程序来提取数据的各个部分时，再花一些时间从头到尾看一下也是值得的。比如，你该如何提取序列数据呢？FEATURES表和它的各个子字段的格式是什么样子的？

在一个典型的GenBank条目中，压缩进了大量信息，能把这些不同的部分分隔开来是非常重要的。比如，如果你能提取出序列，你就可以查找基序、计算序列的统计信息、寻找它和其他序列的相似性，等等。类似的，你可能想把数据注释的各个部分分割开来或者进行解析。在GenBank中，这包括ID号、基因名、属种和发表文献等。注释中的FEATURES表部分包含了DNA的特定信息，像外显子、调控区域、重要突变的位置等。

GenBank文件的格式规范，以及关于GenBank的各种其他信息可以在GenBank的版本注释文件\textit{gbrel.txt}文件中找到，这个文件位与GenBank的网站\href{ftp://ncbi.nlm.nih.gov/genbank/gbrel.txt}{ftp://ncbi.nlm.nih.gov/genbank/gbrel.txt}上。

\textit{gbrel.txt}给出了GenBank文件结构的完整详细的信息，对于程序员有很大的帮助，所以当你的检索越来越复杂的时候，你可能会想去看一看它。作为一名Perl程序员，你并不需要所有的细节，因为你可以使用正则表达式或者\textit{split}函数来解析数据。你需要把数据提取出来，让你的程序可以使用它。就像你在本章中将要看到的，完成该任务的代码其实非常简单。

\section{GenBank库}
GenBank以一系列的库进行发布，也就是包含连续的多个记录的平面文件。\footnote{数据也以ASN.1格式进行发布。}对于2001年8月份发布的GenBank的125.0版，一共有243个文件，大多数文件的大小都超过了200
MB。总算起啦，GenBank包含了来自12,813,526条报道序列的12,813516个位点和13,543,364,296个碱基。GenBank库同样以压缩格式进行发布，这也就意味着你可以下载相对较小的文件，但是在你获取到它们后你需要对它们进行解压缩。解压缩后数据的总量大约有50 GB。从1982年开始，大约每14各月GenBank中序列的数目就会翻番。

根据它们包含的序列类型，或者是系统发育，或者是测序技术，GenBank库又进一步组织、分成不同的类。下面是这些类别：

\begin{itemize}
  \item PRI（primate sequences）：灵长类动物序列
  \item ROD（rodent sequences）：啮齿类动物序列
  \item MAM（other mammalian sequences）：其他哺乳动物序列
  \item VRT（other vertebrate sequences）：其他脊椎动物序列
  \item INV（invertebrate sequences）：无脊椎动物序列
  \item PLN（plant, fungal, and algal sequences）：植物、真菌和藻类序列
  \item BCT（bacterial sequences）：细菌序列
  \item VRL（viral sequences）：病毒序列
  \item PHG（bacteriophage sequences）：噬菌体序列
  \item SYN（synthetic and chimeric sequences）：合成和嵌合序列
  \item UNA（unannotated sequences）：未注释序列
  \item EST（EST（expressed sequence tags） sequences）：EST（表达序列标签）序列
  \item PAT（patent sequences）：专利序列
  \item STS（STS（sequence tagged sites） sequences）：STS（序列标签位点）序列
  \item GSS（GSS（genome survey sequences） sequences）：GSS（基因组勘测序列）序列
  \item HTG（HTGS（high throughput genomic sequencing data） sequences）：HTGS（高通量基因组测序数据）序列
  \item HTC（HTC（high throughput cDNA sequencing data) sequences）：HTC（高通量cDNA测序数据）序列
\end{itemize}

有些类别非常大：最大的就是EST（表达序列标签）类别，它由123个库文件构成！人类DNA的一部分存储在PRI类别中，它包含13个库文件（本书撰写期间），总共大约有3.5 GB的数据。人类的数据还存储在STS、GSS、HTGS和HTC类别中。单单是GenBank中人类的数据就有近5百万记录条目，序列的碱基数超过了8兆（万亿）。

\href{http://www.ncbi.nlm.nih.gov/}{http://www.ncbi.nlm.nih.gov/}上的Entrez和BLAST等公共数据库服务器，可以让你访问进行良好维护和升级的序列数据和程序，但是许多研究人员发现它们需要编写自己的程序来处理和分析这些数据。问题在于，数据量实在太大了。对于大多数的研究目的，你只需要从NCBI或者其他地方下载选定的一部分记录，但有时候你需要全部的数据集。

可以构建一个（Windows、Mac、Unix或者Linux）桌面工作站，把所有的GenBank都包含在内，但是一定要确保购买了一个足够大的硬盘！然而，把所有的数据都下载到你的硬盘中是非常困难的。一个叫做\textit{mirror.pl}的程序可以帮你完成这个工作。即使是大学标准的高速因特网连接，下载这些数据也是一个非常耗时的工作；如果使用调制解调器下载全部的数据集一定会让你抓狂的。最好的解决方案是只下载你需要的文件，而且是压缩格式的文件。比如，EST数据，它大约是整个数据库的一半，除非你真的需要它，否则不要去下载它。如果你需要下载GenBank，我推荐你联系NCBI的服务台。它们会帮助你获取最新的信息。

既然你在学习编程，那在一个小的、只有五条记录的库文件上练习就完全够了，当然，你编写的程序在真实的文件中也是完全可以工作的。

\section{分割序列和注释}
在上一章中，你看到了如何使用Perl的数组操作来检查文件的行。通常，你会把数据保存到一个数组中，每一行都是数组的一个元素。

让我们看看从GenBank文件中提取注释和DNA的两种方法。在第一种方法中，你会把文件一股脑的都放进数组中，然后像上一章的程序一样逐行进行处理。在第二种方法中，你会把整个的GenBank记录放到一个标量变量中，然后使用正则表达式来解析信息。是不是某种方法比另一种更好一些？并不一定，这取决于你的数据。每一种方法都有自己的优缺点，但不管怎样，它们都可以完成任务。

我已经把五条GenBank记录放在了一个叫做\textit{library.gb}的文件中。就像前面一样，你可以从本书的网站上下载这个文件。在接下来的几个例子中，你将使用这个数据文件和\textit{record.gb}这个文件。

\subsection{使用数组}
\autoref{exam:example10.1}演示了第一种方法，它对包含GenBank记录行的数组进行操作。主程序后面跟着的是真正起作用的子程序。

\textbf{例10-1：从GenBank文件中提取注释和序列}
\lstinputlisting[label=exam:example10.1]{./scripts/example10-1.pl}

下面是\autoref{exam:example10.1}输出的序列数据的开头和结尾部分：

\begin{lstlisting}
agatggcggcgctgaggggtcttgggggctctaggccggccacctactgg
tttgcagcggagacgacgcatggggcctgcgcaataggagtacgctgcct
gggaggcgtgactagaagcggaagtagttgtgggcgcctttgcaaccgcc
tgggacgccgccgagtggtctgtgcaggttcgcgggtcgctggcgggggt
cgtgagggagtgcgccgggagcggagatatggagggagatggttcagacc
...
cggtgcccgtgtgtccgttcctccactcatctgtttctccggttctccct
gtgcccatccaccggttgaccgcccatctgcctttatcagagggactgtc
cccgtcgacatgttcagtgcctggtggggctgcggagtccactcatcctt
gcctcctctccctgggttttgttaataaaattttgaagaaaccaaaaaaa
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
\end{lstlisting}

在\autoref{exam:example10.1}中，子程序\verb|parse1|中的\verb|foreach|循环把存储在数组\verb|@GenBankFile|中的GenBank文件的行进行逐行处理。它充分利用了GenBank文件的结构，其中的注释从开头开始一直到下面这一行结束：

\verb|ORIGIN|

其后便是序列，一直到记录终止行\verb|//|为止。循环使用一个标识变量\verb|$in_sequence|来记住它已经找到了\verb|ORIGIN|行、现在正在读取序列行。

\verb|foreach|循环有一个新的特性：Perl的内置函数\verb|last|，它会跳出包裹在最内层的循环。这会由记录终止行\verb|//|触发，只有当整个记录都被处理后才会到达这一行。

为了寻找记录终止行，使用了一个正则表达式。为了能够正确地匹配记录终止行中的（正）斜杠，你必须在每一个前面都放上反斜杠对它们进行转义，这样Perl就不会把它们解释成模式的提前终止了。正则表示式也以换行符结束\verb|\/\/\n|，所以把它放到匹配的定界符中间：\verb|/\/\/\n/|。（当你在一个正则表达式中有许多正斜杠时，你可以使用其他的定界符把正则表达式包裹起来，并在其前面使用\verb|m|，这样就可以避免在正斜杠前面使用反斜杠了。就像这样：\verb|m!//\n!|）。

对于子程序\verb|parse1|来说，比较有趣的一点是\verb|foreach|循环对GenBank记录进行逐行处理时的检测顺序。当你逐行阅读记录时，你会想首先收集注释行，当读到序列开始行\verb|ORIGIN|时设置一个标识，然后收集序列行，直到记录终止行\verb|//|为止。

注意检测的顺序是完全相反的。首先，你检测记录终止行，如果\verb|$in_sequence|标识被设置了就收集序列，然后检测序列开始行\verb|ORIGIN|。最后，你收集注释信息。

逐行读取文件和使用标识变量来标记文件小节的技术，是一个很常见的编程技术。所以，花点时间来想一下，如果你改变了检测的顺序，循环的行为会有什么变化。如果你在检测记录终止行之前就收集序列行，那么你将永远也不会进行记录终止行的检测！

使用其他方法收集注释和序列行也是可以的，尤其是当你多次遍历数组的行时。你可以扫描整个数组，记住序列开始行和记录终止行的行号，然后返回去，使用数组切片（在\autoref{exam:example9.2}的子程序\verb|parseREBASE|中对其进行过介绍）提取注释和序列。下面是一个例子：

\begin{lstlisting}
# find line numbers of ORIGIN and // in the GenBank record

$linenumber = 0;
foreach my $line (@GenBankFile) {
  if ( $line =~ /^//\n/ ) {  # end-of-record // line
    $end = $linenumber;
    last;
  } elsif ( $line =~ /^ORIGIN/ ) { # end annotation, begin sequence
    $origin = $linenumber;
  }
  $linenumber++;
}

# extract annotation and sequence with "array splice"

@annotation = @GenBankFile[0..($origin-1)];
@sequence   = @GenBankFile[($origin+1)..($end-1)];
\end{lstlisting}

\subsection{Using Scalars}
A second way to separate annotations from sequences in GenBank records is to read the entire record into a scalar variable and operate on it with regular expressions. For some kinds of data, this can be a more convenient way to parse the input (compared to scanning through an array, as in \autoref{exam:example10.1}).

Usually string data is stored one line per scalar variable with its newlines, if any, at the end of the string. Sometimes, however, you store several lines concatenated together in one string that is, in turn, stored in a single scalar variable. These multiline strings aren't uncommon; you used them to gather the sequence from a FASTA file in Examples \autoref{exam:example6.2} and \autoref{exam:example6.3}. Regular expressions have pattern modifiers that can be used to make multiline strings with their embedded newlines easy to use. 

\subsubsection{Pattern modifiers}
The pattern modifiers we've used so far are \verb|/g|, for global matching, and \verb|/i|, for case-insensitive matching. Let's take a look at two more that affect the way regular expressions interact with the newlines in scalars.

Recall that previous regular expressions have used the caret (\verb|^|), dot (\verb|.|), and dollar sign (\verb|$|) metacharacters. The \verb|^| anchors a regular expression to the beginning of a string, by default, so that \verb|/^THE BEGUINE/| matches a string that begins with "THE BEGUINE". Similarly, \verb|$| anchors an expression to the end of the string, and the dot (\verb|.|) matches any character except a newline.

The following pattern modifiers affect these three metacharacters:

\begin{itemize}
  \item The \verb|/s| modifier assumes you want to treat the whole string as a single line, even with embedded newlines, so it makes the dot metacharacter match any character \textit{including} newlines.  
  \item The \verb|/m| modifier assumes you want to treat the whole string as a multiline, with embedded newlines, so it extends the \verb|^| and the \verb|$| to match after, or before, a newline, embedded in the string.
\end{itemize}

\subsubsection{Examples of pattern modifiers}
Here's an example of the default behavior of caret (\verb|^|), dot (\verb|.|), and dollar sign (\verb|$|): 

\begin{lstlisting}
use warnings;
"AAC\nGTT" =~ /^.*$/;
print $&, "\n";
\end{lstlisting}

This demonstrates the default behavior without the \verb|/m| or \verb|/s| modifiers and prints the warning:

\begin{lstlisting}
Use of uninitialized value in print statement at line 3.
\end{lstlisting}

The \verb|print| statement tries to print \verb|$&|, a special variable that is always set to the last successful pattern match. This time, since the pattern doesn't match, the variable \verb|$&| isn't set, and you get a warning message for attempting to print an uninitialized value. 

Why doesn't the match succeed? First, let's examine the \verb|^.*$| pattern. It begins with a \verb|^|, which means it must match from the beginning of the string. It ends with a \verb|$|, which means it must also match at the end of the string (the end of the string may contain a single newline, but no other newlines are allowed). The \verb|.*| means it must match zero or more (\verb|*|) of any characters (\verb|.|) except the newline. So, in other words, the pattern \verb|^.*$| matches any string that doesn't contain a newline except for a possible single newline as the last character. But since the string in question, "\verb|ACC\nGTT|" does contain an embedded newline \verb|\n| that isn't the last character, the pattern match fails.

In the next examples, the pattern modifiers \verb|/m| and \verb|/s| change the default
behaviors for the metacharacters \verb|^|, and \verb|$|, and the dot: 

\begin{lstlisting}
"AAC\nGTT" =~ /^.*$/m;
print $&, "\n";
\end{lstlisting}

This snippet prints out \verb|AAC| and demonstrates the \verb|/m| modifier. The \verb|/m| extends the meaning of the \verb|^| and the \verb|$| so they also match around embedded newlines. Here, the pattern matches from the beginning of the string up to the first embedded newline.

The next snippet of code demonstrates the \verb|/s| modifier: 

\begin{lstlisting}
"AAC\nGTT" =~ /^.*$/s;
print $&, "\n";
\end{lstlisting}

which produces the output:

\begin{lstlisting}
AAC
GTT
\end{lstlisting}

The \verb|/s| modifier changes the meaning of the dot metacharacter so that it matches any character including newlines. With the \verb|/s| modifier, the pattern matches everything from the beginning of the string to the end of the string, including the newline. Notice when it prints, it prints the embedded newline. 

\subsubsection{Separating annotations from sequence}
Now that you've met the pattern-matching modifiers and regular expressions that will be your main tools for parsing a GenBank file as a scalar, let's try separating the annotations from the sequence.

The first step is to get the GenBank record stored as a scalar variable. Recall that a GenBank record starts with a line beginning with the word "LOCUS" and ends with the end-of-record separator: a line containing two forward slashes.

First you want to read a GenBank record and store it in a scalar variable. There's a device called an \textit{input record separator} denoted by the special variable \verb|$/| that lets you do exactly that. The input record separator is usually set to a newline, so each call to read a scalar from a filehandle gets one line. Set it to the GenBank end-of-record separator like so: 

\begin{lstlisting}
$/ = "//\n";
\end{lstlisting}

A call to read a scalar from a filehandle takes all the data up to the GenBank end-of-record separator. So the line \verb|$record = <GBFILE>| in \autoref{exam:example10.2} stores the multiline GenBank record into the scalar variable \verb|$record|. Later, you'll see that you can keep repeating this call in order to read in successive GenBank records from a GenBank library file.

After reading in the record, you'll parse it into the annotation and sequence parts making use of \verb|/s| and \verb|/m| pattern modifiers. Extracting the annotation and sequence is the easy part; parsing the annotation will occupy most of the remainder of the chapter.

\textbf{Example 10-2. Extract annotation and sequence from Genbank record}
\lstinputlisting[label=exam:example10.2]{./scripts/example10-2.pl}

The output from this program is the same as the GenBank file listed previously, minus the last line, which is the end-of-record separator \verb|//|.

Let's focus on the regular expression that parses the annotation and sequence out of the \verb|$record| variable. This is the most complicated regular expression so far: 

\begin{lstlisting}
$record = /^(LOCUS.*ORIGIN\s*\n)(.*)\/\/\n/s.
\end{lstlisting}

There are two pairs of parentheses in the regular expression: (\verb|LOCUS.*ORIGIN\s*\n|) and (\verb|.*|). The parentheses are metacharacters whose purpose is to remember the parts of the data that match the pattern within the parentheses, namely, the annotation and the sequence. Also note that the pattern match returns an array whose elements are the matched parenthetical patterns. After you match the annotation and the sequence within the pairs of parentheses in the regular expression, you simply assign the matched patterns to the two variables \verb|$annotation| and \verb|$dna|, like so: 

\begin{lstlisting}
($annotation, $dna) = ($record =~ /^(LOCUS.*ORIGIN\s*\n)(.*)\/\/\n/s);
\end{lstlisting}

Notice that at the end of the pattern, we've added the \verb|/s| pattern matching modifier, which, as you've seen earlier, allows a dot to match any character including an embedded newline. (Of course, since we've got a whole GenBank record in the \verb|$record| scalar, there are a lot of embedded newlines.)

Next, look at the first pair of parentheses:

\begin{lstlisting}
(LOCUS.*ORIGIN\s*\n)
\end{lstlisting}

This whole expression is anchored at the beginning of the string by preceding it with a \verb|^| metacharacter. (\verb|/s| doesn't change the meaning of the \verb|^| character in a regular expression.)

Inside the parentheses, you match from where the string \verb|LOCUS| appears at the beginning of the GenBank record, followed by any number of characters including newlines with \verb|.*|, followed by the string \verb|ORIGIN|, followed by possibly some whitespace with \verb|\s*|, followed by a newline \verb|\n|. This matches the annotation part of the GenBank record.

Now, look at the second parentheses and the remainder:

\begin{lstlisting}
(.*)\/\/\n
\end{lstlisting}

This is easier. The \verb|.*| matches any character, including newlines because of the \verb|/s| pattern modifier at the end of the pattern match. The parentheses are followed by the end-of-record line, \verb|//|, including the newline at the end, with the slashes preceded by backslashes to show that you want to match them exactly. They're not delimiters of the pattern matching operator. The end result is the GenBank record with the annotation and the sequence separated into the variables \verb|$annotation| and \verb|$sequence|. Although the regular expression I used requires a bit of explanation, the attractive thing about this approach is that it took only one line of Perl code to extract both annotation and sequence. 

\section{Parsing Annotations}
Now that you've successfully extracted the sequence, let's look at parsing the annotations of a GenBank file.

Looking at a GenBank record, it's interesting to think about how to extract the useful information. The FEATURES table is certainly a key part of the story. It has considerable structure: what should be preserved, and what is unnecessary? For instance, sometimes you just want to see if a word such as "endonuclease" appears anywhere in the record. For this, you just need a subroutine that searches for any regular expression in the annotation. Sometimes this is enough, but when detailed surgery is necessary, Perl has the necessary tools to make the operation successful. 

\subsection{Using Arrays}
\autoref{exam:example10.3} parses a few pieces of information from the annotations in a GenBank file. It does this using the data in the form of an array. 
  
\textbf{Example 10-3. Parsing GenBank annotations using arrays}
\lstinputlisting[label=exam:example10.3]{./scripts/example10-3.pl}

Here's the output from \autoref{exam:example10.3}:

\begin{lstlisting}
*** LOCUS ***
AB031069     2487 bp    mRNA            PRI       27-MAY-2000
*** ACCESSION ***
AB031069
*** ORGANISM ***
Homo sapiens
\end{lstlisting}

Now let's slightly extend that program to handle the DEFINITION field.  Notice that the DEFINITION field can extend over more than one line. To collect that field, use a trick you've already seen in \autoref{exam:example10.1}: set a flag when you're in the "state" of collecting a definition. The flag variable is called, unsurprisingly, \verb|$flag|. 

\textbf{Example 10-4. Parsing GenBank annotations using arrays, take 2}
\lstinputlisting[label=exam:example10.4]{./scripts/example10-4.pl}

\autoref{exam:example10.4} outputs:

\begin{lstlisting}
*** LOCUS ***
AB031069     2487 bp    mRNA            PRI       27-MAY-2000
*** DEFINITION ***
Homo sapiens PCCX1 mRNA for protein containing CXXC domain 1, complete
cds.
*** ACCESSION ***
AB031069
*** ORGANISM ***
Homo sapiens
\end{lstlisting}

This use of flags to remember which part of the file you're in, from one iteration of a loop to the next, is a common technique when extracting information from files that have multiline sections. As the files and their fields get more complex, the code must keep track of many flags at a time to remember which part of the file it's in and what information needs to be extracted. It works, but as the files become more complex, so does the code. It becomes hard to read and hard to modify. So let's look at regular expressions as a vehicle for parsing annotations. 

\subsection{When to Use Regular Expressions}
We've used two methods to parse GenBank files: regular expressions and looping through arrays of lines and setting flags. We used both methods to separate the annotation from the sequence in a previous section of this chapter. Both methods were equally well suited, since in GenBank files, the annotation is followed by the sequence, clearly delimited by an \verb|ORIGIN| line: a simple structure. However, parsing the annotations seems a bit more complicated; therefore, let's try to use regular expressions to accomplish the task.

To begin, let's wrap the code we've been working on into some convenient subroutines to focus on parsing the annotations. You'll want to fetch GenBank records one at a time from a library (a file containing one or more GenBank records), extract the annotations and the sequence, and then if desired parse the annotations. This would be useful if, say, you were looking for some motif in a GenBank library. Then you can search for the motif, and, if found, you can parse the annotations to look for additional information about the sequence.

As mentioned previously, we'll use the file \textit{library.gb}, which you can download from this book's web site.

Since dealing with annotation data is somewhat complex, let's take a minute to break our tasks into convenient subroutines. Here's the pseudocode: 

\begin{lstlisting}
sub open_file
    given the filename, return the filehandle

sub get_next_record
    given the filehandle, get the record
    (we can get the offset by first calling "tell")

sub get_annotation_and_dna
    given a record, split it into annotation and cleaned-up sequence

sub search_sequence
    given a sequence and a regular expression,
      return array of locations of hits

sub search_annotation
    given a GenBank annotation and a regular expression,
      return array of locations of hits

sub parse_annotation
    separate out the fields of the annotation in a convenient form

sub parse_features
    given the features field, separate out the components
\end{lstlisting}

The idea is to make a subroutine for each important task you want to accomplish and then combine them into useful programs. Some of these can be combined into other subroutines: for instance, perhaps you want to open a file and get the record from it, all in one subroutine call.

You're designing these subroutines to work with library files, that is, files with multiple GenBank records. You pass the filehandle into the subroutines as an argument, so that your subroutines can access open library files as represented by the filehandles. Doing so enables you to have a \verb|get_next_record| function, which is handy in a loop. Using the Perl function \textit{tell} also allows you to save the byte offset of any record of interest, and then return later and extract the record at that byte offset very quickly. (A \textit{byte offset} is just the number of characters into the file where the information of interest lies.) The operating system supports Perl in letting you go immediately to any byte offset location in even huge files, thus bypassing the usual way of opening the file and reading from the beginning until you get where you want to be.  

Using a byte offset is important when you're dealing with large files.  Perl gives you built-in functions such as \verb|seek| that allow you, on an open file, to go immediately to any location in the file. The idea is that when you find something in a file, you can save the byte offset using the Perl function \textit{tell}. Then, when you want to return to that point in the file, you can just call the Perl function \textit{seek} with the byte offset as an argument. You'll see this later in this chapter when you build a DBM file to look up records based on their accession numbers. But the main point is that with a 250-MB file, it takes too long to find something by searching from the beginning, and there are ways of getting around it.

The parsing of the data is done in three steps, according to the design: 

\begin{enumerate}
  \item You'll separate out the annotation and the sequence (which you'll clean up by removing whitespace, etc., and making it a simple string of sequence). Even at this step, you can search for motifs in the sequence, as well as look for text in the annotation.
  \item Extract out the fields.
  \item Parse the features table.
\end{enumerate}

These steps seem natural, and, depending on what you want to do, allow you to parse to whatever depth is needed.  

Here's a main program in pseudocode that shows how to use those subroutines: 

\begin{lstlisting}
open_file 

while ( get_next_record  )

  get_annotation_and_dna

  if ( search_sequence for a motif AND 
       search_annotation for chromosome 22 )

       parse_annotation

       parse_features to get sizes of exons, look for small sizes
  }
}

return accession numbers of records meeting the criteria
\end{lstlisting}

This example shows how to use subroutines to answer a question such as: what are the genes on chromosome 22 that contain a given motif and have small exons? 
  
\subsection{Main Program}
Let's test these subroutines with \autoref{exam:example10.5}, which has some subroutine definitions that will be added to the \textit{BeginPerlBioinfo.pm} module: 
  
\textbf{Example 10-5. GenBank library subroutines}
\lstinputlisting[label=exam:example10.5]{./scripts/example10-5.pl}

\autoref{exam:example10.5} generates the following output on our little GenBank library:

\begin{lstlisting}
Sequence found in record at offset 0
Annotation found in record at offset 0
Sequence found in record at offset 6256
Annotation found in record at offset 6256
Sequence found in record at offset 12366
Annotation found in record at offset 12366
Sequence found in record at offset 17730
Annotation found in record at offset 17730
Sequence found in record at offset 22340
Annotation found in record at offset 22340
\end{lstlisting}

The \textit{tell} function reports the byte offset of the file up to the point where it's been read; so you want to first call \textit{tell} and then read the record to get the proper offset associated with the beginning of the record. 

\subsection{Parsing Annotations at the Top Level}
Now let's parse the annotations.

There is a document from NCBI we mentioned earlier that gives the details of the structure of a GenBank record. This file is \textit{gbrel.txt} and is part of the GenBank release, available at the NCBI web site and their FTP site. It's updated with every release (every two months at present), and it includes notices of changes to the format. If you program with GenBank records, you should read this document and keep a copy around for reference use, and check periodically for announced changes in the GenBank record format.

If you look back at the complete GenBank record earlier in this chapter, you'll see that the annotations have a certain structure. You have some fields, such as LOCUS, DEFINITION, ACCESSION, VERSION, KEYWORDS, SOURCE, REFERENCE, FEATURES, and BASE COUNT that start at the beginning of a line. Some of these fields have subfields, especially the FEATURES field, which has a fairly complex structure.

But for now, let's just extract the top-level fields. You will need a regular expression that matches everything from a word at the beginning of a line to a newline that just precedes another word at the beginning of a line.

Here's a regular expression that matches our definition of a field: 

\begin{lstlisting}
/^[A-Z].*\n(^\s.*\n)*/m
\end{lstlisting}

What does this regular expression say? First of all, it has the \verb|/m| pattern matching modifier, which means the caret \verb|^| and the dollar sign \verb|$| also match around embedded newlines (not just at the beginning and end of the entire string, which is the default behavior).

The first part of the regular expression:
  
\begin{lstlisting}
^[A-Z].*\n
\end{lstlisting}

matches a capital letter at the beginning of a line, followed by any number of characters (except newlines), followed by a newline. That's a good description of the first lines of the fields you're trying to match.

The second part of the regular expression:
  
\begin{lstlisting}
(^\s.*\n)*
\end{lstlisting}

matches a space or tab \verb|\s| at the beginning of a line, followed by any number of characters (except newlines), followed by a newline. This is surrounded by parentheses and followed by a *, which means 0 or more such lines. This matches succeeding lines in a field, lines that start with whitespace. A field may have no extra lines of this sort or several such lines.

So, the two parts of the regular expression combined match the fields with their optional additional lines.

\autoref{exam:example10.6} shows a subroutine that, given the annotations section of a GenBank record stored in a scalar variable, returns a hash with keys equal to the names of the top-level fields and values equal to the contents of those fields. 

\textbf{Example 10-6. Parsing Genbank annotation}
\lstinputlisting[label=exam:example10.6]{./scripts/example10-6.pl}

In the subroutine \textit{parse\_annotation}, note how the variables \verb|$key| and \verb|$value| are scoped within the \verb|while| block. One benefit of this is that you don't have to reinitialize the variables each time through the loop.  Also note that the key is the name of the field, and the value is the whole field.

You should take the time to understand the regular expression that extracts the field name for the key: 

\begin{lstlisting}
(my $key = $value) =~ s/^([A-Z]+).*/$1/s;
\end{lstlisting}

This first assigns \verb|$key| the value \verb|$value|. It then replaces everything in \verb|$key| (note the \verb|/s| modifier for embedded newlines) with \verb|$1|, which is a special variable pattern between the first pair of parentheses (\verb|[A-Z]+|).  This pattern is one or more capital letters (anchored to the beginning of the string, i.e., the field name), so it sets \verb|$key| to the value of the first word in the field name.

You get the following output from \autoref{exam:example10.6} (the test just fetches the first record in the GenBank library): 

\begin{lstlisting}
******** SOURCE *********
SOURCE      Homo sapiens embryo male lung fibroblast cell_line:HuS-L12 cDNA to
            mRNA.
  ORGANISM  Homo sapiens
            Eukaryota; Metazoa; Chordata; Craniata; Vertebrata; Euteleostomi;
            Mammalia; Eutheria; Primates; Catarrhini; Hominidae; Homo.
******** DEFINITION *********
DEFINITION  Homo sapiens PCCX1 mRNA for protein containing CXXC domain 1,
            complete cds.
******** KEYWORDS *********
KEYWORDS    .
******** VERSION *********
VERSION     AB031069.1  GI:8100074
******** FEATURES *********
FEATURES             Location/Qualifiers
     source          1..2487
                     /organism="Homo sapiens"
                     /db_xref="taxon:9606"
                     /sex="male"
                     /cell_line="HuS-L12"
                     /cell_type="lung fibroblast"
                     /dev_stage="embryo"
     gene            229..2199
                     /gene="PCCX1"
     CDS             229..2199
                     /gene="PCCX1"
                     /note="a nuclear protein carrying a PHD finger and a CXXC
                     domain"
                     /codon_start=1
                     /product="protein containing CXXC domain 1"
                     /protein_id="BAA96307.1"
                     /db_xref="GI:8100075"
                     /translation="MEGDGSDPEPPDAGEDSKSENGENAPIYCICRKPDINCFMIGCD
                     NCNEWFHGDCIRITEKMAKAIREWYCRECREKDPKLEIRYRHKKSRERDGNERDSSEP
                     RDEGGGRKRPVPDPDLQRRAGSGTGVGAMLARGSASPHKSSPQPLVATPSQHHQQQQQ
                     QIKRSARMCGECEACRRTEDCGHCDFCRDMKKFGGPNKIRQKCRLRQCQLRARESYKY
                     FPSSLSPVTPSESLPRPRRPLPTQQQPQPSQKLGRIREDEGAVASSTVKEPPEATATP
                     EPLSDEDLPLDPDLYQDFCAGAFDDHGLPWMSDTEESPFLDPALRKRAVKVKHVKRRE
                     KKSEKKKEERYKRHRQKQKHKDKWKHPERADAKDPASLPQCLGPGCVRPAQPSSKYCS
                     DDCGMKLAANRIYEILPQRIQQWQQSPCIAEEHGKKLLERIRREQQSARTRLQEMERR
                     FHELEAIILRAKQQAVREDEESNEGDSDDTDLQIFCVSCGHPINPRVALRHMERCYAK
                     YESQTSFGSMYPTRIEGATRLFCDVYNPQSKTYCKRLQVLCPEHSRDPKVPADEVCGC
                     PLVRDVFELTGDFCRLPKRQCNRHYCWEKLRRAEVDLERVRVWYKLDELFEQERNVRT
                     AMTNRAGLLALMLHQTIQHDPLTTDLRSSADR"
******** REFERENCE *********
REFERENCE   2  (bases 1 to 2487)
  AUTHORS   Fujino,T., Hasegawa,M., Shibata,S., Kishimoto,T., Imai,S. and
            Takano,T.
  TITLE     Direct Submission
  JOURNAL   Submitted (15-AUG-1999) to the DDBJ/EMBL/GenBank databases.
            Tadahiro Fujino, Keio University School of Medicine, Department of
            Microbiology; Shinanomachi 35, Shinjuku-ku, Tokyo 160-8582, Japan
            (E-mail:fujino@microb.med.keio.ac.jp,
            Tel:+81-3-3353-1211(ex.62692), Fax:+81-3-5360-1508)
******** ACCESSION *********
ACCESSION   AB031069
******** LOCUS *********
LOCUS       AB031069     2487 bp    mRNA            PRI       27-MAY-2000
******** ORIGIN *********
ORIGIN      
******** BASE *********
BASE COUNT      564 a    715 c    768 g    440 t
\end{lstlisting}

As you see, the method is working, and apart from the difficulty of reading the regular expressions (which will become easier with practice), the code is very straightforward, just a few short subroutines. 

\subsection{Parsing the FEATURES Table}
Let's take this one step further and parse the features table to its next level, composed of the \verb|source|, \verb|gene|, and \verb|CDS| \textit{features keys}. (See later in this section for a more complete list of these features keys.) In the exercises at the end of the chapter, you'll be challenged to descend further into the FEATURES table.

To study the FEATURES table, you should first look over the NCBI \textit{gbrel.txt} document mentioned previously. Then you should study the most complete documentation for the FEATURES table, available at \href{http://www.ncbi.nlm.nih.gov/collab/FT/index.html}{http://www.ncbi.nlm.nih.gov/collab/FT/index.html}.

\subsubsection{Features}
Although our GenBank entry is fairly simple and includes only three features, there are actually quite a few of them. Notice that the parsing code will find all of them, because it's just looking at the structure of the document, not for specific features.  

The following is a list of the features defined for GenBank records.  Although lengthy, I think it's important to read through it to get an idea of the range of information that may be present in a GenBank record. 

\textcolor{red}{\textit{allele}}
\begin{adjustwidth}{1cm}{}
Obsolete; see \verb|variation| feature key
\end{adjustwidth}

\textcolor{red}{\textit{attenuator}}
\begin{adjustwidth}{1cm}{}
Sequence related to transcription termination
\end{adjustwidth}

\textcolor{red}{\textit{C\_region}}
\begin{adjustwidth}{1cm}{}
Span of the C immunological feature
\end{adjustwidth}

\textcolor{red}{\textit{CAAT\_signal}}
\begin{adjustwidth}{1cm}{}
CAAT box in eukaryotic promoters
\end{adjustwidth}

\textcolor{red}{\textit{CDS}}
\begin{adjustwidth}{1cm}{}
Sequence coding for amino acids in protein (includes stop codon)
\end{adjustwidth}

\textcolor{red}{\textit{conflict}}
\begin{adjustwidth}{1cm}{}
Independent sequence determinations differ
\end{adjustwidth}

\textcolor{red}{\textit{D-loop}}
\begin{adjustwidth}{1cm}{}
Displacement loop
\end{adjustwidth}

\textcolor{red}{\textit{D\_segment}}
\begin{adjustwidth}{1cm}{}
Span of the D immunological feature
\end{adjustwidth}

\textcolor{red}{\textit{enhancer}}
\begin{adjustwidth}{1cm}{}
Cis-acting enhancer of promoter function
\end{adjustwidth}

\textcolor{red}{\textit{exon}}
\begin{adjustwidth}{1cm}{}
Region that codes for part of spliced mRNA
\end{adjustwidth}

\textcolor{red}{\textit{gene}}
\begin{adjustwidth}{1cm}{}
Region that defines a functional gene, possibly including upstream (promoter, enhancer, etc.) and downstream control elements, and for which a name has been assigned 
\end{adjustwidth}

\textcolor{red}{\textit{GC\_signal}}
\begin{adjustwidth}{1cm}{}
GC box in eukaryotic promoters
\end{adjustwidth}

\textcolor{red}{\textit{iDNA}}
\begin{adjustwidth}{1cm}{}
Intervening DNA eliminated by recombination
\end{adjustwidth}

\textcolor{red}{\textit{intron}}
\begin{adjustwidth}{1cm}{}
Transcribed region excised by mRNA splicing
\end{adjustwidth}

\textcolor{red}{\textit{J\_region}}
\begin{adjustwidth}{1cm}{}
Span of the J immunological feature
\end{adjustwidth}

\textcolor{red}{\textit{LTR}}
\begin{adjustwidth}{1cm}{}
Long terminal repeat
\end{adjustwidth}

\textcolor{red}{\textit{mat\_peptide}}
\begin{adjustwidth}{1cm}{}
Mature peptide coding region (doesn't include stop codon)
\end{adjustwidth}

\textcolor{red}{\textit{misc\_binding}}
\begin{adjustwidth}{1cm}{}
Miscellaneous binding site
\end{adjustwidth}

\textcolor{red}{\textit{misc\_difference}}
\begin{adjustwidth}{1cm}{}
Miscellaneous difference feature
\end{adjustwidth}

\textcolor{red}{\textit{misc\_feature}}
\begin{adjustwidth}{1cm}{}
Region of biological significance that can't be described by any other feature 
\end{adjustwidth}

\textcolor{red}{\textit{misc\_recomb}}
\begin{adjustwidth}{1cm}{}
Miscellaneous recombination feature
\end{adjustwidth}

\textcolor{red}{\textit{misc\_RNA}}
\begin{adjustwidth}{1cm}{}
Miscellaneous transcript feature not defined by other RNA keys
\end{adjustwidth}

\textcolor{red}{\textit{misc\_signal}}
\begin{adjustwidth}{1cm}{}
Miscellaneous signal
\end{adjustwidth}

\textcolor{red}{\textit{misc\_structure}}
\begin{adjustwidth}{1cm}{}
Miscellaneous DNA or RNA structure
\end{adjustwidth}

\textcolor{red}{\textit{modified\_base}}
\begin{adjustwidth}{1cm}{}
The indicated base is a modified nucleotide
\end{adjustwidth}

\textcolor{red}{\textit{mRNA}}
\begin{adjustwidth}{1cm}{}
Messenger RNA
\end{adjustwidth}

\textcolor{red}{\textit{mutation}}
\begin{adjustwidth}{1cm}{}
Obsolete: see \verb|variation| feature key
\end{adjustwidth}

\textcolor{red}{\textit{N\_region}}
\begin{adjustwidth}{1cm}{}
Span of the N immunological feature
\end{adjustwidth}

\textcolor{red}{\textit{old\_sequence}}
\begin{adjustwidth}{1cm}{}
Presented sequence revises a previous version
\end{adjustwidth}

\textcolor{red}{\textit{polyA\_signal}}
\begin{adjustwidth}{1cm}{}
Signal for cleavage and polyadenylation
\end{adjustwidth}

\textcolor{red}{\textit{polyA\_site}}
\begin{adjustwidth}{1cm}{}
Site at which polyadenine is added to mRNA
\end{adjustwidth}

\textcolor{red}{\textit{precursor\_RNA}}
\begin{adjustwidth}{1cm}{}
Any RNA species that isn't yet the mature RNA product
\end{adjustwidth}

\textcolor{red}{\textit{prim\_transcript}}
\begin{adjustwidth}{1cm}{}
Primary (unprocessed) transcript
\end{adjustwidth}

\textcolor{red}{\textit{primer}}
\begin{adjustwidth}{1cm}{}
Primer binding region used with PCR
\end{adjustwidth}

\textcolor{red}{\textit{primer\_bind}}
\begin{adjustwidth}{1cm}{}
Noncovalent primer binding site
\end{adjustwidth}

\textcolor{red}{\textit{promoter}}
\begin{adjustwidth}{1cm}{}
A region involved in transcription initiation
\end{adjustwidth}

\textcolor{red}{\textit{protein\_bind}}
\begin{adjustwidth}{1cm}{}
Noncovalent protein binding site on DNA or RNA
\end{adjustwidth}

\textcolor{red}{\textit{RBS}}
\begin{adjustwidth}{1cm}{}
Ribosome binding site
\end{adjustwidth}

\textcolor{red}{\textit{rep\_origin}}
\begin{adjustwidth}{1cm}{}
Replication origin for duplex DNA
\end{adjustwidth}

\textcolor{red}{\textit{repeat\_region}}
\begin{adjustwidth}{1cm}{}
Sequence containing repeated subsequences
\end{adjustwidth}

\textcolor{red}{\textit{repeat\_unit}}
\begin{adjustwidth}{1cm}{}
One repeated unit of a repeat\_region
\end{adjustwidth}

\textcolor{red}{\textit{rRNA}}
\begin{adjustwidth}{1cm}{}
Ribosomal RNA
\end{adjustwidth}

\textcolor{red}{\textit{S\_region}}
\begin{adjustwidth}{1cm}{}
Span of the S immunological feature
\end{adjustwidth}

\textcolor{red}{\textit{satellite}}
\begin{adjustwidth}{1cm}{}
Satellite repeated sequence
\end{adjustwidth}

\textcolor{red}{\textit{scRNA}}
\begin{adjustwidth}{1cm}{}
Small cytoplasmic RNA
\end{adjustwidth}

\textcolor{red}{\textit{sig\_peptide}}
\begin{adjustwidth}{1cm}{}
Signal peptide coding region
\end{adjustwidth}

\textcolor{red}{\textit{snRNA}}
\begin{adjustwidth}{1cm}{}
Small nuclear RNA
\end{adjustwidth}

\textcolor{red}{\textit{source}}
\begin{adjustwidth}{1cm}{}
Biological source of the sequence data represented by a GenBank record; mandatory feature, one or more per record; for organisms that have been incorporated within the NCBI taxonomy database, an associated \verb|/db_xref="taxon:NNNN"| qualifier will be present (where \verb|NNNNN| is the numeric identifier assigned to the organism within the NCBI taxonomy database) 
\end{adjustwidth}

\textcolor{red}{\textit{stem\_loop}}
\begin{adjustwidth}{1cm}{}
Hairpin loop structure in DNA or RNA
\end{adjustwidth}

\textcolor{red}{\textit{STS}}
\begin{adjustwidth}{1cm}{}
Sequence Tagged Site: operationally unique sequence that identifies the combination of primer spans used in a PCR assay 
\end{adjustwidth}

\textcolor{red}{\textit{TATA\_signal}}
\begin{adjustwidth}{1cm}{}
TATA box in eukaryotic promoters
\end{adjustwidth}

\textcolor{red}{\textit{terminator}}
\begin{adjustwidth}{1cm}{}
Sequence causing transcription termination
\end{adjustwidth}

\textcolor{red}{\textit{transit\_peptide}}
\begin{adjustwidth}{1cm}{}
Transit peptide coding region
\end{adjustwidth}

\textcolor{red}{\textit{transposon}}
\begin{adjustwidth}{1cm}{}
Transposable element (TN)
\end{adjustwidth}

\textcolor{red}{\textit{tRNA}}
\begin{adjustwidth}{1cm}{}
Transfer RNA
\end{adjustwidth}

\textcolor{red}{\textit{unsure}}
\begin{adjustwidth}{1cm}{}
Authors are unsure about the sequence in this region
\end{adjustwidth}

\textcolor{red}{\textit{V\_region}}
\begin{adjustwidth}{1cm}{}
Span of the V immunological feature
\end{adjustwidth}

\textcolor{red}{\textit{variation}}
\begin{adjustwidth}{1cm}{}
A related population contains stable mutation
\end{adjustwidth}

\textcolor{red}{\textit{-}}
\begin{adjustwidth}{1cm}{}
Placeholder (hyphen)
\end{adjustwidth}

\textcolor{red}{\textit{-10\_signal}}
\begin{adjustwidth}{1cm}{}
Pribnow box in prokaryotic promoters
\end{adjustwidth}

\textcolor{red}{\textit{-35\_signal}}
\begin{adjustwidth}{1cm}{}
-35 box in prokaryotic promoters
\end{adjustwidth}

\textcolor{red}{\textit{3'clip}}
\begin{adjustwidth}{1cm}{}
3'-most region of a precursor transcript removed in processing
\end{adjustwidth}

\textcolor{red}{\textit{3'UTR}}
\begin{adjustwidth}{1cm}{}
3' untranslated region (trailer)
\end{adjustwidth}

\textcolor{red}{\textit{5'clip}}
\begin{adjustwidth}{1cm}{}
5'-most region of a precursor transcript removed in processing
\end{adjustwidth}

\textcolor{red}{\textit{5'UTR}}
\begin{adjustwidth}{1cm}{}
5' untranslated region (leader)
\end{adjustwidth}

These feature keys can have their own additional features, which you'll see here and in the exercises. 

\subsubsection{Parsing}
\autoref{exam:example10.7} finds whatever features are present and returns an array populated with them. It doesn't look for the complete list of features as presented in the last section; it finds just the features that are actually present in the GenBank record and returns them for further use.

It's often the case that there are multiple instances of the same feature in a record. For instance, there may be several exons specified in the FEATURES table of a GenBank record. For this reason we'll store the features as elements in an array, rather than in a hash keyed on the feature name (as this allows you to store, for instance, only one instance of an exon).

\textbf{Example 10-7. Testing subroutine parse\_features}
\lstinputlisting[label=exam:example10.7]{./scripts/example10-7.pl}

\autoref{exam:example10.7} gives the output:

\begin{lstlisting}
******** source *********
      source          1..2487
                      /organism="Homo sapiens"
                      /db_xref="taxon:9606"
                      /sex="male"
                      /cell_line="HuS-L12"
                      /cell_type="lung fibroblast"
                      /dev_stage="embryo"
******** gene *********
      gene            229..2199
                      /gene="PCCX1"
******** CDS *********
      CDS             229..2199
                      /gene="PCCX1"
                      /note="a nuclear protein carrying a PHD finger and a CXXC
                      domain"
                      /codon_start=1
                      /product="protein containing CXXC domain 1"
                      /protein_id="BAA96307.1"
                      /db_xref="GI:8100075"
                      /translation="MEGDGSDPEPPDAGEDSKSENGENAPIYCICRKPDINCFMIGCD
                      NCNEWFHGDCIRITEKMAKAIREWYCRECREKDPKLEIRYRHKKSRERDGNERDSSEP
                      RDEGGGRKRPVPDPDLQRRAGSGTGVGAMLARGSASPHKSSPQPLVATPSQHHQQQQQ
                      QIKRSARMCGECEACRRTEDCGHCDFCRDMKKFGGPNKIRQKCRLRQCQLRARESYKY
                      FPSSLSPVTPSESLPRPRRPLPTQQQPQPSQKLGRIREDEGAVASSTVKEPPEATATP
                      EPLSDEDLPLDPDLYQDFCAGAFDDHGLPWMSDTEESPFLDPALRKRAVKVKHVKRRE
                      KKSEKKKEERYKRHRQKQKHKDKWKHPERADAKDPASLPQCLGPGCVRPAQPSSKYCS
                      DDCGMKLAANRIYEILPQRIQQWQQSPCIAEEHGKKLLERIRREQQSARTRLQEMERR
                      FHELEAIILRAKQQAVREDEESNEGDSDDTDLQIFCVSCGHPINPRVALRHMERCYAK
                      YESQTSFGSMYPTRIEGATRLFCDVYNPQSKTYCKRLQVLCPEHSRDPKVPADEVCGC
                      PLVRDVFELTGDFCRLPKRQCNRHYCWEKLRRAEVDLERVRVWYKLDELFEQERNVRT
                      AMTNRAGLLALMLHQTIQHDPLTTDLRSSADR
\end{lstlisting}

In subroutine \verb|parse_features| of \autoref{exam:example10.7}, the regular expression that extracts the features is much like the regular expression used in \autoref{exam:example10.6} to parse the top level of the annotations. Let's look at the essential parsing code of \autoref{exam:example10.7}: 

\begin{lstlisting}
while( $features =~ /^ {5}\S.*\n(^ {21}\S.*\n)*/gm ) {
\end{lstlisting}

On the whole, and in brief, this regular expression finds features formatted with the first lines beginning with 5 spaces, and optional continuation lines beginning with 21 spaces.

First, note that the pattern modifier \verb|/m| enables the \verb|^| metacharacter to match after embedded newlines. Also, the \verb|{5}| and \verb|{21}| are quantifiers that specify there should be exactly 5, or 21, of the preceding item, which in both cases is a space. 

The regular expression is in two parts, corresponding to the first line and optional continuation lines of the feature. The first part \verb|^ {5}\S.*\n| means that the beginning of a line (\verb|^|) has 5 spaces (\verb|{5}|), followed by a non-whitespace character (\verb|\S|) followed by any number of non-newlines (\verb|.*|) followed by a newline (\verb|\n|). The second part of the regular expression, \verb|(^ {21}\S.*\n)*| means the beginning of a line (\verb|^|) has 21 spaces (\verb|{21}|) followed by a non-whitespace character (\verb|\S|) followed by any number of non-newlines (\verb|.*|) followed by a newline (\verb|\n|); and there may be \verb|0| or more such lines, indicated by the \verb|()*| around the whole expression. 

The main program has a short regular expression along similar lines to extract the feature name (also called the feature key) from the feature.

So, again, success. The FEATURES table is now decomposed or "parsed" in some detail, down to the level of separating the individual features.  The next stage in parsing the FEATURES table is to extract the detailed information for each feature. This includes the location (given on the same line as the feature name, and possibly on additional lines); and the qualifiers indicated by a slash, a qualifier name, and if applicable, an equals sign and additional information of various kinds, possibly continued on additional lines.

I'll leave this final step for the exercises. It's a fairly straightforward extension of the approach we've been using to parse the features. You will want to consult the documentation from the NCBI web site for complete details about the structure of the FEATURES table before trying to parse the location and qualifiers from a feature.

The method I've used to parse the FEATURES table maintains the structure of the information. However, sometimes you just want to see if some word such as "endonulease" appears anywhere in the record. For this, recall that you created a \verb|search_annotation| subroutine in \autoref{exam:example10.5} that searches for any regular expression in the entire annotation; very often, this is all you really need. As you've now seen, however, when you really need to dig into the FEATURES table, Perl has its own features that make the job possible and even fairly easy. 

\section{Indexing GenBank with DBM}
DBM stands for Database Management. Perl provides a set of built-in functions that give Perl programmers access to DBM files. 

\subsection{DBM Essentials}
When you open a DBM file, you access it like a hash: you give it keys and it returns values, and you can add and delete key-value pairs.  What's useful about DBM is that it saves the key-value data in a permanent disk file on your computer. It can thus save information between the times you run your program; it can also serve as a way to share information between different programs that need the same data. A DBM file can get very big without killing the main memory on your computer and making your program—and everything else—slow to a crawl.

There are two functions, \textit{dbmopen} and \textit{dbmclose}, that "tie" a hash to a DBM file; then you just use the hash. As you've seen, with a hash, lookups are easy, as are definitions. You can get a list of all the keys from a hash called \verb|%my_hash| by typing \verb|keys %my_hash|. You then can get a list of all values by typing \verb|values %my_hash|. For large DBM files, you may not want to do this; the Perl function \verb|each| allows you to read key-value pairs one at a time, thus saving the memory of your running program. There is also a \textit{delete} function to remove the definitions of keys: 

\begin{lstlisting}
delete $my_hash{'DNA'}
\end{lstlisting}

entirely removes that key from the hash.

DBM files are a very simple database. They don't have the power of a relational database such as \textit{MySQL}, \textit{Oracle}, or \textit{PostgreSQL}; however, it's remarkable how often a simple database is all that a problem really needs. When you have a set of key-value data (or several such sets), consider using DBM. It's certainly easy to use with Perl.

The main wrinkle to using DBM is that there are several, slightly different DBM implementations—NDBM, GDBM, SDBM, and Berkeley DB. The differences are small but real; but for most purposes, the implementations are interchangeable. Newer versions of Perl give you Berkeley DB by default, and it's easy to get it and install it for your Perl if you want. If you don't have really long keys or values, it's not a problem. Some older DBMs require you to add null bytes to keys and delete them from values: 

\begin{lstlisting}
$value = $my_hash{"$key\0"};
chop $value;
\end{lstlisting}

Chances are good that you won't have to do that. Berkeley DB handles long strings well (some of the other DBM implementations have limits), and because you have some potentially long strings in biology, I recommend installing Berkeley DB if you don't have it.

\subsection{A DBM Database for GenBank}
You've seen how to extract information from a GenBank record or from a library of GenBank records. You've just seen how DBM files can save your hash data on your hard disk between program runs. You've also seen the use of \verb|tell| and \verb|seek| to quickly access a location in a file.

Now let's combine the three ideas and use DBM to build a database of information about a GenBank library. It'll be something simple: you'll extract the accession numbers for the keys and store the byte offsets in the GenBank library of records for the values. You'll add some code that, given a library and an offset, returns the record at that offset, and write a main program that allows the user to interactively request GenBank records by accession number. When complete, your program should very quickly return a GenBank record if given its accession number.

This general idea is extended in the exercises at the end of the chapter to a considerable extent; you may want to glance ahead at them now to get an idea of the potential power of the technique I'm about to present.

With just the appropriate amount of further ado, here is a code fragment that opens (creating if necessary) a DBM file: 

\begin{lstlisting}
unless(dbmopen(%my_hash, 'DBNAME', 0644)) {
  
  print "Cannot open DBM file DBNAME with mode 0644\n";
  exit;

}
\end{lstlisting}

\verb|%my_hash| is like any other hash in Perl, but it will be tied to the DBM file with this statement. \verb|DBNAME| is the basename of the actual DBM files that will be created. Some DBM versions create one file of exactly that name; others create two files with file extensions \textit{.dir} and \textit{.pag}.

Another parameter is called the mode. Unix or Linux users will be familiar with file permissions in this form. Many possibilities exist; here are the most common ones: 

\textcolor{red}{\textit{0644}}
\begin{adjustwidth}{1cm}{}
You can read and write; others can just read.
\end{adjustwidth}

\textcolor{red}{\textit{0600}}
\begin{adjustwidth}{1cm}{}
Only you can read or write.
\end{adjustwidth}

\textcolor{red}{\textit{0666}}
\begin{adjustwidth}{1cm}{}
Anyone can read or write.
\end{adjustwidth}

\textcolor{red}{\textit{0444}}
\begin{adjustwidth}{1cm}{}
Anyone can read (nobody can write).
\end{adjustwidth}

\textcolor{red}{\textit{0400}}
\begin{adjustwidth}{1cm}{}
Only you can read (nobody else can do anything).
\end{adjustwidth}

The \textit{dbmopen} call fails if you try to open a file with a mode that assumes there are more permissions than were conferred on the DBM file when it was created. Usually, the mode 0644 is declared by the owner if only the owner should be allowed to write, and 0444 is declared by readers. Mode 0666 is declared by the owner and others if the file is meant to be read or written by anyone.

That's pretty much it; DBM files are that simple. \autoref{exam:example10.8} displays a DBM file that stores key-value pairs of accession numbers of GenBank records for keys, and byte offsets of the records as values. 

\textbf{Example 10-8. A DBM index of a GenBank library}
\lstinputlisting[label=exam:example10.8]{./scripts/example10-8.pl}

Here's the truncated output of \autoref{exam:example10.8}:

\begin{lstlisting}
Here are the available accession numbers:
XM_006271
NM_021964
XM_009873
AB031069
XM_006269
Enter accession number (or quit): NM_021964
LOCUS       NM_021964    3032 bp    mRNA            PRI       14-MAR-2001
DEFINITION  Homo sapiens zinc finger protein 148 (pHZ-52) (ZNF148), mRNA.
...
//

Enter accession number (or quit): q
\end{lstlisting}

\section{Exercises}
\textcolor{red}{\textit{Exercise 10.1}}
\begin{adjustwidth}{1cm}{}
Go to the NCBI, EMBL, and EBI web sites and become familiar with their use. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.2}}
\begin{adjustwidth}{1cm}{}
Read the GenBank format documentation, \textit{gbrel.txt}.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.3}}
\begin{adjustwidth}{1cm}{}
Write a subroutine that passes a hash by value. Now rewrite it to pass the hash by reference. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.4}}
\begin{adjustwidth}{1cm}{}
Design a module of subroutines to handle the following kinds of data: a flat file containing records consisting of gene names on a line and extra information of any sort on succeeding lines, followed by a blank line. Your subroutines should be able to read in the data and then do a fast lookup on the information associated with a gene name. You should also be able to add new records to the flat file. Now reuse this module to build an address book program. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.5}}
\begin{adjustwidth}{1cm}{}
Descend further into the FEATURES table. Parse the features in the table into their next level by parsing the feature names, locations, and qualifiers. Check the document \textit{gbrel.txt} for definitions of the structures of the fields. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.6}}
\begin{adjustwidth}{1cm}{}
Write a program that takes a long DNA sequence as input and outputs the counts of all four-base subsequences (256 of them in all), sorted by frequency. A four-base subsequence starts at each location 1, 2, 3, and so on. (This kind of word-frequency analysis is common to many fields of study, including linguistics, computer science, and music.) 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.7}}
\begin{adjustwidth}{1cm}{}
Extend the program in Exercise 10.6 to count all the sequences in a GenBank library. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.8}}
\begin{adjustwidth}{1cm}{}
Given an amino acid, find the frequency of occurrence of the adjacent amino acids coded in a DNA sequence; or in a GenBank library. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.9}}
\begin{adjustwidth}{1cm}{}
Extract all the words (excluding words like "the" or other unnecessary words) from the annotation of a library of GenBank records. For each word found, add the offset of the GenBank record in the library to a DBM file that has keys equal to the words, and values that are strings with offsets separated by spaces. In other words, one key can have a space-separated list of offsets for a value. Then you can quickly find all records containing a word like "fibroblast" with a simple lookup, followed by extracting the offsets and seeking into the library with those offsets. How big is your DBM file compared to the GenBank library?  What might be involved in constructing a search engine for the annotations in all of GenBank? For human DNA only? 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 10.10}}
\begin{adjustwidth}{1cm}{}
Write a program to make a custom library of oncogenes from the GBPRI division of GenBank. 
\end{adjustwidth}

