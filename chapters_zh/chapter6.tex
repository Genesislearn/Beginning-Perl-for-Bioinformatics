\chapter{子程序和Bugs}
\label{chap:chapter6}
\minitoc

在本章中，你将学习到以下两个主题的基础知识：

\begin{itemize}
  \item 子程序
  \item 使用Perl调试器
\end{itemize}

子程序是结构化组织程序的一个重要方法。\autoref{chap:chapter7}将学习如何通过随机化来模拟DNA的突变，在那里你将使用到子程序。Perl调试器会用“慢镜头”的形式来检查一个程序的行为，帮助你找到那些讨厌的bugs。

\section{子程序}
子程序是结构化组织程序的一个重要方法，所有主流的编程语言中都使用子程序。

\textit{子程序}把一些代码包裹起来，给它起一个名字，并提供方法把一些值提供给它进行计算，然后返回计算结果。这样程序的其余部分就可以仅仅通过使用它的名字来使用子程序中的代码了，把需要的值传递给子程序代码并收集运算结果。这种子程序的使用或“调用”通常称作\textit{调用}子程序。你可以把子程序看做程序中的一个程序，就像你运行程序得到结果一样，程序调用子程序得到结果。一旦你有了一个子程序，就可以在程序中使用它了，只需要知道传递哪些值、收集哪种类型的值就行了。

\subsection{子程序的优势}
子程序提供了一些好处。它赋予了程序抽象化和模块化的能力，通过把代码组织成有特定输入输出的代码块就可以创建大的程序了。

假设你需要计算一些东西，比如在一个或多个不同程序的多个地方计算分布的平均值。通过把这种计算编写成子程序，只需要写一次，你就可以在任何需要它的时候调用它了，这会使你的程序：

\begin{itemize}
  \item 更短，因为你在重用代码。
  \item 更容易测试，因为你可以单独对子程序进行测试。
  \item 更容易理解，因为它使得程序具有良好的组织、更加简洁。
  \item 更加稳健，因为重用子程序使得代码量减少了，出错的几率也小了。
  \item 编写起来更加快速，因为你可能已经编写了好多进行基本统计的子程序，这样你就可以直接调用计算平均值的那个子程序而不用重写了。还有更好的一种可能，你找到了一个别人编写的很好的统计学库，这样你就完全不用自己去写了。
\end{itemize}

还一个更加微妙的事情，也这正是它的强大之处。子程序本身就可以调用其他的子程序，也就是说，一个子程序可以根据计算需要使用其他的子程序。\footnote{子程序甚至可以调用它自己本身，这就是所谓的递归，这使得计算过程非常优雅（参看\autoref{chap:chapter11}）。}通过编写一系列的子程序，每一个子程序只做一件或很少的几件事，你可以通过各种形式把它们组合编写成新的子程序，然后你还可以继续组合这些新的子程序，依此类推，最后可能会形成一个巨大且灵活的程序系统。把问题分解成可以方便组合的一系列的子程序，使你可以创造不断增长且适应各种条件的程序，而你只需要很少的付出就可以实现这一点。

所有这一切的技巧就在于你如何把代码分割成一系列的子程序。你希望子程序能够封装一些通用且有用的东西，并且不会只被调用一次（尽管有时这也非常有用）。有一些经验法则：子程序应该只做一件事情并把它做好，并且子程序的代码最好不要超过一页或者两页。这些并不是真正的法则，例外时有发生，但它可以帮你把代码分割成易于管理的代码块，这非常适合子程序。

\subsection{编写子程序}
让我们看看子程序是如何使用及定义的吧。

要使用一个子程序，你需要把数据作为\textit{参数}传递给子程序，然后收集子程序的运算结果值。举个例子，你想要一个子程序，可以把“ACGT”附加到给定DNA的末尾，并返回得到的新的、更长的DNA。让我们把这个子程序叫做\textit{addACGT}吧。在Perl中，你要调用一个子程序，通常只需要键入它的名字，并在后面跟上用小括号包裹起来的参数列表就可以了（如果有参数的话）。比如，这是带着\verb|$dna|这个参数调用\verb|addACGT|子程序的方法：

\begin{lstlisting}
addACGT($dna);
\end{lstlisting}

当调用子程序时，较旧版本的Perl要求在子程序名称的前面加上\&字符（与字符）。现在这样写也是可以的（比如携程：\textit{\&addACGT}），但如今一般都把与字符省略掉。\footnote{即使在较新版本的Perl中，有时也需要加上与字符。在\autoref{chap:chapter11}的\autoref{sect:section11.2.3}中你会看到这样的例子，那一小节介绍的是\textit{File::Find}模块。（还可以参看文档中的\textit{defined}和\textit{undef}函数，或者\textit{perlref}手册页）。}

\autoref{exam:example6.1}演示了一个子程序，从中可以看到它的工作细节。

\textbf{例6-1：把ACGT附加到DNA上的子程序}
\lstinputlisting[label=exam:example6.1]{./scripts/example6-1.pl}

\autoref{exam:example6.1}会产生这样的输出：

\begin{lstlisting}
I added ACGT to CGACGTCTTCTCAGGCGA and got CGACGTCTTCTCAGGCGAACGT
\end{lstlisting}

现在我们来看看这些代码，看看子程序是如何被定义的、以及在Perl程序中使用的。

首先注意的一点，从宏观上来看，程序现在有两小部分。第一部分从程序的开头开始，到\verb|exit|命令结束。随后的一部分是子程序的定义（为了便于理解在开头添加了大量的注释），在这个例子中，就是\textit{addACGT}子程序的定义。为了方便阅读，通常把所有的子程序定义都集中放在程序的末尾，而且会以字母顺序或其他方便的形式对子程序进行排列。

实际上，把子程序的定义放在程序中的任何地方都是合法的。这是因为Perl首先通读代码，在开始运行程序之前，做一些检查语法、学习子程序定义之类的事情。特别的，子程序代码可以紧跟在程序中使用它们的地方的后面（许多人认为法则是放在其前面，但并不需要这样）。并且，不一定非要把子程序都集中放在一起，可以散落在程序代码的各个地方。但是把它们集中放在程序末尾的这种方法，会使阅读程序更加容易一些。可能的一个例外就是，在代码的某一部分使用一个小的子程序，比如使用\textit{sort}函数时这种情况就时有发生。像这种情况，把子程序的定义放在使用它的地方，可以避免读者在子程序定义和它的使用之处两个地方来回翻页。通常，不看子程序定义而把程序整个阅读一遍会更加方便，先对程序的整个流程有个了解，需要时再回去仔细看看子程序。

如你所见，\autoref{exam:example6.1}非常简单。它首先把某个DNA保存到变量\verb|$dna|中，然后把那个变量作为参数去调用子程序，看起来就像这样：\verb|addACGT($dna)|。子函数的调用是通过它的名字来实现的，并在其后紧跟用小括号包裹起来的子程序参数。也有可能没有参数，或者有不止一个参数，这时要用逗号把它们分割开来。可以把子程序的返回值保存起来。在这个程序中，子程序的返回值保存在了叫做\verb|$longer_dna|的变量中，随后就把这个变量打印了出来，然后程序就退出了。

从程序开始到\textit{exit}语句的这一部分叫做\textit{主程序}或程序的\textit{主体}。通过查看这一部分代码，而不需要去看子程序的细节，你就可以看出程序从头到尾发生了什么。

既然你已经看完了\autoref{exam:example6.1}中的主程序，是时候去看一下子程序的定义、以及它是如何使用作用域这个概念的了。

\section{作用域和子程序}
一个子程序的定义包括三部分：子程序定义的\textit{保留字}\footnote{保留字是Perl语言中定义的基本字，如\verb|if|、\verb|while|、\verb|foreach|和\verb|sub|。}——\verb|sub|，子程序的名字——在这里是\textit{addACGT}和一个包裹在成对大括号中的\textit{代码块}。这里的代码块和前面看到的循环和条件语句中把语句集中在一起的代码块是一样的。

在\autoref{exam:example6.1}中，子程序的名字是\verb|addACGT|，而代码块就是名字后面的所有代码。下面把子程序的定义重复了一遍：

\begin{lstlisting}
sub addACGT {
  my($dna) = @_;

  $dna .= 'ACGT';
  return $dna;
}
\end{lstlisting}

现在，让我们来看看子程序的代码块吧。

一个子程序就像是单独的一个主程序的辅助程序一样，它需要有自己的变量。在本书的子程序中你将使用两种类型的变量：\footnote{在本书的子程序中，我们不会使用全局变量，全局变量能同时被主程序和子程序看到；我们也不会使用通过\verb|local|声明的变量，它和\verb|my|的作用域限制有所不同。}

\begin{itemize}
  \item 传递给子程序的参数
  \item 其他通过\verb|my|声明的变量，它们的作用域会被限制在子程序中
\end{itemize}

参数就是使用或调用子程序时传递给它的值。参数值通过\verb|@_|这个特殊变量传递给子程序，在下一小节你将会看到。

其他子程序可能使用到的变量，需要与程序其他部分使用到的变量区分开来，这样它们就只能在子程序自己的范围内发挥作用了。这可以通过使用\verb|my|声明变量来实现，稍后再对此进行详细解释。

最后，大部分子程序都通过\textit{return}函数返回它们的结果。就像我们的子程序\textit{addACGT}中\verb|return $dna;|一样，它可以返回单独的一个标量，也可以像\verb|return ($dna1, $dna2);|这样返回一个标量列表，或者像\verb|return @lines;|这样返回一个数组，等等。

\subsection{参数}
\textit{调用}子函数意味着要键入它的名字，给它适当的参数，通常还要收集它的结果。\textit{参数（argument，parameter）}\footnote{译者注：parameter是指函数定义中的参数，而argument指的是函数调用时的实际参数。简略描述为：parameter=形参(formal parameter)，argument=实参(actual parameter)。在不很严格的情况下，现在二者可以混用，一般用argument，而parameter则比较少用。While defining method, variables passed in the method are called parameters.当定义方法时，传递到方法中的变量称为参数。While using those methods, values passed to those variables are called arguments.当调用方法时，传给变量的值称为引数。（有时argument被翻译为“引数“）}通常包含子程序要计算的数据。在\autoref{exam:example6.1}中，使用参数\verb|$dna|调用子程序\textit{addACGT}：

\begin{lstlisting}
$longer_dna = addACGT($dna);
\end{lstlisting}

最基本的一点，当程序员想要使用子程序时，可以使用子程序可以接受的任何参数、你需要计算的数据（在这个例子中就是需要把\verb|ACGT|附加上去的任何DNA）、出现在子程序\verb|@_|数组中的每一个参数的值来调用它。

当使用特定参数调用子程序时，你在调用中使用的参数的名字在子程序内部就无关紧要了，只有被实际传递到子程序内部的参数的值才是最重要的。子程序通常从\verb|@_|数组中收集这些值，并把它们赋给新的变量，这些变量的名字和你调用子程序时使用的变量名可能一样、也可能不一样。唯一保持不变的是值的顺序，而非包含值的变量的名字。

下面是它的工作原理。子程序代码块的第一行是：

\begin{lstlisting}
my($dna) = @_; 
\end{lstlisting}

调用子程序时的参数的值被传递到了子程序中的特殊数组变量\verb|@_|中。因为它以\verb|@|字符开头，所以你知道这是一个数组。它有一个简短的名字“\_”，这是一个特殊的数组变量，是Perl程序预先定义好的。（你不能再为自己的数组起这样的名字了。）\verb|@_|数组包含着传递到子程序中所有的标量值，这些标量值就是调用子程序时参数的值。在这个例子中，只有一个标量值：DNA字符串，是作为参数传递给子程序的\verb|$dna|变量的值。

如果子程序有更多的参数——比如一个DNA的参数，一个相关蛋白的参数，还有一个基因名的参数——它们都被传递了进去，并在子程序内部被赋给了用\verb|my|声明的变量：

\begin{lstlisting}
my($dna,$protein,$name_of_gene) = @_;
\end{lstlisting}

如果没有参数，在子程序中就可以省略这样的语句了。

在子程序中，这个语句：

\begin{lstlisting}
my($dna) = @_;
\end{lstlisting}

执行后，传递进去的值就赋给了子程序的额变量\verb|$dna|。接下来的小节将解释为什么这个变量对于子程序来说是一个新的变量。子程序中的变量也可以起任何名字，并不一定非要和参数的名字一样，虽然这个例子中它们是一样的。关于作用域非常酷的一点就是，名字一样不一样是无所谓的。

\begin{adjustwidth}{2cm}{2cm}
  \parpic[l]{
  \includegraphics[width=1cm]{warning.png}
  }
  \noindent
  当心这个常见的错误，在子程序中为参数命名时忘记使用\verb|@_|数组，换言之，使用语句：
  \begin{lstlisting}
my($dna);
  \end{lstlisting}
  代替了
  \begin{lstlisting}
my($dna) = @_;
  \end{lstlisting}
  如果你犯了这种错误，即使已经声明了变量名，参数的值也不会出现在你的子程序中。
\end{adjustwidth}

\subsection{作用域}
通过保证子程序使用到的所有变量只在子程序中有效，你就可以安全得在任何地方调用子程序了。通过使用\verb|my|来声明这些变量，就可以使它们只在子程序中有效了。\verb|my|是Perl定义的关键字，它可以把变量限制在使用它们的代码块中（在这个例子中，这个代码块就是子程序）。\footnote{作用域有不同的类别。\verb|my|实现的类别叫做\textit{词法作用域}，也叫做\textit{静态作用域}。在Perl中还有一种方法，就是使用\textit{local}来声明变量，但你几乎总会希望使用\verb|my|。} 

把变量隐藏起来，使它们仅局限在程序的特定部分，这就是\textit{作用域}的概念。在Perl中，使用\verb|my|声明变量就是所谓的\textit{词法作用域}，这是使你的程序模块化的一个至关重要的部分。

像这样用\verb|my|来声明一个变量：

\begin{lstlisting}
my($x); 
\end{lstlisting}

或者：

\begin{lstlisting}
my $x ; 
\end{lstlisting}

或者，变量的声明和变量值的初始化一块进行：

\begin{lstlisting}
my($x) = '49'; 
\end{lstlisting}

再或者，如果你在子程序中收集一个参数：

\begin{lstlisting}
my($x) = @_; 
\end{lstlisting}

一旦通过这种方式声明了一个变量，它就只存在于声明所在的代码块中，直到代码块的末尾。所以，在一个子程序中，如果你像这样声明了所有的变量（包括参数和其他所有的变量），它们就只在子程序中有效。如果某个变量和程序别处的另一个变量同名，你也无须担心什么，因为\verb|my|声明实际上创建了一个新的变量，它只在包裹起来的代码块中有效，代码块外面使用的任何重名的变量都和它完全无关。

例子中演示的在子程序中收集参数，都用小括号把变量包裹了起来。因为\verb|@_|是一个数组，用小括号把新变量包裹起来就把它们放在了数组上下文\footnote{译者注：即列表上下文。}中，这可以保证它们能被正确地初始化（参看\autoref{chap:chapter4}）。

\begin{adjustwidth}{2cm}{2cm}
  \parpic[l]{
  \includegraphics[width=1cm]{warning.png}
  }
  \noindent
  在子程序中，永远使用\verb|my|这样的关键字来声明你的所有变量，即使这些变量并不是作为参数传递进来的。
\end{adjustwidth}

为什么使用作用域呢？\autoref{exam:example6.2}演示了不使用作用域带来的麻烦。回忆一下，子程序的优势之一就是，对于那些有用的代码只需写一次，就可以在需要的时候重复使用了。\autoref{exam:example6.2}这个程序，在主程序中的一个变量和它调用的子程序中的一个变量重名了。在你编写完主程序一段时候后（比如说半年后）再编写子程序时，或者调用别人写的子程序时，这种情况非常容易发生。

\textbf{例6-2：不使用my变量导致的陷阱}
\lstinputlisting[label=exam:example6.2]{./scripts/example6-2.pl}

\autoref{exam:example6.2}给出这样的输出：

\begin{lstlisting}
I changed all the A's in TTTTT to T's and got TTTTT 
\end{lstlisting}

我们期望的应该是这样的输出：

\begin{lstlisting}
I changed all the A's in AAAAA to T's and got TTTTT 
\end{lstlisting}

要想获得这个期望的输出，可以把子程序\textit{A\_to\_T}的定义改成下面这样，使用\verb|my|声明变量把子程序中的\verb|$dna|变成\verb|my|变量：

\begin{lstlisting}
sub A_to_T {
  my($input) = @_;
  my($dna) = $input;
  $dna =~ s/A/T/g;
  return $dna;
}
\end{lstlisting}

\autoref{exam:example6.2}错在哪儿了呢？当程序进入子程序后，使用变量\verb|$dna|进行字符串处理来把A变成T时，Perl语言看到在主程序中已经有一个叫做\verb|$dna|的变量了，因此就继续使用它了。当程序从子程序中返回后，运行\verb|print|语句时，它仍然使用这同一个（仅此一个）变量\verb|$dna|。所以，当它打印输出结果时，变量\verb|$dna|中就不是原来的DNA了，而是在子程序中经过处理已经改变了的DNA。

现在类似的事情经常会发生。程序员倾向于大量使用特定的变量名：常见的变量名如\verb|$tmp|、\verb|$temp|、\verb|$x|、\verb|$a|、\verb|$number|、\verb|$variable|、\verb|$var|、\verb|$array|、\verb|$input|、\verb|$output|、\verb|$result|、\verb|$data|、\verb|$file|、\verb|$filename|等等。生物信息学家则偏爱\verb|$dna|、\verb|$protein|、\verb|$motif|、\verb|$sequence|这样的变量名。当你开始使用别人写的子程序库、你的程序越来越庞大时，让Perl语言来考虑避免重名的问题会更加容易、也更加安全一些。

事实上，从现在开始，我们将不在使用未经声明的变量。从这里开始，我们的所有变量，即使是主程序中的变量，我们都会用\verb|my|来声明。通过在你的程序中添加下面这条指令，可以使这条纪律得到强制执行：

\begin{lstlisting}
use strict;
\end{lstlisting}

它会有这样的效果，要求把程序中的所有变量都声明为\verb|my|变量。

和学习\autoref{chap:chapter4}与\autoref{chap:chapter5}的简单而快乐的日子相比，这些代码中看似无关紧要、稍显杂乱的东西可能会让你倍感束缚，但你应该知道许多语言都要求对它们的所有变量进行声明。事实上，当你编写简短的Perl程序时，不强制使用严格的作用域还是非常方便的，比如，在你尝试教授编程时，不会想一开始就让成千上万的细节把学生压的喘不过气来。

你编写程序时不小心把变量名拼写错了，使用严格的作用域的另一个好处就会凸显出来。如果变量没有被声明过，Perl就会使用拼错的名字创建一个新的变量。程序可能不能正常工作，而且要找出问题所在可能会比较困难。通过使用严格的作用域，对于所有没有声明的、拼错的变量，Perl都会进行抱怨给出提示信息，这会节省你数小时甚至数天抓耳挠腮的工作，向惨不忍睹的代码说再见。

最后，让我们再通过\autoref{exam:example6.1}来回顾一下作用域、参数和子程序的工作原理吧。要调用子程序，需要键入它的名字\textit{addACGT}，把参数\verb|$dna|传递给它，并且通过给\verb|$longer_dna|赋值把结果（如果有的话）收集起来：

\begin{lstlisting}
$longer_dna = addACGT($dna); 
\end{lstlisting}

子程序的第一行，从特殊变量\verb|@_|中获取参数的值，并把它保存到自己的变量\verb|$dna|中，因为使用了\verb|my|，所以这个变量在子程序外是看不到的。尽管子程序外的原始变量也叫做\verb|$dna|，子程序中叫做\verb|$dna|的变量实际上是一个全新的变量（只不过名字相同而已），因为\verb|my|的使用使得它只属于子程序。这个新变量只在程序进入子程序运行时是有效地。注意\autoref{exam:example6.2}末尾\verb|print|语句的输出，尽管子程序中叫做\verb|$dna|的变量被延长了，但子程序外的原始变量\verb|$dna|并没有被改变。

\section{命令行参数和数组}
\autoref{exam:example6.3}是使用子程序的另一个程序。不需要交互式回答程序的提示，你使用命令行就可以把程序需要的信息（比如文件名，或DNA字符串）告诉它。比如，当你计划在特定时间运行程序、而你又不在的时候，这会非常有用。

\autoref{exam:example6.3}还演示了使用数组的一些更多的知识。你将看到，如何通过使用下标来访问数组中特定的元素。

对于命令行程序来说，你键入程序名，如果有参数的话，之后紧跟程序的参数，然后按Enter（或Return）键就可以使程序运行了。在\autoref{exam:example6.3}中，当用户键入程序名，它会要求在程序名后给出参数，在这个例子中，就是DNA字符串，它会计算DNA中G的数目。所以程序运行后会返回类似这样的结果：

\begin{lstlisting}
AAGGGGTTTCCC

The DNA AAGGGGTTTCCC has 4 G's in it!
\end{lstlisting}

当然，好多程序都有图形用户界面（GUI）。它会让程序占据计算机屏幕的一部分或者全部，界面通常包括菜单、按钮、从键盘键入值来设定参数的输入框之类的东西。

然而，许多程序还是从命令行运行。即使最新的基于Unix构建的MacOS
X，现在也提供了一个命令行。（尽管大多数Windows用户并不怎么使用MS-DOS命令窗口，它仍然非常有用，比如说，运行Perl程序。）如前所述，以非交互的形式运行程序，通过命令行传递参数，这可以使程序运行实现自动化，比如在半夜三更没有人真正坐在电脑前的时候运行程序。

\autoref{exam:example6.3}计算DNA字符串中G的数目。

\textbf{例6-3：通过命令行计算DNA中G的数目}
\lstinputlisting[label=exam:example6.3]{./scripts/example6-3.pl}

现在让我们看看程序是如何工作的，同时检查并解释一下其中的新特性。作为开始，注意这新的一行代码：

\begin{lstlisting}
use strict;
\end{lstlisting}

从现在开始，我将使用它来确保所有的变量都用\verb|my|进行了声明，这样就可以强制执行词法作用域了。

Perl预先设置了一些特殊变量，这样你就可以轻而易举得从命令行中使用参数了。每一个Perl程序都有一个数组变量\verb|@ARGV|，它包含了所有的命令行参数。此外，还有一个叫做\verb|$0|（是零不是字母o）的特殊变量，它包含的是在命令行中调用程序时的程序名。

注意，在\autoref{exam:example6.3}中，在\verb|$USAGE|变量中定义了一个提示信息，开头就是变量\verb|$0|的值，后面紧跟着程序需要的参数的指示。这是非常且使用的做法。如果用户没有给程序提供所需的信息，通过某种形式的测试进行检测后，程序会打印输出如何正确使用它的信息提示，然后退出。

事实上，这个程序确实进行了检测，看看在命令行上是否键入了参数。它检测\verb|@ARGV|中是否包含内容，这种情况下它会被测试为\verb|真|；或者如果它完全是空的，这种情况下它就会被测试为\verb|假|。如果程序需要用户提供一个参数，你可以使用\verb|unless|条件测试，如果\verb|@ARGV|是空的，就打印输出\verb|$USAGE|语句并退出程序：

\begin{lstlisting}
unless(@ARGV) {
  print $USAGE;
  exit;
}
\end{lstlisting}

接下来的代码演示了关于数组的一些新的东西，即，如何通过使用下标从数组中提取出一个元素。换句话说，它演示了如何获取第一个、第四个或任何一个元素。\autoref{exam:example6.3}中的代码演示了如何提取出第一个元素，如你所见，它的索引值是0：

\begin{lstlisting}
my($dna) = $ARGV[0];
\end{lstlisting}

你已经检测确保数组不是空的，那就已经知道肯定有第一个元素了。为了获取数组\verb|@ARGV|中的第一个元素，把\verb|@|换成\verb|$|，并在其后跟上用中括号包裹起来的所需的下标：第一个元素的下标是0，第二个元素的下标是1,依此类推。这个语法表明，既然你现在想看数组中的一个元素，并且它是一个标量变量，那你就使用美元符号，就像在其他标量变量上那样使用。

在\autoref{exam:example6.3}中，你把命令行数组\verb|@ARGV|的第一个（也是唯一的一个）元素复制到了变量\verb|$dna|中。

最后是子程序的调用，其中并没有什么新的东西，但却实现了\autoref{chap:chapter5}最后一段的梦想：

\begin{lstlisting}
my($num_of_Gs) = countG ( $dna );
\end{lstlisting}

\section{传递数据给子程序}
在后续章节中，当开始解析GenBank、PDB和BLAST文件时，你将需要向子程序传递更加复杂的参数，来从记录数据中解析出多个字段。接下来的几个小节将演示在Perl是如何实现这一点的。你可以跳过这一小节，等学习到\autoref{chap:chapter10}的时候再回来仔细阅读。

\subsection{子程序：通过值传递}
到目前为止，我们所有的子程序的参数都非常简单。这些参数的值被复制并传递给子程序，而且子程序中这些值的变化不会影响到主程序中相应参数的值。这叫做\textit{通过值传递}或者\textit{通过值调用}。举个例子：

\begin{lstlisting}
#!/usr/bin/perl -w
# Example of pass-by-value (a.k.a. call-by-value)

use strict;

my $i = 2;

simple_sub($i);

print "In main program, after the subroutine call, \$i equals $i\n\n";

exit;

################################################################################
# Subroutines
################################################################################
sub simple_sub {

  my($i) = @_;

  $i += 100;

  print "In subroutine simple_sub, \$i equals $i\n\n";
}
\end{lstlisting}

这会得到下面的输出：

\begin{lstlisting}
In subroutine simple_sub, $i equals 102

In main program, after the subroutine call, $i equals 2
\end{lstlisting}

\subsection{子程序：通过引用传递}
如果你的参数更加复杂，比如说混合了标量、数组和散列，对于Perl来说通常不能把它们区分开来。Perl把所有的参数当成一个单独的数组，就是\verb|@_|这个特殊数组，传递给子程序，如果参数中数组或者散列，在子程序中，它们的元素就会“扁平化”后保存进\verb|@_|这一个数组中。下面是一个例子：

\begin{lstlisting}
#!/usr/bin/perl -w
# Example of problem of pass-by-value with two arrays

use strict;

my @i = ('1', '2', '3');
my @j = ('a', 'b', 'c');

print "In main program before calling subroutine: i = " .  "@i\n";
print "In main program before calling subroutine: j = " .  "@j\n";

reference_sub(@i, @j);

print "In main program after calling subroutine: i = " .  "@i\n";
print "In main program after calling subroutine: j = " .  "@j\n";

exit;

################################################################################
# Subroutines
################################################################################

sub reference_sub {

  my(@i, @j) = @_;

  print "In subroutine : i = " . "@i\n";
  print "In subroutine : j = " . "@j\n";

  push(@i, '4');

  shift(@j);
}
\end{lstlisting}

下面的输出说明这种方法存在问题：

\begin{lstlisting}
In main program before calling subroutine: i = 1 2 3
In main program before calling subroutine: j = a b c
In subroutine : i = 1 2 3 a b c
In subroutine : j = 
In main program after calling subroutine: i = 1 2 3
In main program after calling subroutine: j = a b c
\end{lstlisting}

如你所见，在子程序中，\verb|@i|和\verb|@j|中的所有元素都被组合进了\verb|@_|这个数组中。你开始使用的这两个数组之间的区别，在子程序中荡然无存。当你通过下面这一语句试图把这两个数组找回来时：

\begin{lstlisting}
my(@i, @j) = @_;
\end{lstlisting}

Perl把所有的元素都赋给了第一个数组\verb|@i|。这种行为使得向子程序中传递多个数组变得有些不确定。

此外，一切照旧，因为你使用了词法作用域（\verb|my|变量），主程序中原始的数组并不会被子程序所影响。

为了避免这种问题，你可以以一种叫做\textit{通过引用传递}或\textit{通过引用调用}的方式向子程序中传递参数。通过使用引用，你可以向子程序中传递标量、数组、散列等各种组合形式的参数，子程序可以将它们区分开来。这也是有代价的：代码看起来会有一些复杂。但它的回报通常值得我们这么去做。

通过引用传递的参数的行为有一个很大的不同。当以这种形式传递参数变量时，在子程序中你对参数变量值做的任何事情都会影响到主程序中参数的值。

要调用一个以引用形式传递参数的子程序时，方法和以前一样，但有一点不同：你必须在变量名前加一个反斜线。在本节通过引用传递参数的例子中，可以像这样实现子程序的调用：

\begin{lstlisting}
reference_sub(\@i, \@j);
\end{lstlisting}

就像你在这里看到的一样，参数是两个数组，为了保持传递给\textit{reference\_sub}子程序后两者的区别，通过引用的形式进行了传递，方法就是在它们的名字前加上反斜线。

在子程序中，也有一些变化。首先，参数从\verb|@_|数组中收集起来，并保存为标量变量，这是因为不管引用的是标量、数组、散列或者其他什么，引用都是存储在标量变量中的一种特殊类型的数据。如下所示，进行参数的收集：

\begin{lstlisting}
my($i, $j) = @_;
\end{lstlisting}


从\verb|@_|数组中读取参数后，保存为标量。

对于这些引用的参数，子程序还要进行进一步的处理。当使用它们时，需要对它们进行解引用。要解引用一个被引用的参数，你需要在引用前添加上表明变量类型的符号：对于标量来说是\verb|$|，对于数组来说是\verb|@|，对于散列来说是\verb|%|。所以在这些变量的名字前有两个符号：从左到右分别是它们本来的符号和表明这个变量是引用的\verb|$|符号。这些行：

\begin{lstlisting}
push(@$i, '4');
shift(@$j);
\end{lstlisting}

就是子程序中操作变量的代码。\textit{push}向\verb|@i|数组的末尾添加了'4'这个元素，而\textit{shift}则移除了\verb|@j|数组的第一个元素。因为这些数组是以引用的形式传递进来的，所以在子程序中它们的名字就是\verb|@$i|和\verb|@$j|。（如果你想看一下\verb|@j|数组的第三个元素，通常情况下它就是\verb|$j[2]|，所以你应该使用\verb|$j[2]|。）

在子程序中你对参数做的任何改变都会在主程序中产生影响。因为引用就是对实际参数的引用，它们并不是通过值进行传递时它们的值的拷贝。所以，就像你在例子中看到的那样，在调用子程序后，主程序中的数组也被相应的改变了：

\begin{lstlisting}
#!/usr/bin/perl
# Example of pass-by-reference (a.k.a. call-by-reference)

use strict;
use warnings;

my @i = ('1', '2', '3');
my @j = ('a', 'b', 'c');

print "In main program before calling subroutine: i = " .  "@i\n";
print "In main program before calling subroutine: j = " .  "@j\n";

reference_sub(\@i, \@j);

print "In main program after calling subroutine: i = " .  "@i\n";
print "In main program after calling subroutine: j = " .  "@j\n";

exit;

################################################################################
# Subroutines
################################################################################

sub reference_sub {
  my($i, $j) = @_;

  print "In subroutine : i = " . "@$i\n";
  print "In subroutine : j = " . "@$j\n";

  push(@$i, '4');
  shift(@$j);
}
\end{lstlisting}

This gives the following output:

\begin{lstlisting}
In main program before calling subroutine: i = 1 2 3
In main program before calling subroutine: j = a b c
In subroutine : i = 1 2 3
In subroutine : j = a b c
In main program after calling subroutine: i = 1 2 3 4
In main program after calling subroutine: j = b c
\end{lstlisting}

现在，子程序可以区分开作为参数传递进去的两个数组了。在子程序中对变量进行的修改，在子程序结束后回到主程序中时仍然有效。这是通过引用传递的基本属性。

\section{模块和子程序库}
当开始收集子程序时，你会发现自己在不断地把它们从现有的程序中复制粘贴到新的程序中。这样，子程序就出现了许多程序中。这会使你的程序代码列表显得有些繁琐和重复。这也会使子程序的修改变得更加复杂，因为你不得不修改所有的子程序拷贝。

总之，子程序非常棒，但如果你不得不把它们复制粘贴到你写的每一个新程序中，那就太麻烦了。所以是时候开始把子程序收集到一个便于使用的文件中了，这就是\textit{模块}或者\textit{库}.

这是它的工作原理。你把所有可以重复使用的子程序放进一个单独的文件里。（或者，随着你编写越来越多的代码，事情会变得复杂起来，你可能会想把它们组织到不同的文件中。）之后在你的程序只需要把文件的名字写上，然后说声\textit{变}：子程序的定义就被读进来了，就像它们本身就在你的程序中一样。要实现这一点，使用Perl的内置函数\textit{use}即可，它会把子程序的库文件读进来。

让我们把这个模块叫做\textit{BeginPerlBioinfo.pm}吧。你可以把所有的子程序定义都放在里面，就像它们出现在程序代码中一样。然后就像在本书的学习过程中键入子程序的定义，你就可以创建模块了；或者，更加简便的方法，从属鸡的网页上直接把它下载下来。但需要牢记一点，当创建模块或者向模块中添加东西时，\textit{模块的最后一行必须是\texttt{1;}，否则它不会工作}。这个\verb|1;|应该是\textit{.pm}文件的最后一行，而不是最后一个子程序的一部分。如果你忘记了这一行，你会看到类似这样的错误信息：

\begin{lstlisting}
BeginPerlBioinfo.pm did not return a true value at jkl line 14.
BEGIN failed--compilation aborted at jkl line 14.
\end{lstlisting}

现在，要使用\textit{BeginPerlBioinfo.pm}中的任何子程序，你只需要在靠近代码顶部（靠近\verb|use strict|语句）的地方中加上这样一条语句：

\begin{lstlisting}
use BeginPerlBioinfo;
\end{lstlisting}

注意名字中故意去掉了\textit{.pm}：它是Perl处理模块名的方式。

最后还有一点需要知道，使用模块载入子程序时，Perl程序需要知道到哪里去找到这个模块。如果你在同一个文件夹中进行所有的工作，一切都没有问题。如果Perl抱怨没法找到\textit{BeginPerlBioinfo.pm}，那就给出模块的全路径名吧。如果全路径名是\textit{/home/tisdall/book/BeginPerlBioinfo.pm}，在程序中就可以这样写：

\begin{lstlisting}
use lib '/home/tisdall/book';
use BeginPerlBioinfo;
\end{lstlisting}

还有其他告诉Perl去哪里寻找模块的方法，去查阅一下\verb|use|的Perl文档吧。

在\autoref{chap:chapter8}的开头，我会定义子程序并给出代码，但你应该把它们放到模块中，然后键入：

\begin{lstlisting}
use BeginPerlBioinfo;
\end{lstlisting}

在书籍的网站上也可以下载到这个模块。

\section{修复代码中的Bugs}
现在让我们谈谈，当你的程序出现问题时，该如何去处理。

一个程序会因为各种各样的原因出现问题。也许它完全无法运行。看一下错误信息，尤其是错误信息的第一行或前两行，通常它会带你找到问题的所在，将是语法的某个地方，同时它还会给出相应的解决办法，就是使用正确的语法（举例来说，括号要配对，或者，每一个语句都要以一个分号结尾）。

你的程序可能会运行，但不是你期望的那样。然后你发现程序的逻辑存在一定的问题。可能在某种情况下，你应该买的时候却卖了，比如应该相减却相加了，或者当你想用==测试两个数字是否相等时却使用了赋值操作符=。再或者，问题可能在于你完成任务的方案设计存在缺陷，只有当你实际尝试它的时候缺陷才会暴露出来。

然而，有的时候问题可能不是明显，这时你就不得不开挂了。

幸运的是，Perl有好多方法可以帮助你寻找并修复程序中的bugs。语句\verb|use strict;|和\verb|use warnings;|的使用应该成为一种习惯，因为使用它们你可以捕获许多错误。Perl调试器则给了你完全的自由，可以在程序运行时对程序进行详细的检查。

\subsection{use warnings;和use strict;}
一般来说，当程序的语法出现错误时，可以很容易的进行识别，因为Perl解释器给出的错误信息通常就可以指引你找到问题的所在。但是当程序不以你期望的形式工作时，要找到问题所在通常会更加困难一些。如果你开启了警告功能、并且强制使用严格的声明，许多这样的问题都可以被捕获。

你可能注意到了，到现在为止，本书中出现的所有程序都以这样的命令解释器行起始：

\begin{lstlisting}
#!/usr/bin/perl -w
\end{lstlisting}

\verb|-w|开启了Perl的警告功能，这会尝试寻找代码中潜在的问题，并对此给出警告。它会找出常见的问题，比如声明了不止一次的变量之类的问题，以及不是语法错误但会导致bugs的东西。

开启警告的另外一种方法就是在靠近程序顶部的地方加上下面这个语句：

\begin{lstlisting}
use warnings;
\end{lstlisting}

如果你使用的Perl的版本比较老，\verb|use warnings;|语句可能在其中并不存在。所以如果你的Perl对此进行抱怨，那就把这个语句删掉，用\textit{-w}命令来替代吧。你既可以在命令解释器行上使用它，也可以在命令行中使用它：

\begin{lstlisting}[language=bash]
$ perl -w my_program
\end{lstlisting}

然而，在不同的操作系统之间，使用\verb|use warnings;|会更加灵活一些。所以，从现在开始，这就是我在代码中开启警告功能的方式。另外一个你应该使用的重要的帮手是下面这个语句，也把它放在靠近程序顶部（紧邻\verb|use warnings;|）的地方：

\begin{lstlisting}
use strict;
\end{lstlisting}

前面已经提到，这会强制你去声明变量。（它还有一些选项，但那已经超出本书的范围了。）它会找到拼错的变量、会干扰程序其他部分的未声明的变量，等等。

\begin{adjustwidth}{2cm}{2cm}
  \parpic[l]{
  \includegraphics[width=1cm]{note.png}
  }
  \noindent
当编写Perl代码时，最后永远同时使用\verb|use strict;|和\verb|use warnings;|。
\end{adjustwidth}

\subsection{Fixing Bugs with Comments and Print Statements}
Sometimes you can identify misbehaving code by selectively commenting out sections of the program until you find the part that seems to cause the problem. You can also add \verb|print| statements at suspicious parts of a misbehaving program to check what certain variables are doing. Both of these are time-honored programming techniques, and they work well in almost any programming language.

Commenting out sections of code can be particularly helpful when the error messages that you get from Perl don't point you directly at the offending line. This happens occasionally. When it does happen you may, by trial and error, discover that commenting out a small section of code causes the error messages to go away; then you know where the error is occurring.

Adding \verb|print| statements can also be a quick way to pinpoint a problem, especially if you already have some idea of where the problem is. As a novice programmer, however, you may find that using the Perl debugger is easier than adding \verb|print| statements. In the debugger, you can easily set \verb|print| statements at any line. For instance, the following debugger command says to print the values of \verb|$i| and \verb|$k| before line 48:

\begin{lstlisting}
a 48 print "$i $k\n"
\end{lstlisting}

Once you learn how to do it, this method is generally faster and easier than editing the Perl program and adding \verb|print| statements by hand. Using this method is partly a matter of taste, since some extremely good Perl programmers prefer to do it the old-fashioned way, by adding \verb|print| statements. 

\subsection{The Perl Debugger}
My favorite way to deal with nonobvious bugs in my programs is to use the Perl debugger. The problem with bugs in code is that once a program starts running, all you can see is the output; you can't see the steps a program is taking. The Perl debugger lets you examine your program in detail, step by step, and almost always can lead you quickly to the problem. You'll also find that it's easy to use with a little practice.

There are situations the Perl debugger can't handle well: interacting processes that depend on timing considerations, for instance. The debugger can examine only one program at a time, and while examining, it stops the program, so timing considerations with other processes go right out the window.

For most purposes, the Perl debugger is a great, essential, programming tool. This section introduces its most important features. 

\subsubsection{A program with bugs}
\autoref{exam:example6.4} has some bugs we can examine. It's supposed to take a sequence and two bases, and output everything from those two bases to the end of the sequence (if it can find them in the sequence). The two bases can be given as an argument, or if no argument is given, the program uses the bases TA by default.

There is one new thing in \autoref{exam:example6.4}. The next statement affects the control flow in a loop. It immediately returns the control flow to the next iteration of the loop, skipping whatever else would have followed.  Also, you may want to recall \verb|$_|, which we discussed back in \autoref{exam:example5.5}
in the context of a \verb|foreach| loop. 

\textbf{Example 6-4. A program with a bug or two}
\lstinputlisting[label=exam:example6.4]{./scripts/example6-4.pl}

Here's the output of two runs of \autoref{exam:example6.1}:

\begin{lstlisting}[language=bash]
$ perl example 6-4 AA

$ perl example 6-4
TA
\end{lstlisting}

Huh? It should have printed out \verb|AAGGCGA| when called with the argument \verb|AA|, and \verb|TAAGGCGA| when called with no arguments. There must be a bug in this program. But, if you look it over, there isn't anything obviously wrong. It's time to fire up the debugger. What follows is an actual debugging session on \autoref{exam:example6.4}, interspersed with comments to explain what's happening and why. 

\subsubsection{How to start and stop the debugger}
The debugger runs interactively, and you control it from the keyboard.\footnote{You also can run it automatically to produce a trace of the program in a file.} The most common way to start it is by giving the \textit{-d} switch to Perl at the command line. Since you're using buggy \autoref{exam:example6.4} to demonstrate the debugger, here's how to start that program:

\begin{lstlisting}[language=bash]
perl -d example6-4
\end{lstlisting}

Alternatively, you could have added a \textit{-d} flag to the command interpreter:

\begin{lstlisting}[language=bash]
#!/usr/bin/perl -d
\end{lstlisting}

On systems such as Unix and Linux where command interpretation works, this starts the debugger automatically.

To stop the debugger, simply type \verb|q|.

\subsubsection{Debugger command summary}
First, let's try to find the bug in \autoref{exam:example6.4} when it's called with no arguments:

\begin{lstlisting}
$ perl -d example6-4
Default die handler restored.

Loading DB routines from perl5db.pl version 1.07
Editor support available.

Enter h or 'h h' for help, or 'man perldebug' for more help.

main::(example6-4:11):    my $dna = 'CGACGTCTTCTAAGGCGA';
  DB<1> 
\end{lstlisting}

Let's stop right here at the beginning and look at a few things. After some messages, which may not mean a whole lot right now, you get the excellent information that the commands \verb|h| and \verb|h h| give more help. Let's try \verb|h h|:

\begin{lstlisting}
  DB<1> h h
List/search source lines:               Control script execution:
  l [ln|sub]  List source code            T           Stack trace
  - or .      List previous/current line  s [expr]    Single step [in expr]
  w [line]    List around line            n [expr]    Next, steps over subs
  f filename  View source in file         <CR/Enter>  Repeat last n or s
  /pattern/ ?patt?   Search forw/backw    r           Return from subroutine
  v          Show versions of modules     c [ln|sub]  Continue until position
Debugger controls:                        L           List break/watch/actions
  O [...]     Set debugger options        t [expr]    Toggle trace [trace expr]
  <[<]|{[{]|>[>] [cmd] Do pre/post-prompt b [ln|event|sub] [cnd] Set breakpoint
  ! [N|pat]   Redo a previous command     d [ln] or D Delete a/all breakpoints
  H [-num]    Display last num commands   a [ln] cmd  Do cmd before line
  = [a val]   Define/list an alias        W expr      Add a watch expression
  h [db_cmd]  Get help on command         A or W      Delete all actions/watch
  |[|]db_cmd  Send output to pager        ![!] syscmd Run cmd in a subprocess
  q or ^D     Quit                        R           Attempt a restart
Data Examination:       expr     Execute perl code, also see: s,n,t expr
  x|m expr      Evals expr in list context, dumps the result or lists methods.
  p expr        Print expression (uses script's current package).
  S [[!]pat]    List subroutine names [not] matching pattern
  V [Pk [Vars]] List Variables in Package.  Vars can be ~pattern or !pattern.
  X [Vars]     Same as "V current_package [Vars]".
For more help, type h cmd_letter, or run man perldebug for all docs.
  DB<2> 
\end{lstlisting}

It's a bit hard to read, but you have a concise summary of the debugger commands. You can also use the \verb|h| command, which gives several screens worth of information. The \verb=| h= command displays those several pages one at a time; the pipe at the beginning of a debugger command pipes the output through a pager, which typically advances a page when you hit the spacebar on your keyboard. You should try those out. Right now, however, let's focus on a few of the most useful commands. But remember that typing \verb|h command| can give you help about the command. 

\subsubsection{Stepping through statements with the debugger}
Back to the immediate problem. When you started up the debugger, you saw that it stopped on the first line of real Perl code:

\begin{lstlisting}
  main::(example6-4:11):    my $dna = 'CGACGTCTTCTAAGGCGA';
\end{lstlisting}

There's an important point about the debugger you should understand right away. It shows the line it's about to execute, not the line it just executed.

So really, \autoref{exam:example6.4} hasn't done anything yet. You can see from the command summary that \verb|p| tells the debugger to print out values. If you ask it to print the value of \verb|$dna|, you'll find:

\begin{lstlisting}
  DB<2> p $dna

  DB<3> 
\end{lstlisting}

It didn't show anything because there's nothing to show; it hasn't even seen the variable \verb|$dna| yet. So you should execute the statement. There are two commands to use: \verb|n| or \verb|s| both execute the statement being displayed. (The difference is that \verb|n| or "next" skips the plunge into a subroutine call, treating it like a single statement; \verb|s| or "single step" enters a subroutine and single step you through that code as well.) Once you've given one of these commands, you can just hit Enter to repeat the same command.

Since there aren't any subroutines, you needn't worry about choosing between \verb|n| and \verb|s|, so let's use n: 

\begin{lstlisting}
 DB<3> n
 main::(example6-4:12):    my @dna;
   DB<3> 
\end{lstlisting}

This shows the next line (you can see the line numbers of the Perl program at the end of the prompt). If you wish to see more lines, the \verb|w| or "window" command will serve: 

\begin{lstlisting}
  DB<3> w
9
10      # declare and initialize variables
11:     my $dna = 'CGACGTCTTCTAAGGCGA';
12==>   my @dna;
13:     my $receivingcommittment;
14:     my $previousbase = ''; 
15
16:     my $subsequence = '';
17
18:     if (@ARGV) {
  DB<3>
\end{lstlisting}

The current line—the line that will be executed next—is highlighted with an arrow (\verb|==>|).

The \verb|w| seems like a useful thing. Let's get more information about it with the help command \verb|h w|: 

\begin{lstlisting}
  DB<3> h w
w [line]        List window around line.
  DB<4> 
\end{lstlisting}

Actually, there's more—hitting \verb|w| repeatedly keeps showing more of the program; a minus sign backs up a screen. But enough of that.

Now that \verb|$dna| has been declared and initialized, the program seems wrong on the first statement: 

\begin{lstlisting}
  DB<4> p $dna
CGACGTCTTCTAAGGCGA
  DB<5> 
\end{lstlisting}

That's exactly what was expected. There's no bug, so let's continue examining the lines, printing out values here and there: 

\begin{lstlisting}
  DB<5> n
main::(example6-4:13):	my $receivingcommittment;
  DB<5> n
main::(example6-4:14):	my $previousbase = ''; 
  DB<5> n
main::(example6-4:16):	my $subsequence = '';
  DB<5> n
main::(example6-4:18):	if (@ARGV) {
  DB<5> p @ARGV

  DB<6> w
15
16:     my $subsequence = '';
17
18==>   if (@ARGV) {
19:         my $subsequence = $ARGV[0];
20      }else{
21:         $subsequence = 'TA';
22      }
23
24:     my $base1 = substr($subsequence, 0, 1);
  DB<6> n
main::(example6-4:21):	    $subsequence = 'TA';
  DB<6> n
main::(example6-4:24):	my $base1 = substr($subsequence, 0, 1);
  DB<6> p $subsequence
TA
  DB<7> n
main::(example6-4:25):	my $base2 = substr($subsequence, 1, 1);
  DB<7> n
main::(example6-4:28):	@dna = split ( '', $dna );
  DB<7> p $base1
T
  DB<8> p $base2
A
  DB<9>
\end{lstlisting}

So far, everything is as expected; the default subsequence \verb|TA| is being used, and the \verb|$base1| and \verb|$base2| variables are set to \verb|T| and \verb|A|, the first and second bases of the subsequence. Let's continue:

\begin{lstlisting}
  DB<9> n
main::(example6-4:39):    foreach (@dna) {
  DB<9> p @dna
CGACGTCTTCTAAGGCGA
  DB<10> p "@dna"
C G A C G T C T T C T A A G G C G A
  DB<11> 
\end{lstlisting}

This shows a trick with Perl and printing arrays: normally they are printed without any spacing between the elements, but enclosing an array in double quotes in a \verb|print| statement causes it to be displayed with spaces between the elements.

Again, everything seems okay, and we're about to enter a loop. Let's look at the whole loop first: 

\begin{lstlisting}
  DB<11> w
36       #
37       # At each loop, save the previous base.
38
39==>    foreach (@dna) {
40:          if ($receivingcommittment) {
41:              print;
42:              next;
43           } elsif ($previousbase eq $base1) {
44:              if ( /$base2/ ) {
45:                  print $base1, $base2; 
  DB<11> w
43           } elsif ($previousbase eq $base1) {
44:              if ( /$base2/ ) {
45:                  print $base1, $base2; 
46:                  $recievingcommitment = 1;
47               }
48           }
49:          $previousbase = $_;
50       }
51
52:      print "\n";
  DB<11>
\end{lstlisting}

Despite the few repeated lines resulting from the \verb|w| command, you can see the whole loop. Now you know something in here is going wrong: when you tested the program without giving it an argument, as it's running now, it took the default argument \verb|TA|, and so far it seemed okay. However, all it actually did in your test was to print out the \verb|TA| when it was supposed to print out everything in the string starting with the first occurrence of \verb|TA|. What's going wrong? 

\subsubsection{Setting breakpoints}
To figure out what's wrong, you can set a breakpoint in your code. A \textit{breakpoint} is a spot in your program where you tell the debugger to stop execution so you can poke around in the code. The Perl debugger lets you set breakpoints in various ways. They let you run the program, stopping only to examine it when a statement with a breakpoint is reached. That way, you don't have to step through every line of code. (If you have 5,000 lines of code, and the error happens when you hit a line of code that's first used when you're reading the 12,000th line of input, you'll be happy about this feature.)

Notice that the part of this loop that prints out the rest of the string, once the starting two bases have been found, is the \verb|if| block starting at line 40: 

\begin{lstlisting}
if ($receivingcommittment) {
  print;
  next;
}
\end{lstlisting}

Let's look at that \verb|$receivingcommittment| variable.

Here's one way to do this. Let's set a breakpoint at line 40. Type \verb|b 40| and then \verb|c| to continue, and the program proceeds until it hits line 40: 

\begin{lstlisting}
  DB<11> b 40
  DB<12> c
main::(example6-4:40):      if ($receivingcommittment) {
  DB<12> p
C
  DB<12> 
\end{lstlisting}

The last command, \verb|p|, prints out the element from the \verb|@dna| array you reached in the \verb|foreach| loop. Since you didn't specify a variable for the loop, it used the default \verb|$_| variable. Many Perl commands such as \verb|print| or pattern matching operate on the default \verb|$_| variable if no other variable is given. (It's the cousin of the \verb|@_| default array subroutines used to hold their parameters.) So the \verb|p| debugger command shows that you're operating on C from the \verb|@dna| array, which is the first character.

All well and good. But it would be good to have the program break when the variable \verb|$receivingcommittment| has a change in its value, and then single step from there, to see why the program isn't printing out the rest of the string. Recall that this variable is the flag whose change tells the program to print the rest of the string. First let's delete all other breakpoints: 

\begin{lstlisting}
  DB<12> D
Deleting all breakpoints...
\end{lstlisting}

You can "watch" the variable with \verb|W| like so: 

\begin{lstlisting}
  DB<12> W $receivingcommittment
  DB<13> c
TA
Debugged program terminated.  Use q to quit or R to restart,
  use O inhibit_exit to avoid stopping after program termination,
  h q, h R or h O to get additional info.  
  DB<13> 
\end{lstlisting}

Wait a minute! The \verb|W| command should indicate when \verb|$receivingcommittment| changes value. But when the program continued running with the \verb|c| command, it ran to the end, meaning that \verb|$receivingcommittment| never changed value. So let's start up the program again and break on the line that changes its value: 

\begin{lstlisting}
  DB<13> R
Warning: some settings and command-line options may be lost!
Default die handler restored.

Loading DB routines from perl5db.pl version 1.07
Editor support available.

Enter h or 'h h' for help, or 'man perldebug' for more help.

main::(example6-4:11):	my $dna = 'CGACGTCTTCTAAGGCGA';
  DB<13> w 45
42:              next;
43           } elsif ($previousbase eq $base1) {
44:              if ( /$base2/ ) {
45:                  print $base1, $base2; 
46:                  $recievingcommitment = 1;
47               }
48           }
49:          $previousbase = $_;
50       }
51
  DB<14> b 46
  DB<15> c
TAmain::(example6-4:46):             $recievingcommitment = 1;
  DB<15> n
main::(example6-4:49):          $previousbase = $_;
  DB<15> p $receivingcommittment

  DB<16> 
\end{lstlisting}

Huh? The code says it's assigning the variable a value of 1, but after you execute the code, with the \verb|n| and try to print out the value, it doesn't print anything.

If you stare harder at the program, you see that at line 66 you misspelled \verb|$receivingcommittment| as \verb|$recievingcommitment|. That explains everything; fix it and run it again:

\begin{lstlisting}[language=bash]
$ perl example6-4
TAAGGCGA 
\end{lstlisting}

Success! 

\subsubsection{Fixing another bug}
Now, did that fix the other bug when you ran \autoref{exam:example6.4} with an argument?

\begin{lstlisting}[language=bash]
$ perl example6-4 AA
GACGTCTTCTAAGGCGA
\end{lstlisting}

Again, huh? You expected \verb|AAGGCGA|. Can there be another bug in the program? Let's try the debugger again:

\begin{lstlisting}
$ perl -d example6-4 AA
Default die handler restored.

Loading DB routines from perl5db.pl version 1.07
Editor support available.

Enter h or 'h h' for help, or 'man perldebug' for more help.

main::(example6-4:11):	my $dna = 'CGACGTCTTCTAAGGCGA';
  DB<1> n
main::(example6-4:12):	my @dna;
  DB<1> n
main::(example6-4:13):	my $receivingcommittment;
  DB<1> n
main::(example6-4:14):	my $previousbase = ''; 
  DB<1> n
main::(example6-4:16):	my $subsequence = '';
  DB<1> n
main::(example6-4:18):	if (@ARGV) {
  DB<1> n
main::(example6-4:19):	    my $subsequence = $ARGV[0];
  DB<1> n
main::(example6-4:24):	my $base1 = substr($subsequence, 0, 1);
  DB<1> n
main::(example6-4:25):	my $base2 = substr($subsequence, 1, 1);
  DB<1> n
main::(example6-4:28):	@dna = split ( '', $dna );
  DB<1> p $subsequence

  DB<2> p $base1

  DB<3> p $base2

  DB<4> 
\end{lstlisting}

Okay, for some reason the \verb|$subsequence|, and therefore the \verb|$base1| and \verb|$base2| variables, are not getting set right. How come?

Check out line 19 where you declared a new \verb|my| variable in the block of the \verb|if| statement with the same name, \verb|$subsequence|. That's the variable you're setting, but it's disappearing as soon as the \verb|if| statement is over, because it's scoped in the block since it's a \verb|my| variable.

So again, you fix that problem by removing the \verb|my| declaration on line 19 and instead inserting an assignment \verb|$subsequence = $ARGV[0];| and run the program again:

\begin{lstlisting}
$ perl example6-4
TAAGGCGA
$ perl example6-4 AA
AAGGCGA 
\end{lstlisting}

Here, finally, is success.

\subsubsection{use warnings; and use strict; redux}
\autoref{exam:example6.4} was somewhat artificial. It turns out that these problems would have been reported easily if warnings had been used. So let's see an actual example of the benefits of \verb|use strict;| and \verb|use warnings;|, as discussed earlier in this chapter.

If you go back to the original \autoref{exam:example6.4} and add the \verb|use warnings;| directive near the top of the program, you get the following output: 

\begin{lstlisting}
$ perl example6-4 
Name "main::recievingcommitment" used only once: possible typo at example6-4 line 47.
TA 
\end{lstlisting}

As you see, the warnings found the first bug immediately. They noticed there was a variable that was used only once, usually a sign of a misspelled variable. (I can never spell "receiving" or "commitment" properly.) So fix the misspelling at line 66, and run it again: 

\begin{lstlisting}
$ perl example6-4 
TAAGGCGA
$ perl example6-4 AA
substr outside of string at example6-4 line 26.
Use of uninitialized value in regexp compilation at example6-4 line 45.
Use of uninitialized value in print at example6-4 line 46.
GACGTCTTCTAAGGCGA   
\end{lstlisting}

So, the first bug is fixed. The second bug remains with a few warnings that are, perhaps, hard to understand. But focus on the first error message, and see that it complains about line 26:

\begin{lstlisting}
my $base2 = substr($subsequence, 1, 1);
\end{lstlisting}

So, there's something wrong with \verb|$subsequence|. Often, error messages will be off by one line, so it may well be that the error starts on the line before, the first time \verb|$subsequence| is operated on by the \textit{substr}. But that's not the case here.

Nonetheless, the warnings have pointed directly to the problem. In this case, you still have to take a little initiative; look back at the \verb|$subsequence| variable and notice the extra \verb|my| declaration within the \verb|if| block on line 20 that is preventing the variable from being initialized properly. Now this is not necessarily always a bug—declaring a variable scoped within a block and that overrides another variable of the same name that is outside the block. In fact, it's perfectly legal, so the programmers who wrote the warnings did not flag it as an obvious error. However, it seems to have caused a real problem here!

One final point: if you go back to the original, buggy program, notice there's no \verb|use strict;| in the program. If you add that and run the program without arguments, you get the following: 

\begin{lstlisting}
$ perl example6-4   
Global symbol "$recievingcommitment" requires explicit package name at example6-4 line 47.
Execution of example6-4 aborted due to compilation errors.
\end{lstlisting}

Fixing the misspelled variable, and running the program with the argument, you get:

\begin{lstlisting}
$ perl example6-4 AA
GACGTCTTCTAAGGCGA
\end{lstlisting}

You can see that \verb|use strict;| didn't help for the other bug. Remember, it's best to employ both \verb|use strict;| and \verb|use warnings;|.

\section{Exercises}
\textcolor{red}{\textit{Exercise 6.1}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to concatenate two strings of DNA.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.2}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to report the percentage of each nucleotide in DNA.  You've seen the plus operator \verb|+|. You will also want to use the divide operator \verb|/| and the multiply operator \verb|*|. Count the number of each nucleotide, divide by the total length of the DNA, then multiply by 100 to get the percentage. Your arguments should be the DNA and the nucleotide you want to report on. The \verb|int| function can be used to discard digits after the decimal point, if needed.
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.3}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to prompt a user with any message, and collect the user's answer. The subroutine's argument should be the message, and the return value should be the (one-line) answer. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.4}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to look for command-line arguments such as \verb|-help|, \verb|-h|, and \verb|--help|. Recall that command-line arguments appear in the \verb|@ARGV| array. Call your subroutine from a main program. If you give the program any of the named command-line arguments, when you pass them into the subroutine it should return a true value. If this is the case, have the program print out a help message in a \verb|$USAGE| variable and exit. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.5}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to check if a file exists, is a regular file, and is nonzero in size. Use the \verb|file test| operators (See \autoref{chap:chapterab}). 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.6}}
\begin{adjustwidth}{1cm}{}
Use Exercise 6.3 in a subroutine that keeps prompting until a valid file is entered by the user or until five attempts have failed. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.7}}
\begin{adjustwidth}{1cm}{}
Write a module that contains subroutines that report various statistics on DNA sequences, for instance length, GC content, presence or absence of poly-T sequences (long stretches of mostly T's at the 5' (left) end of many \verb|$DNA| sequences), or other measures of interest. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.8}}
\begin{adjustwidth}{1cm}{}
Write a subroutine to do something a biologist normally does. (Here's an opportunity to look around the lab and write a useful program!) 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.9}}
\begin{adjustwidth}{1cm}{}
Read the documentation about the debugger and become familiar with its use by applying it during your programming. 
\end{adjustwidth}

\textcolor{red}{\textit{Exercise 6.10}}
\begin{adjustwidth}{1cm}{}
Write a subroutine that alters an array of lines in a file. Use pass by reference for the array. Pass the subroutine a reference to the array, a regular expression, and a string to replace the regular expression. All the lines of the array should be altered by substituting the matches found for the regular expression by the replacement string.
\end{adjustwidth}
